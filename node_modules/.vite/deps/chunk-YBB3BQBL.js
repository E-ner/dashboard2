import {
  ListBase
} from "./chunk-THSAVX3Y.js";
import {
  Input
} from "./chunk-6I4VWWOD.js";
import {
  Animation,
  Browser,
  Button,
  ChildProperty,
  Collection,
  Component,
  Event,
  EventHandler,
  HijriParser,
  Internationalization,
  KeyboardEvents,
  L10n,
  NotifyPropertyChanges,
  Popup,
  Property,
  addClass,
  append,
  attributes,
  cldrData,
  closest,
  createElement,
  detach,
  extend,
  formatUnit,
  getDefaultDateObject,
  getUniqueID,
  getValue,
  isNullOrUndefined,
  isUndefined,
  merge,
  prepend,
  remove,
  removeClass,
  rippleEffect,
  select,
  setStyleAttribute,
  setValue,
  throwError
} from "./chunk-6HHTMAXE.js";

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/enum.js
var PdfHorizontalAlignment;
(function(PdfHorizontalAlignment2) {
  PdfHorizontalAlignment2[PdfHorizontalAlignment2["Left"] = 0] = "Left";
  PdfHorizontalAlignment2[PdfHorizontalAlignment2["Center"] = 1] = "Center";
  PdfHorizontalAlignment2[PdfHorizontalAlignment2["Right"] = 2] = "Right";
})(PdfHorizontalAlignment || (PdfHorizontalAlignment = {}));
var PdfVerticalAlignment;
(function(PdfVerticalAlignment2) {
  PdfVerticalAlignment2[PdfVerticalAlignment2["Top"] = 0] = "Top";
  PdfVerticalAlignment2[PdfVerticalAlignment2["Middle"] = 1] = "Middle";
  PdfVerticalAlignment2[PdfVerticalAlignment2["Bottom"] = 2] = "Bottom";
})(PdfVerticalAlignment || (PdfVerticalAlignment = {}));
var PdfTextAlignment;
(function(PdfTextAlignment2) {
  PdfTextAlignment2[PdfTextAlignment2["Left"] = 0] = "Left";
  PdfTextAlignment2[PdfTextAlignment2["Center"] = 1] = "Center";
  PdfTextAlignment2[PdfTextAlignment2["Right"] = 2] = "Right";
  PdfTextAlignment2[PdfTextAlignment2["Justify"] = 3] = "Justify";
})(PdfTextAlignment || (PdfTextAlignment = {}));
var TextRenderingMode;
(function(TextRenderingMode2) {
  TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
  TextRenderingMode2[TextRenderingMode2["Stroke"] = 1] = "Stroke";
  TextRenderingMode2[TextRenderingMode2["FillStroke"] = 2] = "FillStroke";
  TextRenderingMode2[TextRenderingMode2["None"] = 3] = "None";
  TextRenderingMode2[TextRenderingMode2["ClipFlag"] = 4] = "ClipFlag";
  TextRenderingMode2[TextRenderingMode2["ClipFill"] = 4] = "ClipFill";
  TextRenderingMode2[TextRenderingMode2["ClipStroke"] = 5] = "ClipStroke";
  TextRenderingMode2[TextRenderingMode2["ClipFillStroke"] = 6] = "ClipFillStroke";
  TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
})(TextRenderingMode || (TextRenderingMode = {}));
var PdfLineJoin;
(function(PdfLineJoin2) {
  PdfLineJoin2[PdfLineJoin2["Miter"] = 0] = "Miter";
  PdfLineJoin2[PdfLineJoin2["Round"] = 1] = "Round";
  PdfLineJoin2[PdfLineJoin2["Bevel"] = 2] = "Bevel";
})(PdfLineJoin || (PdfLineJoin = {}));
var PdfLineCap;
(function(PdfLineCap2) {
  PdfLineCap2[PdfLineCap2["Flat"] = 0] = "Flat";
  PdfLineCap2[PdfLineCap2["Round"] = 1] = "Round";
  PdfLineCap2[PdfLineCap2["Square"] = 2] = "Square";
})(PdfLineCap || (PdfLineCap = {}));
var PdfDashStyle;
(function(PdfDashStyle2) {
  PdfDashStyle2[PdfDashStyle2["Solid"] = 0] = "Solid";
  PdfDashStyle2[PdfDashStyle2["Dash"] = 1] = "Dash";
  PdfDashStyle2[PdfDashStyle2["Dot"] = 2] = "Dot";
  PdfDashStyle2[PdfDashStyle2["DashDot"] = 3] = "DashDot";
  PdfDashStyle2[PdfDashStyle2["DashDotDot"] = 4] = "DashDotDot";
  PdfDashStyle2[PdfDashStyle2["Custom"] = 5] = "Custom";
})(PdfDashStyle || (PdfDashStyle = {}));
var PdfFillMode;
(function(PdfFillMode2) {
  PdfFillMode2[PdfFillMode2["Winding"] = 0] = "Winding";
  PdfFillMode2[PdfFillMode2["Alternate"] = 1] = "Alternate";
})(PdfFillMode || (PdfFillMode = {}));
var PdfColorSpace;
(function(PdfColorSpace2) {
  PdfColorSpace2[PdfColorSpace2["Rgb"] = 0] = "Rgb";
  PdfColorSpace2[PdfColorSpace2["Cmyk"] = 1] = "Cmyk";
  PdfColorSpace2[PdfColorSpace2["GrayScale"] = 2] = "GrayScale";
  PdfColorSpace2[PdfColorSpace2["Indexed"] = 3] = "Indexed";
})(PdfColorSpace || (PdfColorSpace = {}));
var PdfBlendMode;
(function(PdfBlendMode2) {
  PdfBlendMode2[PdfBlendMode2["Normal"] = 0] = "Normal";
  PdfBlendMode2[PdfBlendMode2["Multiply"] = 1] = "Multiply";
  PdfBlendMode2[PdfBlendMode2["Screen"] = 2] = "Screen";
  PdfBlendMode2[PdfBlendMode2["Overlay"] = 3] = "Overlay";
  PdfBlendMode2[PdfBlendMode2["Darken"] = 4] = "Darken";
  PdfBlendMode2[PdfBlendMode2["Lighten"] = 5] = "Lighten";
  PdfBlendMode2[PdfBlendMode2["ColorDodge"] = 6] = "ColorDodge";
  PdfBlendMode2[PdfBlendMode2["ColorBurn"] = 7] = "ColorBurn";
  PdfBlendMode2[PdfBlendMode2["HardLight"] = 8] = "HardLight";
  PdfBlendMode2[PdfBlendMode2["SoftLight"] = 9] = "SoftLight";
  PdfBlendMode2[PdfBlendMode2["Difference"] = 10] = "Difference";
  PdfBlendMode2[PdfBlendMode2["Exclusion"] = 11] = "Exclusion";
  PdfBlendMode2[PdfBlendMode2["Hue"] = 12] = "Hue";
  PdfBlendMode2[PdfBlendMode2["Saturation"] = 13] = "Saturation";
  PdfBlendMode2[PdfBlendMode2["Color"] = 14] = "Color";
  PdfBlendMode2[PdfBlendMode2["Luminosity"] = 15] = "Luminosity";
})(PdfBlendMode || (PdfBlendMode = {}));
var PdfGraphicsUnit;
(function(PdfGraphicsUnit2) {
  PdfGraphicsUnit2[PdfGraphicsUnit2["Centimeter"] = 0] = "Centimeter";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Pica"] = 1] = "Pica";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Pixel"] = 2] = "Pixel";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Point"] = 3] = "Point";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Inch"] = 4] = "Inch";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Document"] = 5] = "Document";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Millimeter"] = 6] = "Millimeter";
})(PdfGraphicsUnit || (PdfGraphicsUnit = {}));
var PdfGridImagePosition;
(function(PdfGridImagePosition2) {
  PdfGridImagePosition2[PdfGridImagePosition2["Fit"] = 0] = "Fit";
  PdfGridImagePosition2[PdfGridImagePosition2["Center"] = 1] = "Center";
  PdfGridImagePosition2[PdfGridImagePosition2["Stretch"] = 2] = "Stretch";
  PdfGridImagePosition2[PdfGridImagePosition2["Tile"] = 3] = "Tile";
})(PdfGridImagePosition || (PdfGridImagePosition = {}));
var PdfTextDirection;
(function(PdfTextDirection2) {
  PdfTextDirection2[PdfTextDirection2["None"] = 0] = "None";
  PdfTextDirection2[PdfTextDirection2["LeftToRight"] = 1] = "LeftToRight";
  PdfTextDirection2[PdfTextDirection2["RightToLeft"] = 2] = "RightToLeft";
})(PdfTextDirection || (PdfTextDirection = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-operators.js
var Operators = (
  /** @class */
  function() {
    function Operators2() {
      this.forTest = "test";
      this.forTest = Operators2.obj;
    }
    Operators2.obj = "obj";
    Operators2.endObj = "endobj";
    Operators2.r = "R";
    Operators2.whiteSpace = " ";
    Operators2.slash = "/";
    Operators2.newLine = "\r\n";
    Operators2.stream = "stream";
    Operators2.endStream = "endstream";
    Operators2.xref = "xref";
    Operators2.f = "f";
    Operators2.n = "n";
    Operators2.trailer = "trailer";
    Operators2.startxref = "startxref";
    Operators2.eof = "%%EOF";
    Operators2.header = "%PDF-1.5";
    Operators2.beginText = "BT";
    Operators2.endText = "ET";
    Operators2.beginPath = "m";
    Operators2.appendLineSegment = "l";
    Operators2.stroke = "S";
    Operators2.fill = "f";
    Operators2.fillEvenOdd = "f*";
    Operators2.fillStroke = "B";
    Operators2.fillStrokeEvenOdd = "B*";
    Operators2.appendbeziercurve = "c";
    Operators2.appendRectangle = "re";
    Operators2.saveState = "q";
    Operators2.restoreState = "Q";
    Operators2.paintXObject = "Do";
    Operators2.modifyCtm = "cm";
    Operators2.modifyTM = "Tm";
    Operators2.setLineWidth = "w";
    Operators2.setLineCapStyle = "J";
    Operators2.setLineJoinStyle = "j";
    Operators2.setDashPattern = "d";
    Operators2.setFlatnessTolerance = "i";
    Operators2.closePath = "h";
    Operators2.closeStrokePath = "s";
    Operators2.closeFillStrokePath = "b";
    Operators2.setCharacterSpace = "Tc";
    Operators2.setWordSpace = "Tw";
    Operators2.setHorizontalScaling = "Tz";
    Operators2.setTextLeading = "TL";
    Operators2.setFont = "Tf";
    Operators2.setRenderingMode = "Tr";
    Operators2.setTextRise = "Ts";
    Operators2.setTextScaling = "Tz";
    Operators2.setCoords = "Td";
    Operators2.goToNextLine = "T*";
    Operators2.setText = "Tj";
    Operators2.setTextWithFormatting = "TJ";
    Operators2.setTextOnNewLine = "'";
    Operators2.selectcolorspaceforstroking = "CS";
    Operators2.selectcolorspacefornonstroking = "cs";
    Operators2.setrbgcolorforstroking = "RG";
    Operators2.setrbgcolorfornonstroking = "rg";
    Operators2.setcmykcolorforstroking = "K";
    Operators2.setcmykcolorfornonstroking = "k";
    Operators2.setgraycolorforstroking = "G";
    Operators2.setgraycolorfornonstroking = "g";
    Operators2.clipPath = "W";
    Operators2.clipPathEvenOdd = "W*";
    Operators2.endPath = "n";
    Operators2.setGraphicsState = "gs";
    Operators2.comment = "%";
    Operators2.evenOdd = "*";
    Operators2.setMiterLimit = "M";
    Operators2.setColorAndPattern = "scn";
    Operators2.setColorAndPatternStroking = "SCN";
    return Operators2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/collections/utils.js
function defaultToString(item) {
  if (Object.prototype.toString.call(item) === "[object String]") {
    return "$s" + item;
  } else {
    return "$o" + item.toString();
  }
}

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/collections/dictionary.js
var Dictionary = (
  /** @class */
  function() {
    function Dictionary2(toStringFunction) {
      this.table = {};
      this.nElements = 0;
      this.toStr = toStringFunction || defaultToString;
    }
    Dictionary2.prototype.getValue = function(key) {
      var pair = this.table["$" + this.toStr(key)];
      if (typeof pair === "undefined") {
        return void 0;
      }
      return pair.value;
    };
    Dictionary2.prototype.setValue = function(key, value) {
      var ret;
      var k = "$" + this.toStr(key);
      var previousElement = this.table[k];
      this.nElements++;
      ret = void 0;
      this.table[k] = {
        key,
        value
      };
      return ret;
    };
    Dictionary2.prototype.remove = function(key) {
      var k = "$" + this.toStr(key);
      var previousElement = this.table[k];
      delete this.table[k];
      this.nElements--;
      return previousElement.value;
    };
    Dictionary2.prototype.keys = function() {
      var keysArray = [];
      var namesOfKeys = Object.keys(this.table);
      for (var index1 = 0; index1 < namesOfKeys.length; index1++) {
        var pair1 = this.table[namesOfKeys[index1]];
        keysArray.push(pair1.key);
      }
      return keysArray;
    };
    Dictionary2.prototype.values = function() {
      var valuesArray = [];
      var namesOfValues = Object.keys(this.table);
      for (var index2 = 0; index2 < namesOfValues.length; index2++) {
        var pair2 = this.table[namesOfValues[index2]];
        valuesArray.push(pair2.value);
      }
      return valuesArray;
    };
    Dictionary2.prototype.containsKey = function(key) {
      var retutnValue = true;
      if (typeof this.getValue(key) === "undefined") {
        retutnValue = true;
      } else {
        retutnValue = false;
      }
      return !retutnValue;
    };
    Dictionary2.prototype.clear = function() {
      this.table = {};
      this.nElements = 0;
    };
    Dictionary2.prototype.size = function() {
      return this.nElements;
    };
    return Dictionary2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-number.js
var PdfNumber = (
  /** @class */
  function() {
    function PdfNumber2(value) {
      this.position5 = -1;
      this.value = value;
    }
    Object.defineProperty(PdfNumber2.prototype, "intValue", {
      /**
       * Gets or sets the `integer` value.
       * @private
       */
      get: function() {
        return this.value;
      },
      set: function(value) {
        this.value = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "isInteger", {
      /**
       * Gets or sets a value indicating whether this instance `is integer`.
       * @private
       */
      get: function() {
        return this.integer;
      },
      set: function(value) {
        this.integer = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status5;
      },
      set: function(value) {
        this.status5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving5;
      },
      set: function(value) {
        this.isSaving5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index5;
      },
      set: function(value) {
        this.index5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position5;
      },
      set: function(value) {
        this.position5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        var rValue = null;
        return rValue;
      },
      enumerable: true,
      configurable: true
    });
    PdfNumber2.prototype.save = function(writer) {
      writer.write(this.intValue.toString());
    };
    PdfNumber2.prototype.clone = function(crossTable) {
      var newNumber = new PdfNumber2(this.value);
      return newNumber;
    };
    PdfNumber2.floatToString = function(number) {
      var returnString = number.toFixed(2);
      if (returnString === "0.00") {
        returnString = ".00";
      }
      return returnString;
    };
    PdfNumber2.min = function(x, y, z) {
      var r = Math.min(x, y);
      return Math.min(z, r);
    };
    return PdfNumber2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-array.js
var PdfArray = (
  /** @class */
  function() {
    function PdfArray2(array) {
      this.startMark = "[";
      this.endMark = "]";
      this.position9 = -1;
      this.clonedObject9 = null;
      this.isFont = false;
      if (typeof array === "undefined") {
        this.internalElements = [];
      } else {
        if (typeof array !== "undefined" && !(array instanceof PdfArray2)) {
          var tempNumberArray = array;
          for (var index = 0; index < tempNumberArray.length; index++) {
            var pdfNumber = new PdfNumber(tempNumberArray[index]);
            this.add(pdfNumber);
          }
        } else {
          var tempArray = array;
          this.internalElements = [];
          for (var index = 0; index < tempArray.elements.length; index++) {
            this.internalElements.push(tempArray.elements[index]);
          }
        }
      }
    }
    PdfArray2.prototype.items = function(index) {
      return this.internalElements[index];
    };
    Object.defineProperty(PdfArray2.prototype, "count", {
      /**
       * Gets the `count`.
       * @private
       */
      get: function() {
        return this.internalElements.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status9;
      },
      set: function(value) {
        this.status9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving9;
      },
      set: function(value) {
        this.isSaving9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return this.clonedObject9;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position9;
      },
      set: function(value) {
        this.position9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index9;
      },
      set: function(value) {
        this.index9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "CrossTable", {
      /**
       * Returns `PdfCrossTable` associated with the object.
       * @private
       */
      get: function() {
        return this.pdfCrossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "elements", {
      /**
       * Gets the `elements` of the Pdf Array.
       * @private
       */
      get: function() {
        return this.internalElements;
      },
      enumerable: true,
      configurable: true
    });
    PdfArray2.prototype.add = function(element) {
      if (typeof this.internalElements === "undefined") {
        this.internalElements = [];
      }
      this.internalElements.push(element);
      this.markedChange();
    };
    PdfArray2.prototype.markedChange = function() {
      this.bChanged = true;
    };
    PdfArray2.prototype.contains = function(element) {
      var returnValue = false;
      for (var index = 0; index < this.internalElements.length; index++) {
        var tempElement = this.internalElements[index];
        var inputElement = element;
        if (tempElement != null && typeof tempElement !== "undefined" && inputElement != null && typeof inputElement !== "undefined") {
          if (tempElement.value === inputElement.value) {
            return true;
          }
        }
      }
      return returnValue;
    };
    PdfArray2.prototype.getItems = function(index) {
      return this.internalElements[index];
    };
    PdfArray2.prototype.save = function(writer) {
      writer.write(this.startMark);
      for (var i = 0, len = this.count; i < len; i++) {
        this.getItems(i).save(writer);
        if (i + 1 !== len) {
          writer.write(Operators.whiteSpace);
        }
      }
      writer.write(this.endMark);
    };
    PdfArray2.prototype.clone = function(crossTable) {
      this.clonedObject9 = null;
      var newArray = new PdfArray2();
      for (var index = 0; index < this.internalElements.length; index++) {
        var obj = this.internalElements[index];
        newArray.add(obj.clone(crossTable));
      }
      newArray.pdfCrossTable = crossTable;
      this.clonedObject9 = newArray;
      return newArray;
    };
    PdfArray2.fromRectangle = function(bounds) {
      var values = [bounds.x, bounds.y, bounds.width, bounds.height];
      var array = new PdfArray2(values);
      return array;
    };
    PdfArray2.prototype.insert = function(index, element) {
      if (index < this.internalElements.length && index > 0) {
        var tempElements = [];
        for (var i = 0; i < index; i++) {
          tempElements.push(this.internalElements[i]);
        }
        tempElements.push(element);
        for (var i = index; i < this.internalElements.length; i++) {
          tempElements.push(this.internalElements[i]);
        }
        this.internalElements = tempElements;
      } else {
        this.internalElements.push(element);
      }
      this.markChanged();
    };
    PdfArray2.prototype.indexOf = function(element) {
      return this.internalElements.indexOf(element);
    };
    PdfArray2.prototype.remove = function(element) {
      var index = this.internalElements.indexOf(element);
      this.internalElements[index] = null;
      this.markChanged();
    };
    PdfArray2.prototype.removeAt = function(index) {
      if (this.internalElements.length > index) {
        var tempArray = [];
        for (var i = 0; i < index; i++) {
          tempArray.push(this.internalElements[i]);
        }
        for (var i = index + 1; i < this.internalElements.length; i++) {
          tempArray.push(this.internalElements[i]);
        }
        this.internalElements = tempArray;
      }
      this.markChanged();
    };
    PdfArray2.prototype.clear = function() {
      this.internalElements = [];
      this.markChanged();
    };
    PdfArray2.prototype.markChanged = function() {
      this.bChanged = true;
    };
    return PdfArray2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-color.js
var PdfColor = (
  /** @class */
  function() {
    function PdfColor2(color1, color2, color3, color4) {
      if (typeof color1 === "undefined") {
        if (typeof color2 !== "undefined" && typeof color3 !== "undefined" && typeof color4 !== "undefined") {
          this.assignRGB(color2, color3, color4);
        } else {
          this.filled = false;
        }
      } else if (color1 instanceof PdfColor2) {
        this.redColor = color1.r;
        this.greenColor = color1.g;
        this.blueColor = color1.b;
        this.grayColor = color1.gray;
        this.alpha = color1.alpha;
        this.filled = this.alpha !== 0;
      } else if (typeof color1 === "number" && typeof color2 === "undefined" && typeof color3 === "undefined" && typeof color4 === "undefined") {
        if (color1 < 0) {
          color1 = 0;
        }
        if (color1 > 1) {
          color1 = 1;
        }
        this.redColor = color1 * PdfColor2.maxColourChannelValue;
        this.greenColor = color1 * PdfColor2.maxColourChannelValue;
        this.blueColor = color1 * PdfColor2.maxColourChannelValue;
        this.cyanColor = color1;
        this.magentaColor = color1;
        this.yellowColor = color1;
        this.blackColor = color1;
        this.grayColor = color1;
        this.alpha = PdfColor2.maxColourChannelValue;
        this.filled = true;
      } else if (typeof color4 === "undefined") {
        this.assignRGB(color1, color2, color3);
      } else {
        this.assignRGB(color2, color3, color4, color1);
      }
    }
    PdfColor2.prototype.assignRGB = function(r, g, b, a) {
      if (typeof r === "undefined" || typeof g === "undefined" || typeof b === "undefined") {
        this.filled = false;
      } else {
        this.cyanColor = 0;
        this.magentaColor = 0;
        this.yellowColor = 0;
        this.blackColor = 0;
        this.grayColor = 0;
        this.redColor = r;
        this.greenColor = g;
        this.blueColor = b;
        if (typeof a === "undefined") {
          this.alpha = PdfColor2.maxColourChannelValue;
        } else {
          this.alpha = a;
        }
        this.filled = true;
        this.assignCMYK(r, g, b);
      }
    };
    PdfColor2.prototype.assignCMYK = function(r, g, b) {
      var red = r / PdfColor2.maxColourChannelValue;
      var green = g / PdfColor2.maxColourChannelValue;
      var blue = b / PdfColor2.maxColourChannelValue;
      var black = PdfNumber.min(1 - red, 1 - green, 1 - blue);
      var cyan = black === 1 ? 0 : (1 - red - black) / (1 - black);
      var magenta = black === 1 ? 0 : (1 - green - black) / (1 - black);
      var yellow = black === 1 ? 0 : (1 - blue - black) / (1 - black);
      this.blackColor = black;
      this.cyanColor = cyan;
      this.magentaColor = magenta;
      this.yellowColor = yellow;
    };
    Object.defineProperty(PdfColor2.prototype, "r", {
      //Properties
      // public static get Empty():PdfColor
      // {
      //     return this.s_emptyColor
      // }
      /**
       * Gets or sets `Red` channel value.
       * @private
       */
      get: function() {
        return this.redColor;
      },
      set: function(value) {
        this.redColor = value;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "red", {
      /**
       * Gets the `Red` color
       * @private
       */
      get: function() {
        return this.r / PdfColor2.maxColourChannelValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "b", {
      /**
       * Gets or sets `Blue` channel value.
       * @private
       */
      get: function() {
        return this.blueColor;
      },
      set: function(value) {
        this.blueColor = value;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "blue", {
      /**
       * Gets the `blue` color.
       * @private
       */
      get: function() {
        return this.b / PdfColor2.maxColourChannelValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "c", {
      /**
       * Gets or sets `Cyan` channel value.
       * @private
       */
      get: function() {
        return this.cyanColor;
      },
      set: function(value) {
        if (value < 0) {
          this.cyanColor = 0;
        } else if (value > 1) {
          this.cyanColor = 1;
        } else {
          this.cyanColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "k", {
      /**
       * Gets or sets `Black` channel value.
       * @private
       */
      get: function() {
        return this.blackColor;
      },
      set: function(value) {
        if (value < 0) {
          this.blackColor = 0;
        } else if (value > 1) {
          this.blackColor = 1;
        } else {
          this.blackColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "m", {
      /**
       * Gets or sets `Magenta` channel value.
       * @private
       */
      get: function() {
        return this.magentaColor;
      },
      set: function(value) {
        if (value < 0) {
          this.magentaColor = 0;
        } else if (value > 1) {
          this.magentaColor = 1;
        } else {
          this.magentaColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "y", {
      /**
       * Gets or sets `Yellow` channel value.
       * @private
       */
      get: function() {
        return this.yellowColor;
      },
      set: function(value) {
        if (value < 0) {
          this.yellowColor = 0;
        } else if (value > 1) {
          this.yellowColor = 1;
        } else {
          this.yellowColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "g", {
      /**
       *  Gets or sets `Green` channel value.
       * @private
       */
      get: function() {
        return this.greenColor;
      },
      set: function(value) {
        this.greenColor = value;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "green", {
      /**
       * Gets the `Green` color.
       * @private
       */
      get: function() {
        return this.g / PdfColor2.maxColourChannelValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "gray", {
      /**
       * Gets or sets `Gray` channel value.
       * @private
       */
      get: function() {
        return (this.redColor + this.greenColor + this.blueColor) / (PdfColor2.maxColourChannelValue * 3);
      },
      set: function(value) {
        if (value < 0) {
          this.grayColor = 0;
        } else if (value > 1) {
          this.grayColor = 1;
        } else {
          this.grayColor = value;
        }
        this.r = this.grayColor * PdfColor2.maxColourChannelValue;
        this.g = this.grayColor * PdfColor2.maxColourChannelValue;
        this.b = this.grayColor * PdfColor2.maxColourChannelValue;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "isEmpty", {
      /**
       * Gets whether the PDFColor `is Empty` or not.
       * @private
       */
      get: function() {
        return !this.filled;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "a", {
      /**
       * Gets or sets `Alpha` channel value.
       * @private
       */
      get: function() {
        return this.alpha;
      },
      set: function(value) {
        if (value < 0) {
          this.alpha = 0;
        } else {
          this.alpha = value;
        }
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    PdfColor2.prototype.toString = function(colorSpace, stroke) {
      if (this.isEmpty) {
        return "";
      }
      var str = "";
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          str = this.rgbToString(stroke);
          break;
        case PdfColorSpace.GrayScale:
          str = this.grayScaleToString(stroke);
          break;
        case PdfColorSpace.Cmyk:
          str = this.cmykToString(stroke);
          break;
      }
      return str;
    };
    PdfColor2.prototype.grayScaleToString = function(ifStroking) {
      var gray = this.gray;
      var colour = "";
      var obj = null;
      obj = ifStroking ? PdfColor2.grayStringsSroke.containsKey(gray) ? PdfColor2.grayStringsSroke.getValue(gray) : null : PdfColor2.grayStringsFill.containsKey(gray) ? PdfColor2.grayStringsFill.getValue(gray) : null;
      if (obj == null) {
        if (ifStroking) {
          colour = gray.toString() + " G";
          PdfColor2.grayStringsSroke.setValue(gray, colour);
        }
      } else {
        colour = obj.toString();
      }
      return colour + Operators.newLine;
    };
    PdfColor2.prototype.rgbToString = function(ifStroking) {
      var r = this.r;
      var g = this.g;
      var b = this.b;
      var key = (r << 16) + (g << 8) + b;
      if (ifStroking) {
        key += 1 << 24;
      }
      var colour = "";
      var obj = null;
      if (PdfColor2.rgbStrings.containsKey(key)) {
        obj = PdfColor2.rgbStrings.getValue(key);
      }
      if (obj == null) {
        var red = r / PdfColor2.maxColourChannelValue;
        var green = g / PdfColor2.maxColourChannelValue;
        var blue = b / PdfColor2.maxColourChannelValue;
        if (ifStroking) {
          colour = red.toString() + " " + green.toString() + " " + blue.toString() + " RG";
        } else {
          colour = red.toString() + " " + green.toString() + " " + blue.toString() + " rg";
        }
        PdfColor2.rgbStrings.setValue(key, colour);
      } else {
        colour = obj.toString();
      }
      return colour + Operators.newLine;
    };
    PdfColor2.prototype.cmykToString = function(ifStroking) {
      var cyan = this.c;
      var magenta = this.m;
      var yellow = this.y;
      var black = this.b;
      var colour = "";
      colour = cyan.toString() + " " + magenta.toString() + " " + yellow.toString() + " " + black.toString() + " K";
      return colour + Operators.newLine;
    };
    PdfColor2.prototype.toArray = function(colorSpace) {
      var array = new PdfArray();
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          array.add(new PdfNumber(this.red));
          array.add(new PdfNumber(this.green));
          array.add(new PdfNumber(this.blue));
          break;
      }
      return array;
    };
    PdfColor2.rgbStrings = new Dictionary();
    PdfColor2.grayStringsSroke = new Dictionary();
    PdfColor2.grayStringsFill = new Dictionary();
    PdfColor2.maxColourChannelValue = 255;
    return PdfColor2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/drawing/pdf-drawing.js
var PointF = (
  /** @class */
  function() {
    function PointF2(x, y) {
      if (typeof x === "undefined") {
        this.x = 0;
        this.y = 0;
      } else {
        if (x !== null) {
          this.x = x;
        } else {
          this.x = 0;
        }
        if (y !== null) {
          this.y = y;
        } else {
          this.y = 0;
        }
      }
    }
    return PointF2;
  }()
);
var SizeF = (
  /** @class */
  function() {
    function SizeF2(width, height) {
      if (typeof height === "undefined") {
        this.height = 0;
        this.width = 0;
      } else {
        if (height !== null) {
          this.height = height;
        } else {
          this.height = 0;
        }
        if (width !== null) {
          this.width = width;
        } else {
          this.width = 0;
        }
      }
    }
    return SizeF2;
  }()
);
var RectangleF = (
  /** @class */
  function() {
    function RectangleF2(arg1, arg2, arg3, arg4) {
      if (typeof arg1 === typeof arg1 && typeof arg1 === "undefined") {
        this.x = 0;
        this.y = 0;
        this.height = 0;
        this.width = 0;
      } else {
        if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === "undefined") {
          var pointf = arg1;
          this.x = pointf.x;
          this.y = pointf.y;
          var sizef = arg2;
          this.height = sizef.height;
          this.width = sizef.width;
        } else {
          var x = arg1;
          var y = arg2;
          var width = arg3;
          var height = arg4;
          this.x = x;
          this.y = y;
          this.height = height;
          this.width = width;
        }
      }
    }
    return RectangleF2;
  }()
);
var Rectangle = (
  /** @class */
  function() {
    function Rectangle2(left, top, right, bottom) {
      this.left = left;
      this.top = top;
      this.right = right;
      this.bottom = bottom;
    }
    Object.defineProperty(Rectangle2.prototype, "width", {
      /**
       * Gets a value of width
       */
      get: function() {
        return this.right - this.left;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "height", {
      /**
       * Gets a value of height
       */
      get: function() {
        return this.bottom - this.top;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "topLeft", {
      /**
       * Gets a value of Top and Left
       */
      get: function() {
        return new PointF(this.left, this.top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "size", {
      /**
       * Gets a value of size
       */
      get: function() {
        return new SizeF(this.width, this.height);
      },
      enumerable: true,
      configurable: true
    });
    Rectangle2.prototype.toString = function() {
      return this.topLeft + "x" + this.size;
    };
    return Rectangle2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-brush.js
var PdfBrush = (
  /** @class */
  function() {
    function PdfBrush2() {
    }
    PdfBrush2.prototype.clone = function() {
      return this;
    };
    return PdfBrush2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-solid-brush.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfSolidBrush = (
  /** @class */
  function(_super) {
    __extends(PdfSolidBrush2, _super);
    function PdfSolidBrush2(color) {
      var _this = _super.call(this) || this;
      _this.pdfColor = color;
      return _this;
    }
    Object.defineProperty(PdfSolidBrush2.prototype, "color", {
      //Properties
      /**
       * Gets or sets the `color` of the brush.
       * @private
       */
      get: function() {
        return this.pdfColor;
      },
      set: function(value) {
        this.pdfColor = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfSolidBrush2.prototype.monitorChanges = function(brush, streamWriter, getResources, saveChanges, currentColorSpace) {
      if (streamWriter == null) {
        throw new Error("ArgumentNullException:streamWriter");
      }
      var diff = false;
      if (brush == null) {
        diff = true;
        streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);
        return diff;
      } else {
        var sBrush = brush;
        diff = true;
        streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);
        return diff;
      }
    };
    PdfSolidBrush2.prototype.resetChanges = function(streamWriter) {
      streamWriter.setColorAndSpace(new PdfColor(0, 0, 0), PdfColorSpace.Rgb, false);
    };
    return PdfSolidBrush2;
  }(PdfBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/enum.js
var PdfFontStyle;
(function(PdfFontStyle2) {
  PdfFontStyle2[PdfFontStyle2["Regular"] = 0] = "Regular";
  PdfFontStyle2[PdfFontStyle2["Bold"] = 1] = "Bold";
  PdfFontStyle2[PdfFontStyle2["Italic"] = 2] = "Italic";
  PdfFontStyle2[PdfFontStyle2["Underline"] = 4] = "Underline";
  PdfFontStyle2[PdfFontStyle2["Strikeout"] = 8] = "Strikeout";
})(PdfFontStyle || (PdfFontStyle = {}));
var PdfFontFamily;
(function(PdfFontFamily2) {
  PdfFontFamily2[PdfFontFamily2["Helvetica"] = 0] = "Helvetica";
  PdfFontFamily2[PdfFontFamily2["Courier"] = 1] = "Courier";
  PdfFontFamily2[PdfFontFamily2["TimesRoman"] = 2] = "TimesRoman";
  PdfFontFamily2[PdfFontFamily2["Symbol"] = 3] = "Symbol";
  PdfFontFamily2[PdfFontFamily2["ZapfDingbats"] = 4] = "ZapfDingbats";
})(PdfFontFamily || (PdfFontFamily = {}));
var PdfFontType;
(function(PdfFontType2) {
  PdfFontType2[PdfFontType2["Standard"] = 0] = "Standard";
  PdfFontType2[PdfFontType2["TrueType"] = 1] = "TrueType";
  PdfFontType2[PdfFontType2["TrueTypeEmbedded"] = 2] = "TrueTypeEmbedded";
})(PdfFontType || (PdfFontType = {}));
var PdfWordWrapType;
(function(PdfWordWrapType2) {
  PdfWordWrapType2[PdfWordWrapType2["None"] = 0] = "None";
  PdfWordWrapType2[PdfWordWrapType2["Word"] = 1] = "Word";
  PdfWordWrapType2[PdfWordWrapType2["WordOnly"] = 2] = "WordOnly";
  PdfWordWrapType2[PdfWordWrapType2["Character"] = 3] = "Character";
})(PdfWordWrapType || (PdfWordWrapType = {}));
var PdfSubSuperScript;
(function(PdfSubSuperScript2) {
  PdfSubSuperScript2[PdfSubSuperScript2["None"] = 0] = "None";
  PdfSubSuperScript2[PdfSubSuperScript2["SuperScript"] = 1] = "SuperScript";
  PdfSubSuperScript2[PdfSubSuperScript2["SubScript"] = 2] = "SubScript";
})(PdfSubSuperScript || (PdfSubSuperScript = {}));
var FontEncoding;
(function(FontEncoding2) {
  FontEncoding2[FontEncoding2["Unknown"] = 0] = "Unknown";
  FontEncoding2[FontEncoding2["StandardEncoding"] = 1] = "StandardEncoding";
  FontEncoding2[FontEncoding2["MacRomanEncoding"] = 2] = "MacRomanEncoding";
  FontEncoding2[FontEncoding2["MacExpertEncoding"] = 3] = "MacExpertEncoding";
  FontEncoding2[FontEncoding2["WinAnsiEncoding"] = 4] = "WinAnsiEncoding";
  FontEncoding2[FontEncoding2["PdfDocEncoding"] = 5] = "PdfDocEncoding";
  FontEncoding2[FontEncoding2["IdentityH"] = 6] = "IdentityH";
})(FontEncoding || (FontEncoding = {}));
var TtfCmapFormat;
(function(TtfCmapFormat2) {
  TtfCmapFormat2[TtfCmapFormat2["Apple"] = 0] = "Apple";
  TtfCmapFormat2[TtfCmapFormat2["Microsoft"] = 4] = "Microsoft";
  TtfCmapFormat2[TtfCmapFormat2["Trimmed"] = 6] = "Trimmed";
})(TtfCmapFormat || (TtfCmapFormat = {}));
var TtfCmapEncoding;
(function(TtfCmapEncoding2) {
  TtfCmapEncoding2[TtfCmapEncoding2["Unknown"] = 0] = "Unknown";
  TtfCmapEncoding2[TtfCmapEncoding2["Symbol"] = 1] = "Symbol";
  TtfCmapEncoding2[TtfCmapEncoding2["Unicode"] = 2] = "Unicode";
  TtfCmapEncoding2[TtfCmapEncoding2["Macintosh"] = 3] = "Macintosh";
})(TtfCmapEncoding || (TtfCmapEncoding = {}));
var TtfPlatformID;
(function(TtfPlatformID2) {
  TtfPlatformID2[TtfPlatformID2["AppleUnicode"] = 0] = "AppleUnicode";
  TtfPlatformID2[TtfPlatformID2["Macintosh"] = 1] = "Macintosh";
  TtfPlatformID2[TtfPlatformID2["Iso"] = 2] = "Iso";
  TtfPlatformID2[TtfPlatformID2["Microsoft"] = 3] = "Microsoft";
})(TtfPlatformID || (TtfPlatformID = {}));
var TtfMicrosoftEncodingID;
(function(TtfMicrosoftEncodingID2) {
  TtfMicrosoftEncodingID2[TtfMicrosoftEncodingID2["Undefined"] = 0] = "Undefined";
  TtfMicrosoftEncodingID2[TtfMicrosoftEncodingID2["Unicode"] = 1] = "Unicode";
})(TtfMicrosoftEncodingID || (TtfMicrosoftEncodingID = {}));
var TtfMacintoshEncodingID;
(function(TtfMacintoshEncodingID2) {
  TtfMacintoshEncodingID2[TtfMacintoshEncodingID2["Roman"] = 0] = "Roman";
  TtfMacintoshEncodingID2[TtfMacintoshEncodingID2["Japanese"] = 1] = "Japanese";
  TtfMacintoshEncodingID2[TtfMacintoshEncodingID2["Chinese"] = 2] = "Chinese";
})(TtfMacintoshEncodingID || (TtfMacintoshEncodingID = {}));
var FontDescriptorFlags;
(function(FontDescriptorFlags2) {
  FontDescriptorFlags2[FontDescriptorFlags2["FixedPitch"] = 1] = "FixedPitch";
  FontDescriptorFlags2[FontDescriptorFlags2["Serif"] = 2] = "Serif";
  FontDescriptorFlags2[FontDescriptorFlags2["Symbolic"] = 4] = "Symbolic";
  FontDescriptorFlags2[FontDescriptorFlags2["Script"] = 8] = "Script";
  FontDescriptorFlags2[FontDescriptorFlags2["Nonsymbolic"] = 32] = "Nonsymbolic";
  FontDescriptorFlags2[FontDescriptorFlags2["Italic"] = 64] = "Italic";
  FontDescriptorFlags2[FontDescriptorFlags2["ForceBold"] = 262144] = "ForceBold";
})(FontDescriptorFlags || (FontDescriptorFlags = {}));
var TtfCompositeGlyphFlags;
(function(TtfCompositeGlyphFlags2) {
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["Arg1And2AreWords"] = 1] = "Arg1And2AreWords";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["ArgsAreXyValues"] = 2] = "ArgsAreXyValues";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["RoundXyToGrid"] = 4] = "RoundXyToGrid";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveScale"] = 8] = "WeHaveScale";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["Reserved"] = 16] = "Reserved";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["MoreComponents"] = 32] = "MoreComponents";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveAnXyScale"] = 64] = "WeHaveAnXyScale";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveTwoByTwo"] = 128] = "WeHaveTwoByTwo";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveInstructions"] = 256] = "WeHaveInstructions";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["UseMyMetrics"] = 512] = "UseMyMetrics";
})(TtfCompositeGlyphFlags || (TtfCompositeGlyphFlags = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-string-format.js
var PdfStringFormat = (
  /** @class */
  function() {
    function PdfStringFormat2(arg1, arg2) {
      this.scalingFactor = 100;
      this.wordWrapType = PdfWordWrapType.Word;
      this.internalLineLimit = true;
      this.wordWrapType = PdfWordWrapType.Word;
      if (typeof arg1 !== "undefined" && typeof arg1 !== "string") {
        this.textAlignment = arg1;
      }
      if (typeof arg2 !== "undefined") {
        this.verticalAlignment = arg2;
      }
    }
    Object.defineProperty(PdfStringFormat2.prototype, "alignment", {
      //Properties
      /**
       * Gets or sets the `horizontal` text alignment
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set the text alignment
       * stringFormat.alignment = PdfTextAlignment.Center;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.textAlignment;
      },
      set: function(value) {
        this.textAlignment = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "textDirection", {
      get: function() {
        return this.direction;
      },
      set: function(value) {
        this.direction = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "lineAlignment", {
      /**
       * Gets or sets the `vertical` text alignment.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set the vertical alignment
       * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.verticalAlignment === "undefined" || this.verticalAlignment == null) {
          return PdfVerticalAlignment.Top;
        } else {
          return this.verticalAlignment;
        }
      },
      set: function(value) {
        this.verticalAlignment = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "rightToLeft", {
      /**
       * Gets or sets the value that indicates text `direction` mode.
       * @private
       */
      get: function() {
        if (typeof this.isRightToLeft === "undefined" || this.isRightToLeft == null) {
          return false;
        } else {
          return this.isRightToLeft;
        }
      },
      set: function(value) {
        this.isRightToLeft = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "characterSpacing", {
      /**
       * Gets or sets value that indicates a `size` among the characters in the text.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set character spacing
       * stringFormat.characterSpacing = 10;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.internalCharacterSpacing === "undefined" || this.internalCharacterSpacing == null) {
          return 0;
        } else {
          return this.internalCharacterSpacing;
        }
      },
      set: function(value) {
        this.internalCharacterSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "wordSpacing", {
      /**
       * Gets or sets value that indicates a `size` among the words in the text.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set word spacing
       * stringFormat.wordSpacing = 10;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.internalWordSpacing === "undefined" || this.internalWordSpacing == null) {
          return 0;
        } else {
          return this.internalWordSpacing;
        }
      },
      set: function(value) {
        this.internalWordSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "lineSpacing", {
      /**
       * Gets or sets value that indicates the `vertical distance` between the baselines of adjacent lines of text.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * // set string
       * let text : string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
       * incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitati';
       * // set rectangle bounds
       * let rectangle : RectangleF = new RectangleF({x : 0, y : 0}, {width : 300, height : 100})
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set line spacing
       * stringFormat.lineSpacing = 10;
       * //
       * // draw the text
       * page1.graphics.drawString(text, font, blackBrush, rectangle, stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.leading === "undefined" || this.leading == null) {
          return 0;
        } else {
          return this.leading;
        }
      },
      set: function(value) {
        this.leading = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "clipPath", {
      /**
       * Gets or sets a value indicating whether the text is `clipped` or not.
       * @private
       */
      get: function() {
        if (typeof this.clip === "undefined" || this.clip == null) {
          return false;
        } else {
          return this.clip;
        }
      },
      set: function(value) {
        this.clip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "subSuperScript", {
      /**
       * Gets or sets value indicating whether the text is in `subscript or superscript` mode.
       * @private
       */
      get: function() {
        if (typeof this.pdfSubSuperScript === "undefined" || this.pdfSubSuperScript == null) {
          return PdfSubSuperScript.None;
        } else {
          return this.pdfSubSuperScript;
        }
      },
      set: function(value) {
        this.pdfSubSuperScript = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "paragraphIndent", {
      /**
       * Gets or sets the `indent` of the first line in the paragraph.
       * @private
       */
      get: function() {
        if (typeof this.internalParagraphIndent === "undefined" || this.internalParagraphIndent == null) {
          return 0;
        } else {
          return this.internalParagraphIndent;
        }
      },
      set: function(value) {
        this.internalParagraphIndent = value;
        this.firstLineIndent = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "lineLimit", {
      /**
       * Gets or sets a value indicating whether [`line limit`].
       * @private
       */
      get: function() {
        return this.internalLineLimit;
      },
      set: function(value) {
        this.internalLineLimit = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "measureTrailingSpaces", {
      /**
       * Gets or sets a value indicating whether [`measure trailing spaces`].
       * @private
       */
      get: function() {
        if (typeof this.trailingSpaces === "undefined" || this.trailingSpaces == null) {
          return false;
        } else {
          return this.trailingSpaces;
        }
      },
      set: function(value) {
        this.trailingSpaces = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "noClip", {
      /**
       * Gets or sets a value indicating whether [`no clip`].
       * @private
       */
      get: function() {
        if (typeof this.isNoClip === "undefined" || this.isNoClip == null) {
          return false;
        } else {
          return this.isNoClip;
        }
      },
      set: function(value) {
        this.isNoClip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "wordWrap", {
      /**
       * Gets or sets value indicating type of the text `wrapping`.
       * @private
       */
      get: function() {
        return this.wordWrapType;
      },
      set: function(value) {
        this.wordWrapType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "horizontalScalingFactor", {
      /**
       * Gets or sets the `scaling factor`.
       * @private
       */
      get: function() {
        return this.scalingFactor;
      },
      set: function(value) {
        if (value <= 0) {
          throw new Error("ArgumentOutOfRangeException:The scaling factor cant be less of equal to zero, ScalingFactor");
        }
        this.scalingFactor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "firstLineIndent", {
      /**
       * Gets or sets the `indent` of the first line in the text.
       * @private
       */
      get: function() {
        if (typeof this.initialLineIndent === "undefined" || this.initialLineIndent == null) {
          return 0;
        } else {
          return this.initialLineIndent;
        }
      },
      set: function(value) {
        this.initialLineIndent = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfStringFormat2.prototype.clone = function() {
      var format = this;
      return format;
    };
    return PdfStringFormat2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/enum.js
var PdfPageOrientation;
(function(PdfPageOrientation2) {
  PdfPageOrientation2[PdfPageOrientation2["Portrait"] = 0] = "Portrait";
  PdfPageOrientation2[PdfPageOrientation2["Landscape"] = 1] = "Landscape";
})(PdfPageOrientation || (PdfPageOrientation = {}));
var PdfPageRotateAngle;
(function(PdfPageRotateAngle2) {
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle0"] = 0] = "RotateAngle0";
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle90"] = 1] = "RotateAngle90";
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle180"] = 2] = "RotateAngle180";
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle270"] = 3] = "RotateAngle270";
})(PdfPageRotateAngle || (PdfPageRotateAngle = {}));
var PdfNumberStyle;
(function(PdfNumberStyle2) {
  PdfNumberStyle2[PdfNumberStyle2["None"] = 0] = "None";
  PdfNumberStyle2[PdfNumberStyle2["Numeric"] = 1] = "Numeric";
  PdfNumberStyle2[PdfNumberStyle2["LowerLatin"] = 2] = "LowerLatin";
  PdfNumberStyle2[PdfNumberStyle2["LowerRoman"] = 3] = "LowerRoman";
  PdfNumberStyle2[PdfNumberStyle2["UpperLatin"] = 4] = "UpperLatin";
  PdfNumberStyle2[PdfNumberStyle2["UpperRoman"] = 5] = "UpperRoman";
})(PdfNumberStyle || (PdfNumberStyle = {}));
var PdfDockStyle;
(function(PdfDockStyle2) {
  PdfDockStyle2[PdfDockStyle2["None"] = 0] = "None";
  PdfDockStyle2[PdfDockStyle2["Bottom"] = 1] = "Bottom";
  PdfDockStyle2[PdfDockStyle2["Top"] = 2] = "Top";
  PdfDockStyle2[PdfDockStyle2["Left"] = 3] = "Left";
  PdfDockStyle2[PdfDockStyle2["Right"] = 4] = "Right";
  PdfDockStyle2[PdfDockStyle2["Fill"] = 5] = "Fill";
})(PdfDockStyle || (PdfDockStyle = {}));
var PdfAlignmentStyle;
(function(PdfAlignmentStyle2) {
  PdfAlignmentStyle2[PdfAlignmentStyle2["None"] = 0] = "None";
  PdfAlignmentStyle2[PdfAlignmentStyle2["TopLeft"] = 1] = "TopLeft";
  PdfAlignmentStyle2[PdfAlignmentStyle2["TopCenter"] = 2] = "TopCenter";
  PdfAlignmentStyle2[PdfAlignmentStyle2["TopRight"] = 3] = "TopRight";
  PdfAlignmentStyle2[PdfAlignmentStyle2["MiddleLeft"] = 4] = "MiddleLeft";
  PdfAlignmentStyle2[PdfAlignmentStyle2["MiddleCenter"] = 5] = "MiddleCenter";
  PdfAlignmentStyle2[PdfAlignmentStyle2["MiddleRight"] = 6] = "MiddleRight";
  PdfAlignmentStyle2[PdfAlignmentStyle2["BottomLeft"] = 7] = "BottomLeft";
  PdfAlignmentStyle2[PdfAlignmentStyle2["BottomCenter"] = 8] = "BottomCenter";
  PdfAlignmentStyle2[PdfAlignmentStyle2["BottomRight"] = 9] = "BottomRight";
})(PdfAlignmentStyle || (PdfAlignmentStyle = {}));
var TemplateType;
(function(TemplateType2) {
  TemplateType2[TemplateType2["None"] = 0] = "None";
  TemplateType2[TemplateType2["Top"] = 1] = "Top";
  TemplateType2[TemplateType2["Bottom"] = 2] = "Bottom";
  TemplateType2[TemplateType2["Left"] = 3] = "Left";
  TemplateType2[TemplateType2["Right"] = 4] = "Right";
})(TemplateType || (TemplateType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-size.js
var PdfPageSize = (
  /** @class */
  function() {
    function PdfPageSize2() {
    }
    PdfPageSize2.letter = new SizeF(612, 792);
    PdfPageSize2.note = new SizeF(540, 720);
    PdfPageSize2.legal = new SizeF(612, 1008);
    PdfPageSize2.a0 = new SizeF(2380, 3368);
    PdfPageSize2.a1 = new SizeF(1684, 2380);
    PdfPageSize2.a2 = new SizeF(1190, 1684);
    PdfPageSize2.a3 = new SizeF(842, 1190);
    PdfPageSize2.a4 = new SizeF(595, 842);
    PdfPageSize2.a5 = new SizeF(421, 595);
    PdfPageSize2.a6 = new SizeF(297, 421);
    PdfPageSize2.a7 = new SizeF(210, 297);
    PdfPageSize2.a8 = new SizeF(148, 210);
    PdfPageSize2.a9 = new SizeF(105, 148);
    PdfPageSize2.a10 = new SizeF(74, 105);
    PdfPageSize2.b0 = new SizeF(2836, 4008);
    PdfPageSize2.b1 = new SizeF(2004, 2836);
    PdfPageSize2.b2 = new SizeF(1418, 2004);
    PdfPageSize2.b3 = new SizeF(1002, 1418);
    PdfPageSize2.b4 = new SizeF(709, 1002);
    PdfPageSize2.b5 = new SizeF(501, 709);
    PdfPageSize2.archE = new SizeF(2592, 3456);
    PdfPageSize2.archD = new SizeF(1728, 2592);
    PdfPageSize2.archC = new SizeF(1296, 1728);
    PdfPageSize2.archB = new SizeF(864, 1296);
    PdfPageSize2.archA = new SizeF(648, 864);
    PdfPageSize2.flsa = new SizeF(612, 936);
    PdfPageSize2.halfLetter = new SizeF(396, 612);
    PdfPageSize2.letter11x17 = new SizeF(792, 1224);
    PdfPageSize2.ledger = new SizeF(1224, 792);
    return PdfPageSize2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-margins.js
var PdfMargins = (
  /** @class */
  function() {
    function PdfMargins2() {
      this.pdfMargin = 40;
      this.setMargins(this.pdfMargin);
    }
    Object.defineProperty(PdfMargins2.prototype, "left", {
      //Properties
      /**
       * Gets or sets the `left margin` size.
       * @private
       */
      get: function() {
        return this.leftMargin;
      },
      set: function(value) {
        this.leftMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "top", {
      /**
       * Gets or sets the `top margin` size.
       * @private
       */
      get: function() {
        return this.topMargin;
      },
      set: function(value) {
        this.topMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "right", {
      /**
       * Gets or sets the `right margin` size.
       * @private
       */
      get: function() {
        return this.rightMargin;
      },
      set: function(value) {
        this.rightMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "bottom", {
      /**
       * Gets or sets the `bottom margin` size.
       * @private
       */
      get: function() {
        return this.bottomMargin;
      },
      set: function(value) {
        this.bottomMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "all", {
      /**
       * Sets the `margins`.
       * @private
       */
      set: function(value) {
        this.setMargins(value);
      },
      enumerable: true,
      configurable: true
    });
    PdfMargins2.prototype.setMargins = function(margin1, margin2, margin3, margin4) {
      if (typeof margin2 === "undefined") {
        this.leftMargin = this.topMargin = this.rightMargin = this.bottomMargin = margin1;
      } else {
        if (typeof margin3 === "undefined") {
          this.leftMargin = this.rightMargin = margin1;
          this.bottomMargin = this.topMargin = margin2;
        } else {
          this.leftMargin = margin1;
          this.topMargin = margin2;
          this.rightMargin = margin3;
          this.bottomMargin = margin4;
        }
      }
    };
    PdfMargins2.prototype.clone = function() {
      return this;
    };
    return PdfMargins2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-settings.js
var PdfPageSettings = (
  /** @class */
  function() {
    function PdfPageSettings2(margins) {
      this.pageMargins = new PdfMargins();
      this.pageSize = PdfPageSize.a4;
      this.rotateAngle = PdfPageRotateAngle.RotateAngle0;
      this.pageOrientation = PdfPageOrientation.Portrait;
      this.pageOrigin = new PointF(0, 0);
      this.isRotation = false;
      if (typeof margins === "number") {
        this.pageMargins.setMargins(margins);
      }
    }
    Object.defineProperty(PdfPageSettings2.prototype, "size", {
      //Properties
      /**
       * Gets or sets the `size` of the page.
       * @private
       */
      get: function() {
        return this.pageSize;
      },
      set: function(value) {
        this.setSize(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "orientation", {
      /**
       * Gets or sets the page `orientation`.
       * @private
       */
      get: function() {
        return this.pageOrientation;
      },
      set: function(orientation) {
        if (this.pageOrientation !== orientation) {
          this.pageOrientation = orientation;
          this.updateSize(orientation);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "margins", {
      /**
       * Gets or sets the `margins` of the page.
       * @private
       */
      get: function() {
        return this.pageMargins;
      },
      set: function(value) {
        this.pageMargins = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "width", {
      /**
       * Gets or sets the `width` of the page.
       * @private
       */
      get: function() {
        return this.pageSize.width;
      },
      set: function(value) {
        this.pageSize.width = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "height", {
      /**
       * Gets or sets the `height` of the page.
       * @private
       */
      get: function() {
        return this.pageSize.height;
      },
      set: function(value) {
        this.pageSize.height = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "origin", {
      /**
       * Gets or sets the `origin` of the page.
       * @private
       */
      get: function() {
        return this.pageOrigin;
      },
      set: function(value) {
        this.pageOrigin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "rotate", {
      /**
       * Gets or sets the number of degrees by which the page should be `rotated` clockwise when displayed or printed.
       * @private
       */
      get: function() {
        return this.rotateAngle;
      },
      set: function(value) {
        this.rotateAngle = value;
        this.isRotation = true;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageSettings2.prototype.updateSize = function(orientation) {
      var min = Math.min(this.pageSize.width, this.pageSize.height);
      var max = Math.max(this.pageSize.width, this.pageSize.height);
      switch (orientation) {
        case PdfPageOrientation.Portrait:
          this.pageSize = new SizeF(min, max);
          break;
        case PdfPageOrientation.Landscape:
          this.pageSize = new SizeF(max, min);
          break;
      }
    };
    PdfPageSettings2.prototype.clone = function() {
      var settings = this;
      settings.pageMargins = this.pageMargins.clone();
      return settings;
    };
    PdfPageSettings2.prototype.getActualSize = function() {
      var width = this.width - (this.margins.left + this.margins.right);
      var height = this.height - (this.margins.top + this.margins.bottom);
      var size = new SizeF(width, height);
      return size;
    };
    PdfPageSettings2.prototype.setSize = function(size) {
      var min = Math.min(size.width, size.height);
      var max = Math.max(size.width, size.height);
      if (this.orientation === PdfPageOrientation.Portrait) {
        this.pageSize = new SizeF(min, max);
      } else {
        this.pageSize = new SizeF(max, min);
      }
    };
    return PdfPageSettings2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-pen.js
var PdfPen = (
  /** @class */
  function() {
    function PdfPen2(arg1, arg2) {
      this.pdfColor = new PdfColor(0, 0, 0);
      this.dashOffsetValue = 0;
      this.penDashPattern = [0];
      this.pdfDashStyle = PdfDashStyle.Solid;
      this.pdfLineCap = 0;
      this.pdfLineJoin = 0;
      this.penWidth = 1;
      this.internalMiterLimit = 0;
      this.colorSpace = PdfColorSpace.Rgb;
      if (arg1 instanceof PdfBrush) {
        this.setBrush(arg1);
      } else if (arg1 instanceof PdfColor) {
        this.color = arg1;
      }
      if (typeof arg2 === "number") {
        this.width = arg2;
      }
    }
    Object.defineProperty(PdfPen2.prototype, "color", {
      //Properties
      /**
       * Gets or sets the `color of the pen`.
       * @private
       */
      get: function() {
        return this.pdfColor;
      },
      set: function(value) {
        this.pdfColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "dashOffset", {
      /**
       * Gets or sets the `dash offset of the pen`.
       * @private
       */
      get: function() {
        if (typeof this.dashOffsetValue === "undefined" || this.dashOffsetValue == null) {
          return 0;
        } else {
          return this.dashOffsetValue;
        }
      },
      set: function(value) {
        this.dashOffsetValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "dashPattern", {
      /**
       * Gets or sets the `dash pattern of the pen`.
       * @private
       */
      get: function() {
        return this.penDashPattern;
      },
      set: function(value) {
        this.penDashPattern = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "dashStyle", {
      /**
       * Gets or sets the `dash style of the pen`.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // create a new page
       * let page1 : PdfPage = document.pages.add();
       * // set pen
       * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
       * //
       * // set pen style
       * pen.dashStyle = PdfDashStyle.DashDot;
       * // get pen style
       * let style : PdfDashStyle = pen.dashStyle;
       * //
       * // draw rectangle
       * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.pdfDashStyle;
      },
      set: function(value) {
        if (this.pdfDashStyle !== value) {
          this.pdfDashStyle = value;
          switch (this.pdfDashStyle) {
            case PdfDashStyle.Custom:
              break;
            case PdfDashStyle.Dash:
              this.penDashPattern = [3, 1];
              break;
            case PdfDashStyle.Dot:
              this.penDashPattern = [1, 1];
              break;
            case PdfDashStyle.DashDot:
              this.penDashPattern = [3, 1, 1, 1];
              break;
            case PdfDashStyle.DashDotDot:
              this.penDashPattern = [3, 1, 1, 1, 1, 1];
              break;
            case PdfDashStyle.Solid:
              break;
            default:
              this.pdfDashStyle = PdfDashStyle.Solid;
              this.penDashPattern = [0];
              break;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "lineCap", {
      /**
       * Gets or sets the `line cap of the pen`.
       * @private
       */
      get: function() {
        return this.pdfLineCap;
      },
      set: function(value) {
        this.pdfLineCap = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "lineJoin", {
      /**
       * Gets or sets the `line join style of the pen`.
       * @private
       */
      get: function() {
        return this.pdfLineJoin;
      },
      set: function(value) {
        this.pdfLineJoin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "miterLimit", {
      /**
       * Gets or sets the `miter limit`.
       * @private
       */
      get: function() {
        return this.internalMiterLimit;
      },
      set: function(value) {
        this.internalMiterLimit = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "width", {
      /**
       * Gets or sets the `width of the pen`.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // create a new page
       * let page1 : PdfPage = document.pages.add();
       * // set pen
       * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
       * //
       * // set pen width
       * pen.width = 2;
       * //
       * // draw rectangle
       * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.penWidth;
      },
      set: function(value) {
        this.penWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfPen2.prototype.clone = function() {
      var pen = this;
      return pen;
    };
    PdfPen2.prototype.setBrush = function(brush) {
      var sBrush = brush;
      if (sBrush != null && sBrush instanceof PdfSolidBrush) {
        this.color = sBrush.color;
        this.pdfBrush = sBrush;
      }
      this.color = sBrush.color;
      this.pdfBrush = sBrush;
    };
    PdfPen2.prototype.monitorChanges = function(currentPen, streamWriter, getResources, saveState, currentColorSpace, matrix) {
      var diff = false;
      saveState = true;
      if (currentPen == null) {
        diff = true;
      }
      diff = this.dashControl(currentPen, saveState, streamWriter);
      streamWriter.setLineWidth(this.width);
      streamWriter.setLineJoin(this.lineJoin);
      streamWriter.setLineCap(this.lineCap);
      var miterLimit = this.miterLimit;
      if (miterLimit > 0) {
        streamWriter.setMiterLimit(miterLimit);
        diff = true;
      }
      var brush = this.pdfBrush;
      streamWriter.setColorAndSpace(this.color, currentColorSpace, true);
      diff = true;
      return diff;
    };
    PdfPen2.prototype.dashControl = function(pen, saveState, streamWriter) {
      saveState = true;
      var lineWidth = this.width;
      var pattern = this.getPattern();
      streamWriter.setLineDashPattern(pattern, this.dashOffset * lineWidth);
      return saveState;
    };
    PdfPen2.prototype.getPattern = function() {
      var pattern = this.dashPattern;
      for (var i = 0; i < pattern.length; ++i) {
        pattern[i] *= this.width;
      }
      return pattern;
    };
    return PdfPen2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/byte-array.js
var ByteArray = (
  /** @class */
  function() {
    function ByteArray2(length) {
      this.mPosition = 0;
      this.buffer = new Uint8Array(length);
      this.dataView = new DataView(this.buffer.buffer);
    }
    Object.defineProperty(ByteArray2.prototype, "position", {
      /**
       * Gets and Sets a current `position` of byte array.
       * @hidden
       * @private
       */
      get: function() {
        return this.mPosition;
      },
      set: function(value) {
        this.mPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    ByteArray2.prototype.read = function(buffer, offset, count) {
      for (var index = offset; index < count; index++) {
        var position = this.position;
        buffer.buffer[index] = this.readByte(position);
        this.position++;
      }
    };
    ByteArray2.prototype.getBuffer = function(index) {
      return this.buffer[index];
    };
    ByteArray2.prototype.writeFromBase64String = function(base64) {
      var arr = this.encodedString(base64);
      this.buffer = arr;
    };
    ByteArray2.prototype.encodedString = function(input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var chr1;
      var chr2;
      var chr3;
      var enc1;
      var enc2;
      var enc3;
      var enc4;
      var i = 0;
      var resultIndex = 0;
      var dataUrlPrefix = "data:";
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
        totalLength--;
      }
      var output = new Uint8Array(totalLength | 0);
      while (i < input.length) {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        output[resultIndex++] = chr2;
        output[resultIndex++] = chr3;
      }
      return output;
    };
    ByteArray2.prototype.readByte = function(offset) {
      return this.buffer[offset];
    };
    Object.defineProperty(ByteArray2.prototype, "internalBuffer", {
      /**
       * @hidden
       */
      get: function() {
        return this.buffer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ByteArray2.prototype, "count", {
      /**
       * @hidden
       */
      get: function() {
        return this.buffer.byteLength;
      },
      enumerable: true,
      configurable: true
    });
    ByteArray2.prototype.readNextTwoBytes = function(stream) {
      var data = stream.readByte(this.position);
      this.position++;
      data <<= 8;
      data |= stream.readByte(this.position);
      this.position++;
      return data;
    };
    return ByteArray2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-name.js
var PdfName = (
  /** @class */
  function() {
    function PdfName2(value) {
      this.stringStartMark = "/";
      this.internalValue = "";
      this.isSaving6 = false;
      this.position6 = -1;
      this.internalValue = this.normalizeValue(value);
    }
    Object.defineProperty(PdfName2.prototype, "status", {
      //property
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status6;
      },
      set: function(value) {
        this.status6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving6;
      },
      set: function(value) {
        this.isSaving6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index6;
      },
      set: function(value) {
        this.index6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position6;
      },
      set: function(value) {
        this.position6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "value", {
      /**
       * Gets or sets the `value` of the object.
       * @private
       */
      get: function() {
        return this.internalValue;
      },
      set: function(value) {
        var val = value;
        if (value !== null && value.length > 0) {
          val = value;
          this.internalValue = this.normalizeValue(val);
        } else {
          this.internalValue = val;
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfName2.prototype.save = function(writer) {
      writer.write(this.toString());
    };
    PdfName2.prototype.toString = function() {
      return this.stringStartMark + this.escapeString(this.value);
    };
    PdfName2.prototype.clone = function(crossTable) {
      var newName = new PdfName2();
      newName.value = this.internalValue;
      return newName;
    };
    PdfName2.prototype.escapeString = function(stringValue) {
      var result = "";
      var len = 0;
      for (var i = 0, len_1 = stringValue.length; i < len_1; i++) {
        var ch = stringValue[i];
        var index = PdfName2.delimiters.indexOf(ch);
        result = result + ch;
      }
      return result;
    };
    PdfName2.prototype.normalizeValue = function(value, c) {
      var strFormat = "#{0:X}";
      return value;
    };
    PdfName2.delimiters = "()<>[]{}/%}";
    PdfName2.replacements = [" ", "	", "\n", "\r"];
    return PdfName2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-dictionary-properties.js
var DictionaryProperties = (
  /** @class */
  function() {
    function DictionaryProperties2() {
      this.pages = "Pages";
      this.kids = "Kids";
      this.count = "Count";
      this.resources = "Resources";
      this.type = "Type";
      this.size = "Size";
      this.mediaBox = "MediaBox";
      this.parent = "Parent";
      this.root = "Root";
      this.decodeParms = "DecodeParms";
      this.filter = "Filter";
      this.font = "Font";
      this.type1 = "Type1";
      this.baseFont = "BaseFont";
      this.encoding = "Encoding";
      this.subtype = "Subtype";
      this.contents = "Contents";
      this.procset = "ProcSet";
      this.colorSpace = "ColorSpace";
      this.extGState = "ExtGState";
      this.pattern = "Pattern";
      this.xObject = "XObject";
      this.length = "Length";
      this.width = "Width";
      this.height = "Height";
      this.bitsPerComponent = "BitsPerComponent";
      this.image = "Image";
      this.dctdecode = "DCTDecode";
      this.columns = "Columns";
      this.blackIs1 = "BlackIs1";
      this.k = "K";
      this.s = "S";
      this.predictor = "Predictor";
      this.deviceRgb = "DeviceRGB";
      this.next = "Next";
      this.action = "Action";
      this.link = "Link";
      this.a = "A";
      this.annot = "Annot";
      this.p = "P";
      this.c = "C";
      this.rect = "Rect";
      this.uri = "URI";
      this.annots = "Annots";
      this.ca = "ca";
      this.CA = "CA";
      this.xyz = "XYZ";
      this.fit = "Fit";
      this.dest = "Dest";
      this.BM = "BM";
      this.flatedecode = "FlateDecode";
      this.rotate = "Rotate";
      this.bBox = "BBox";
      this.form = "Form";
      this.w = "W";
      this.cIDFontType2 = "CIDFontType2";
      this.cIDToGIDMap = "CIDToGIDMap";
      this.identity = "Identity";
      this.dw = "DW";
      this.fontDescriptor = "FontDescriptor";
      this.cIDSystemInfo = "CIDSystemInfo";
      this.fontName = "FontName";
      this.flags = "Flags";
      this.fontBBox = "FontBBox";
      this.missingWidth = "MissingWidth";
      this.stemV = "StemV";
      this.italicAngle = "ItalicAngle";
      this.capHeight = "CapHeight";
      this.ascent = "Ascent";
      this.descent = "Descent";
      this.leading = "Leading";
      this.avgWidth = "AvgWidth";
      this.fontFile2 = "FontFile2";
      this.maxWidth = "MaxWidth";
      this.xHeight = "XHeight";
      this.stemH = "StemH";
      this.registry = "Registry";
      this.ordering = "Ordering";
      this.supplement = "Supplement";
      this.type0 = "Type0";
      this.identityH = "Identity-H";
      this.toUnicode = "ToUnicode";
      this.descendantFonts = "DescendantFonts";
      this.background = "Background";
      this.shading = "Shading";
      this.matrix = "Matrix";
      this.antiAlias = "AntiAlias";
      this.function = "Function";
      this.extend = "Extend";
      this.shadingType = "ShadingType";
      this.coords = "Coords";
      this.domain = "Domain";
      this.range = "Range";
      this.functionType = "FunctionType";
      this.bitsPerSample = "BitsPerSample";
      this.patternType = "PatternType";
      this.paintType = "PaintType";
      this.tilingType = "TilingType";
      this.xStep = "XStep";
      this.yStep = "YStep";
    }
    return DictionaryProperties2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-dictionary.js
var PdfDictionary = (
  /** @class */
  function() {
    function PdfDictionary2(dictionary) {
      this.position7 = -1;
      this.primitiveItems = new Dictionary();
      this.prefix = "<<";
      this.suffix = ">>";
      this.resources = [];
      this.object = null;
      this.archive = true;
      this.isFont = false;
      if (typeof dictionary === "undefined") {
        this.primitiveItems = new Dictionary();
        this.encrypt = true;
        this.dictionaryProperties = new DictionaryProperties();
      } else {
        this.primitiveItems = new Dictionary();
        var keys = dictionary.items.keys();
        var values = dictionary.items.values();
        for (var index = 0; index < dictionary.items.size(); index++) {
          this.primitiveItems.setValue(keys[index], values[index]);
        }
        this.status = dictionary.status;
        this.freezeChanges(this);
        this.encrypt = true;
        this.dictionaryProperties = new DictionaryProperties();
      }
    }
    Object.defineProperty(PdfDictionary2.prototype, "items", {
      //Properties
      /**
       * Gets or sets the `IPdfSavable` with the specified key.
       * @private
       */
      get: function() {
        return this.primitiveItems;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status7;
      },
      set: function(value) {
        this.status7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving7;
      },
      set: function(value) {
        this.isSaving7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index7;
      },
      set: function(value) {
        this.index7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return this.object;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position7;
      },
      set: function(value) {
        this.position7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "Count", {
      /**
       * Gets the `count`.
       * @private
       */
      get: function() {
        return this.primitiveItems.size();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "Dictionary", {
      /**
       * Collection of `items` in the object.
       * @private
       */
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    PdfDictionary2.prototype.getArchive = function() {
      return this.archive;
    };
    PdfDictionary2.prototype.setArchive = function(value) {
      this.archive = value;
    };
    PdfDictionary2.prototype.setEncrypt = function(value) {
      this.encrypt = value;
      this.modify();
    };
    PdfDictionary2.prototype.getEncrypt = function() {
      return this.encrypt;
    };
    PdfDictionary2.prototype.freezeChanges = function(freezer) {
      this.bChanged = false;
    };
    PdfDictionary2.prototype.clone = function(crossTable) {
      var newDict = new PdfDictionary2();
      return newDict;
    };
    PdfDictionary2.prototype.modify = function() {
      this.bChanged = true;
    };
    PdfDictionary2.prototype.remove = function(key) {
      if (typeof key !== "string") {
        this.primitiveItems.remove(key.value);
        this.modify();
      } else {
        this.remove(new PdfName(key));
      }
    };
    PdfDictionary2.prototype.containsKey = function(key) {
      var returnValue = false;
      returnValue = this.primitiveItems.containsKey(key.toString());
      return returnValue;
    };
    PdfDictionary2.prototype.onBeginSave = function() {
      this.beginSave.sender.beginSave();
    };
    PdfDictionary2.prototype.onFontDictionaryBeginSave = function() {
      this.fontDictionaryBeginSave.sender.fontDictionaryBeginSave();
    };
    PdfDictionary2.prototype.onDescendantFontBeginSave = function() {
      this.descendantFontBeginSave.sender.descendantFontBeginSave();
    };
    PdfDictionary2.prototype.onTemplateBeginSave = function() {
      this.pageBeginDrawTemplate.sender.pageBeginSave();
    };
    PdfDictionary2.prototype.onBeginAnnotationSave = function() {
      this.annotationBeginSave.sender.beginSave();
    };
    PdfDictionary2.prototype.onSectionBeginSave = function(writer) {
      var saveEvent = this.sectionBeginSave;
      saveEvent.sender.beginSave(saveEvent.state, writer);
    };
    PdfDictionary2.prototype.save = function(writer, bRaiseEvent) {
      if (typeof bRaiseEvent === "undefined") {
        this.save(writer, true);
      } else {
        writer.write(this.prefix);
        if (typeof this.beginSave !== "undefined") {
          this.onBeginSave();
        }
        if (typeof this.descendantFontBeginSave !== "undefined") {
          this.onDescendantFontBeginSave();
        }
        if (typeof this.fontDictionaryBeginSave !== "undefined") {
          this.onFontDictionaryBeginSave();
        }
        if (typeof this.annotationBeginSave !== "undefined") {
          this.onBeginAnnotationSave();
        }
        if (typeof this.sectionBeginSave !== "undefined") {
          this.onSectionBeginSave(writer);
        }
        if (typeof this.pageBeginDrawTemplate !== "undefined") {
          this.onTemplateBeginSave();
        }
        if (this.Count > 0) {
          this.saveItems(writer);
        }
        writer.write(this.suffix);
        writer.write(Operators.newLine);
      }
    };
    PdfDictionary2.prototype.saveItems = function(writer) {
      writer.write(Operators.newLine);
      var keys = this.primitiveItems.keys();
      var values = this.primitiveItems.values();
      for (var index = 0; index < keys.length; index++) {
        var key = keys[index];
        var name_1 = new PdfName(key);
        name_1.save(writer);
        writer.write(Operators.whiteSpace);
        var resources = values[index];
        resources.save(writer);
        writer.write(Operators.newLine);
      }
    };
    return PdfDictionary2;
  }()
);
var SaveSectionCollectionEventHandler = (
  /** @class */
  function() {
    function SaveSectionCollectionEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveSectionCollectionEventHandler2;
  }()
);
var SaveDescendantFontEventHandler = (
  /** @class */
  function() {
    function SaveDescendantFontEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveDescendantFontEventHandler2;
  }()
);
var SaveFontDictionaryEventHandler = (
  /** @class */
  function() {
    function SaveFontDictionaryEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveFontDictionaryEventHandler2;
  }()
);
var SaveAnnotationEventHandler = (
  /** @class */
  function() {
    function SaveAnnotationEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveAnnotationEventHandler2;
  }()
);
var SaveSectionEventHandler = (
  /** @class */
  function() {
    function SaveSectionEventHandler2(sender, state) {
      this.sender = sender;
      this.state = state;
    }
    return SaveSectionEventHandler2;
  }()
);
var SaveTemplateEventHandler = (
  /** @class */
  function() {
    function SaveTemplateEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveTemplateEventHandler2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-string.js
var InternalEnum;
(function(InternalEnum2) {
  var ForceEncoding;
  (function(ForceEncoding2) {
    ForceEncoding2[ForceEncoding2["None"] = 0] = "None";
    ForceEncoding2[ForceEncoding2["Ascii"] = 1] = "Ascii";
    ForceEncoding2[ForceEncoding2["Unicode"] = 2] = "Unicode";
  })(ForceEncoding = InternalEnum2.ForceEncoding || (InternalEnum2.ForceEncoding = {}));
  var SourceType;
  (function(SourceType2) {
    SourceType2[SourceType2["StringValue"] = 0] = "StringValue";
    SourceType2[SourceType2["ByteBuffer"] = 1] = "ByteBuffer";
  })(SourceType || (SourceType = {}));
})(InternalEnum || (InternalEnum = {}));
var PdfString = (
  /** @class */
  function() {
    function PdfString2(value) {
      this.bHex = false;
      this.position1 = -1;
      this.clonedObject1 = null;
      this.bDecrypted = false;
      this.isParentDecrypted = false;
      this.isPacked = false;
      this.isFormField = false;
      this.isColorSpace = false;
      this.isHexString = true;
      if (typeof value === "undefined") {
        this.bHex = false;
      } else {
        if (!(value.length > 0 && value[0] === "0xfeff")) {
          this.stringValue = value;
          this.data = [];
          for (var i = 0; i < value.length; ++i) {
            this.data.push(value.charCodeAt(i));
          }
        }
      }
    }
    Object.defineProperty(PdfString2.prototype, "hex", {
      //Property
      /**
       * Gets a value indicating whether string is in `hex`.
       * @private
       */
      get: function() {
        return this.bHex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "value", {
      /**
       * Gets or sets string `value` of the object.
       * @private
       */
      get: function() {
        return this.stringValue;
      },
      set: function(value) {
        this.stringValue = value;
        this.data = null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status1;
      },
      set: function(value) {
        this.status1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving1;
      },
      set: function(value) {
        this.isSaving1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index1;
      },
      set: function(value) {
        this.index1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return this.clonedObject1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position1;
      },
      set: function(value) {
        this.position1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "CrossTable", {
      /**
       * Returns `PdfCrossTable` associated with the object.
       * @private
       */
      get: function() {
        return this.crossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "converted", {
      /**
       * Gets a value indicating whether to check if the value has unicode characters.
       * @private
       */
      get: function() {
        return this.bConverted;
      },
      /**
       * sets a value indicating whether to check if the value has unicode characters.
       * @private
       */
      set: function(value) {
        this.bConverted = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "encode", {
      /**
       * Gets value indicating whether we should convert data to Unicode.
       */
      get: function() {
        return this.bForceEncoding;
      },
      set: function(value) {
        this.bForceEncoding = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfString2.bytesToHex = function(bytes) {
      if (bytes == null) {
        return "";
      }
      var builder = "";
      return builder;
    };
    PdfString2.prototype.save = function(writer) {
      if (writer === null) {
        throw new Error("ArgumentNullException : writer");
      }
      if (this.encode !== void 0 && this.encode === InternalEnum.ForceEncoding.Ascii) {
        writer.write(this.pdfEncode());
      } else {
        writer.write(PdfString2.stringMark[0] + this.value + PdfString2.stringMark[1]);
      }
    };
    PdfString2.prototype.pdfEncode = function() {
      var result = "";
      if (this.encode !== void 0 && this.encode === InternalEnum.ForceEncoding.Ascii) {
        var data = this.escapeSymbols(this.value);
        for (var i = 0; i < data.length; i++) {
          result += String.fromCharCode(data[i]);
        }
        result = PdfString2.stringMark[0] + result + PdfString2.stringMark[1];
      } else {
        result = this.value;
      }
      return result;
    };
    PdfString2.prototype.escapeSymbols = function(value) {
      var data = [];
      for (var i = 0; i < value.length; i++) {
        var currentData = value.charCodeAt(i);
        switch (currentData) {
          case 40:
          case 41:
            data.push(92);
            data.push(currentData);
            break;
          case 13:
            data.push(92);
            data.push(114);
            break;
          case 92:
            data.push(92);
            data.push(currentData);
            break;
          default:
            data.push(currentData);
            break;
        }
      }
      return data;
    };
    PdfString2.prototype.clone = function(crossTable) {
      if (this.clonedObject1 !== null && this.clonedObject1.CrossTable === crossTable) {
        return this.clonedObject1;
      } else {
        this.clonedObject1 = null;
      }
      var newString = new PdfString2(this.stringValue);
      newString.bHex = this.bHex;
      newString.crossTable = crossTable;
      newString.isColorSpace = this.isColorSpace;
      this.clonedObject1 = newString;
      return newString;
    };
    PdfString2.toUnicodeArray = function(value, bAddPrefix) {
      if (value == null) {
        throw new Error("Argument Null Exception : value");
      }
      var startIndex = 0;
      var output = [];
      for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        output.push(code / 256 >>> 0);
        output.push(code & 255);
      }
      return output;
    };
    PdfString2.byteToString = function(data) {
      if (data == null) {
        throw new Error("Argument Null Exception : stream");
      }
      var result = "";
      for (var i = 0; i < data.length; ++i) {
        result += String.fromCharCode(data[i]);
      }
      return result;
    };
    PdfString2.stringMark = "()";
    PdfString2.hexStringMark = "<>";
    PdfString2.hexFormatPattern = "{0:X2}";
    return PdfString2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-reference.js
var PdfReference = (
  /** @class */
  function() {
    function PdfReference2(objNumber, genNumber) {
      this.index3 = -1;
      this.position3 = -1;
      this.objNumber = 0;
      this.genNumber = 0;
      if (typeof objNumber === "number" && typeof genNumber === "number") {
        this.objNumber = objNumber;
        this.genNumber = genNumber;
      } else {
        this.objNumber = Number(objNumber);
        this.genNumber = Number(genNumber);
      }
    }
    Object.defineProperty(PdfReference2.prototype, "status", {
      //Property
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status3;
      },
      set: function(value) {
        this.status3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving3;
      },
      set: function(value) {
        this.isSaving3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index3;
      },
      set: function(value) {
        this.index3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position3;
      },
      set: function(value) {
        this.position3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        var returnObject3 = null;
        return returnObject3;
      },
      enumerable: true,
      configurable: true
    });
    PdfReference2.prototype.save = function(writer) {
      writer.write(this.toString());
    };
    PdfReference2.prototype.toString = function() {
      return this.objNumber.toString() + " " + this.genNumber.toString() + " R";
    };
    PdfReference2.prototype.clone = function(crossTable) {
      return null;
    };
    return PdfReference2;
  }()
);
var PdfReferenceHolder = (
  /** @class */
  function() {
    function PdfReferenceHolder2(obj1, obj2) {
      this.index4 = -1;
      this.position4 = -1;
      this.objectIndex = -1;
      this.dictionaryProperties = new DictionaryProperties();
      this.initialize(obj1);
    }
    Object.defineProperty(PdfReferenceHolder2.prototype, "status", {
      //Properties
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status4;
      },
      set: function(value) {
        this.status4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving4;
      },
      set: function(value) {
        this.isSaving4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index4;
      },
      set: function(value) {
        this.index4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position4;
      },
      set: function(value) {
        this.position4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "object", {
      /**
       * Gets the `object` the reference is of.
       * @private
       */
      get: function() {
        return this.primitiveObject;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "reference", {
      /**
       * Gets the `reference`.
       * @private
       */
      get: function() {
        return this.pdfReference;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "index", {
      /**
       * Gets the `index` of the object.
       * @private
       */
      get: function() {
        return this.objectIndex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "element", {
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.primitiveObject;
      },
      enumerable: true,
      configurable: true
    });
    PdfReferenceHolder2.prototype.initialize = function(obj1) {
      if (obj1 instanceof PdfArray || obj1 instanceof PdfDictionary || obj1 instanceof PdfName || obj1 instanceof PdfNumber || obj1 instanceof PdfStream || obj1 instanceof PdfReference || obj1 instanceof PdfString) {
        this.primitiveObject = obj1;
      } else {
        var tempObj = obj1;
        this.initialize(tempObj.element);
      }
    };
    PdfReferenceHolder2.prototype.save = function(writer) {
      var position = writer.position;
      var cTable = writer.document.crossTable;
      this.object.isSaving = true;
      var reference = null;
      reference = cTable.getReference(this.object);
      reference.save(writer);
    };
    PdfReferenceHolder2.prototype.clone = function(crossTable) {
      var refHolder = null;
      var temp = null;
      var refNum = "";
      var reference = null;
      return null;
    };
    return PdfReferenceHolder2;
  }()
);

// node_modules/@syncfusion/ej2-file-utils/src/save.js
var Save = (
  /** @class */
  function() {
    function Save2() {
    }
    Save2.save = function(fileName, buffer) {
      if (fileName === null || fileName === void 0 || fileName === "") {
        throw new Error("ArgumentException: fileName cannot be undefined, null or empty");
      }
      var extension = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length);
      var mimeType = this.getMimeType(extension);
      if (mimeType !== "") {
        buffer = new Blob([buffer], { type: mimeType });
      }
      if (this.isMicrosoftBrowser) {
        navigator.msSaveBlob(buffer, fileName);
      } else {
        var downloadLink = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
        this.saveInternal(fileName, extension, buffer, downloadLink, "download" in downloadLink);
      }
    };
    Save2.saveInternal = function(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {
      if (hasDownloadAttribute) {
        downloadLink.download = fileName;
        var dataUrl_1 = window.URL.createObjectURL(buffer);
        downloadLink.href = dataUrl_1;
        var event_1 = document.createEvent("MouseEvent");
        event_1.initEvent("click", true, true);
        downloadLink.dispatchEvent(event_1);
        setTimeout(function() {
          window.URL.revokeObjectURL(dataUrl_1);
          dataUrl_1 = void 0;
        });
      } else {
        if (extension !== "docx" && extension !== "xlsx") {
          var url = window.URL.createObjectURL(buffer);
          var isPopupBlocked = window.open(url, "_blank");
          if (!isPopupBlocked) {
            window.location.href = url;
          }
        } else {
          var reader_1 = new FileReader();
          reader_1.onloadend = function() {
            var isPopupBlocked2 = window.open(reader_1.result, "_blank");
            if (!isPopupBlocked2) {
              window.location.href = reader_1.result;
            }
          };
          reader_1.readAsDataURL(buffer);
        }
      }
    };
    Save2.getMimeType = function(extension) {
      var mimeType = "";
      switch (extension) {
        case "html":
          mimeType = "text/html";
          break;
        case "pdf":
          mimeType = "application/pdf";
          break;
        case "docx":
          mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          break;
        case "xlsx":
          mimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
          break;
        case "txt":
          mimeType = "text/plain";
          break;
      }
      return mimeType;
    };
    return Save2;
  }()
);

// node_modules/@syncfusion/ej2-file-utils/src/xml-writer.js
var XmlWriter = (
  /** @class */
  function() {
    function XmlWriter2() {
      this.contentPos = 0;
      this.bufferText = "";
      this.bufferBlob = new Blob([""], { type: "text/plain" });
      this.currentState = "Initial";
      this.namespaceStack = [];
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[0].set("xmlns", "http://www.w3.org/2000/xmlns/", "Special");
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[1].set("xml", "http://www.w3.org/XML/1998/namespace", "Special");
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[2].set("", "", "Implied");
      this.elementStack = [];
      this.elementStack.push(new XmlElement());
      this.elementStack[0].set("", "", "", this.namespaceStack.length - 1);
      this.attributeStack = [];
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(XmlWriter2.prototype, "buffer", {
      /**
       * Gets the content written to the {XmlWriter} as Blob.
       * @returns {Blob}
       */
      get: function() {
        this.flush();
        return this.bufferBlob;
      },
      enumerable: true,
      configurable: true
    });
    XmlWriter2.prototype.writeProcessingInstruction = function(name, text) {
      if (name === void 0 || name === null || name.length === 0) {
        throw new Error("ArgumentException: name should not be undefined, null or empty");
      }
      this.checkName(name);
      if (text === void 0 || text === null) {
        text = "";
      }
      if (name.length === 3 && name === "xml") {
        if (this.currentState !== "Initial") {
          throw new Error("InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it");
        }
      }
      if (this.currentState !== "Initial" || this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      } else {
        this.writeStartDocument();
        this.writeProcessingInstructionInternal(name, text);
      }
    };
    XmlWriter2.prototype.writeStartDocument = function(standalone) {
      if (this.currentState !== "Initial" || this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      this.currentState = "StartDocument";
      this.rawText('<?xml version="1.0" encoding="utf-8');
      if (standalone !== null && standalone !== void 0) {
        this.rawText('" standalone="');
        this.rawText(standalone ? "yes" : "no");
      }
      this.rawText('"?>');
    };
    XmlWriter2.prototype.writeEndDocument = function() {
      while (this.elementStack.length - 1 > 0) {
        this.writeEndElement();
      }
      this.currentState = "EndDocument";
      this.flush();
    };
    XmlWriter2.prototype.writeStartElement = function(prefix, localName, namespace) {
      if (this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      if (localName === void 0 || localName === null || localName.length === 0) {
        throw new Error("ArgumentException: localName cannot be undefined, null or empty");
      }
      this.checkName(localName);
      if (this.currentState === "Initial") {
        this.writeStartDocument();
      }
      if (this.currentState === "StartElement") {
        this.startElementContent();
      }
      this.currentState = "StartElement";
      if (prefix === void 0 || prefix === null) {
        if (namespace !== void 0 && namespace !== null) {
          prefix = this.lookupPrefix(namespace);
        }
        if (prefix === void 0 || prefix === null) {
          prefix = "";
        }
      } else if (prefix.length > 0) {
        if (namespace === void 0 || namespace === null) {
          namespace = this.lookupNamespace(prefix);
        }
        if (namespace === void 0 || namespace === null || namespace !== void 0 && namespace.length === 0) {
          throw new Error("ArgumentException: Cannot use a prefix with an empty namespace");
        }
      }
      if (namespace === void 0 || namespace === null) {
        namespace = this.lookupNamespace(prefix);
      }
      this.writeStartElementInternal(prefix, localName, namespace);
    };
    XmlWriter2.prototype.writeEndElement = function() {
      if (this.currentState === "StartElement") {
        this.startElementContent();
        this.currentState = "ElementContent";
      } else if (this.currentState === "ElementContent") {
        this.currentState = "ElementContent";
      }
      this.currentState = "EndElement";
      var top = this.elementStack.length - 1;
      this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);
      this.namespaceStack.splice(this.elementStack[top].previousTop + 1);
      this.elementStack.splice(top);
      if (this.bufferText.length > 10240) {
        this.flush();
      }
    };
    XmlWriter2.prototype.writeElementString = function(prefix, localName, namespace, value) {
      this.writeStartElement(prefix, localName, namespace);
      if (value !== void 0 && value !== null && value.length !== 0) {
        this.writeString(value);
      }
      this.writeEndElement();
    };
    XmlWriter2.prototype.writeAttributeString = function(prefix, localName, namespace, value) {
      this.writeStartAttribute(prefix, localName, namespace, value);
      this.writeStringInternal(value, true);
      this.writeEndAttribute();
    };
    XmlWriter2.prototype.writeString = function(text) {
      this.writeInternal(text, false);
    };
    XmlWriter2.prototype.writeRaw = function(text) {
      this.writeInternal(text, true);
    };
    XmlWriter2.prototype.writeInternal = function(text, isRawString) {
      if (text === void 0 || text === null) {
        return;
      } else {
        if (this.currentState !== "StartElement" && this.currentState !== "ElementContent") {
          throw new Error("InvalidOperationException: Wrong Token");
        }
        if (this.currentState === "StartElement") {
          this.startElementContent();
        }
        this.currentState = "ElementContent";
        if (isRawString) {
          this.rawText(text);
        } else {
          this.writeStringInternal(text, false);
        }
      }
    };
    XmlWriter2.prototype.save = function(fileName) {
      while (this.elementStack.length - 1 > 0) {
        this.writeEndElement();
      }
      if (this.bufferText !== "") {
        this.flush();
      }
      Save.save(fileName, this.buffer);
    };
    XmlWriter2.prototype.destroy = function() {
      this.bufferBlob = void 0;
      for (var i = 0; i < this.namespaceStack.length; i++) {
        this.namespaceStack[i].destroy();
      }
      this.namespaceStack = [];
      for (var i = 0; i < this.elementStack.length; i++) {
        this.elementStack[i].destroy();
      }
      this.elementStack = [];
      this.bufferText = "";
      this.contentPos = 0;
    };
    XmlWriter2.prototype.flush = function() {
      if (this.bufferBlob === void 0) {
        return;
      }
      this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: "text/plain" });
      this.bufferText = "";
    };
    XmlWriter2.prototype.writeProcessingInstructionInternal = function(name, text) {
      this.bufferText += "<?";
      this.rawText(name);
      if (text.length > 0) {
        this.bufferText += " ";
        text = text.replace(/\?\>/g, "? >");
        this.bufferText += text;
      }
      this.bufferText += "?";
      this.bufferText += ">";
    };
    XmlWriter2.prototype.writeStartAttribute = function(prefix, localName, namespace, value) {
      if (localName === void 0 || localName === null || localName.length === 0) {
        if (prefix === "xmlns") {
          localName = "xmlns";
          prefix = "";
        } else {
          throw new Error("ArgumentException: localName cannot be undefined, null or empty");
        }
      }
      if (this.currentState !== "StartElement") {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      this.checkName(localName);
      this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);
    };
    XmlWriter2.prototype.writeStartAttributePrefixAndNameSpace = function(prefix, localName, namespace, value) {
      if (prefix === void 0 || prefix === null) {
        if (namespace !== void 0 && namespace !== null) {
          if (!(localName === "xmlns" && namespace === "http://www.w3.org/2000/xmlns/")) {
            prefix = this.lookupPrefix(namespace);
          }
        }
        if (prefix === void 0 || prefix === null) {
          prefix = "";
        }
      }
      if (namespace === void 0 || namespace === null) {
        if (prefix !== void 0 && prefix !== null && prefix.length > 0) {
          namespace = this.lookupNamespace(prefix);
        }
        if (namespace === void 0 || namespace === null) {
          namespace = "";
        }
      }
      this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);
    };
    XmlWriter2.prototype.writeStartAttributeSpecialAttribute = function(prefix, localName, namespace, value) {
      if (prefix.length === 0) {
        if (localName[0] === "x" && localName === "xmlns") {
          this.skipPushAndWrite(prefix, localName, namespace);
          this.pushNamespaceExplicit("", value);
          return;
        } else if (namespace.length > 0) {
          prefix = this.lookupPrefix(namespace);
        }
      } else {
        if (prefix[0] === "x") {
          if (prefix === "xmlns") {
            this.skipPushAndWrite(prefix, localName, namespace);
            this.pushNamespaceExplicit(localName, value);
            return;
          } else if (prefix === "xml") {
            if (localName === "space" || localName === "lang") {
              this.skipPushAndWrite(prefix, localName, namespace);
              return;
            }
          }
        }
        if (namespace.length === 0) {
          prefix = "";
        }
      }
      if (prefix !== void 0 && prefix !== null && prefix.length !== 0) {
        this.pushNamespaceImplicit(prefix, namespace);
      }
      this.skipPushAndWrite(prefix, localName, namespace);
    };
    XmlWriter2.prototype.writeEndAttribute = function() {
      this.currentState = "StartElement";
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeStartElementInternal = function(prefix, localName, namespace) {
      this.bufferText += "<";
      if (prefix.length > 0) {
        this.rawText(prefix);
        this.bufferText += ":";
      }
      this.rawText(localName);
      var top = this.elementStack.length;
      this.elementStack.push(new XmlElement());
      this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);
      this.pushNamespaceImplicit(prefix, namespace);
      for (var i = 0; i < this.attributeStack.length; i++) {
        this.attributeStack[i].destroy();
      }
      this.attributeStack = [];
    };
    XmlWriter2.prototype.writeEndElementInternal = function(prefix, localName) {
      if (this.contentPos !== this.bufferText.length + 1) {
        this.bufferText += "</";
        if (prefix !== void 0 && prefix !== null && prefix.length !== 0) {
          this.rawText(prefix);
          this.bufferText += ":";
        }
        this.rawText(localName);
        this.bufferText += ">";
      } else {
        this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);
        this.bufferText += " />";
      }
    };
    XmlWriter2.prototype.writeStartAttributeInternal = function(prefix, localName, namespaceName) {
      this.bufferText += " ";
      if (prefix !== void 0 && prefix !== null && prefix.length > 0) {
        this.rawText(prefix);
        this.bufferText += ":";
      }
      this.rawText(localName);
      this.bufferText += "=";
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeNamespaceDeclaration = function(prefix, namespaceUri) {
      this.writeStartNamespaceDeclaration(prefix);
      this.writeStringInternal(namespaceUri, true);
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeStartNamespaceDeclaration = function(prefix) {
      if (prefix === void 0 || prefix === null || prefix.length === 0) {
        this.rawText(' xmlns="');
      } else {
        this.rawText(" xmlns:");
        this.rawText(prefix);
        this.bufferText += "=";
        this.bufferText += '"';
      }
    };
    XmlWriter2.prototype.writeStringInternal = function(text, inAttributeValue) {
      if (text === null || text === void 0) {
        text = "";
      }
      var tempText = "";
      text = text.replace(/\&/g, "&amp;");
      text = text.replace(/\</g, "&lt;");
      text = text.replace(/\>/g, "&gt;");
      if (inAttributeValue) {
        text = text.replace(/\"/g, "&quot;");
      }
      this.bufferText += text;
      if (!inAttributeValue) {
        this.contentPos = 0;
      }
    };
    XmlWriter2.prototype.startElementContent = function() {
      var start = this.elementStack[this.elementStack.length - 1].previousTop;
      for (var i = this.namespaceStack.length - 1; i > start; i--) {
        if (this.namespaceStack[i].kind === "NeedToWrite") {
          this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);
        }
      }
      this.bufferText += ">";
      this.contentPos = this.bufferText.length + 1;
    };
    XmlWriter2.prototype.rawText = function(text) {
      this.bufferText += text;
    };
    XmlWriter2.prototype.addNamespace = function(prefix, ns, kind) {
      var top = this.namespaceStack.length;
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[top].set(prefix, ns, kind);
    };
    XmlWriter2.prototype.lookupPrefix = function(namespace) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].namespaceUri === namespace) {
          return this.namespaceStack[i].prefix;
        }
      }
      return void 0;
    };
    XmlWriter2.prototype.lookupNamespace = function(prefix) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].prefix === prefix) {
          return this.namespaceStack[i].namespaceUri;
        }
      }
      return void 0;
    };
    XmlWriter2.prototype.lookupNamespaceIndex = function(prefix) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].prefix === prefix) {
          return i;
        }
      }
      return -1;
    };
    XmlWriter2.prototype.pushNamespaceImplicit = function(prefix, ns) {
      var kind;
      var existingNsIndex = this.lookupNamespaceIndex(prefix);
      if (existingNsIndex !== -1) {
        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {
          if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {
            throw new Error("XmlException namespace Uri needs to be the same as the one that is already declared");
          }
          return;
        } else {
          if (this.namespaceStack[existingNsIndex].kind === "Special") {
            if (prefix === "xml") {
              if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {
                throw new Error("InvalidArgumentException: Xml String");
              } else {
                kind = "Implied";
              }
            } else {
              throw new Error('InvalidArgumentException: Prefix "xmlns" is reserved for use by XML.');
            }
          } else {
            kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? "Implied" : "NeedToWrite";
          }
        }
      } else {
        if (ns === "http://www.w3.org/XML/1998/namespace" && prefix !== "xml" || ns === "http://www.w3.org/2000/xmlns/" && prefix !== "xmlns") {
          throw new Error("InvalidArgumentException");
        }
        kind = "NeedToWrite";
      }
      this.addNamespace(prefix, ns, kind);
    };
    XmlWriter2.prototype.pushNamespaceExplicit = function(prefix, ns) {
      var existingNsIndex = this.lookupNamespaceIndex(prefix);
      if (existingNsIndex !== -1) {
        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {
          this.namespaceStack[existingNsIndex].kind = "Written";
          return;
        }
      }
      this.addNamespace(prefix, ns, "Written");
      return;
    };
    XmlWriter2.prototype.addAttribute = function(prefix, localName, namespaceName) {
      var top = this.attributeStack.length;
      this.attributeStack.push(new XmlAttribute());
      this.attributeStack[top].set(prefix, localName, namespaceName);
      for (var i = 0; i < top; i++) {
        if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {
          throw new Error("XmlException: duplicate attribute name");
        }
      }
    };
    XmlWriter2.prototype.skipPushAndWrite = function(prefix, localName, namespace) {
      this.addAttribute(prefix, localName, namespace);
      this.writeStartAttributeInternal(prefix, localName, namespace);
    };
    XmlWriter2.prototype.checkName = function(text) {
      var format = /[ !@#$%^&*()+\=\[\]{};':"\\|,<>\/?]/;
      if (format.test(text)) {
        throw new Error("InvalidArgumentException: invalid name character");
      }
    };
    return XmlWriter2;
  }()
);
var Namespace = (
  /** @class */
  function() {
    function Namespace2() {
    }
    Namespace2.prototype.set = function(prefix, namespaceUri, kind) {
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.kind = kind;
    };
    Namespace2.prototype.destroy = function() {
      this.prefix = void 0;
      this.namespaceUri = void 0;
      this.kind = void 0;
    };
    return Namespace2;
  }()
);
var XmlElement = (
  /** @class */
  function() {
    function XmlElement2() {
    }
    XmlElement2.prototype.set = function(prefix, localName, namespaceUri, previousTop) {
      this.previousTop = previousTop;
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.localName = localName;
    };
    XmlElement2.prototype.destroy = function() {
      this.previousTop = void 0;
      this.prefix = void 0;
      this.localName = void 0;
      this.namespaceUri = void 0;
    };
    return XmlElement2;
  }()
);
var XmlAttribute = (
  /** @class */
  function() {
    function XmlAttribute2() {
    }
    XmlAttribute2.prototype.set = function(prefix, localName, namespaceUri) {
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.localName = localName;
    };
    XmlAttribute2.prototype.isDuplicate = function(prefix, localName, namespaceUri) {
      return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);
    };
    XmlAttribute2.prototype.destroy = function() {
      this.prefix = void 0;
      this.namespaceUri = void 0;
      this.localName = void 0;
    };
    return XmlAttribute2;
  }()
);

// node_modules/@syncfusion/ej2-file-utils/src/encoding.js
var Encoding = (
  /** @class */
  function() {
    function Encoding2(includeBom) {
      this.emitBOM = true;
      this.encodingType = "Ansi";
      this.initBOM(includeBom);
    }
    Object.defineProperty(Encoding2.prototype, "includeBom", {
      /**
       * Gets a value indicating whether to write a Unicode byte order mark
       * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false
       */
      get: function() {
        return this.emitBOM;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Encoding2.prototype, "type", {
      /**
       * Gets the encoding type.
       * @returns EncodingType
       */
      get: function() {
        return this.encodingType;
      },
      /**
       * Sets the encoding type.
       * @param  {EncodingType} value
       */
      set: function(value) {
        this.encodingType = value;
      },
      enumerable: true,
      configurable: true
    });
    Encoding2.prototype.initBOM = function(includeBom) {
      if (includeBom === void 0 || includeBom === null) {
        this.emitBOM = true;
      } else {
        this.emitBOM = includeBom;
      }
    };
    Encoding2.prototype.getByteCount = function(chars) {
      var byteCount = 0;
      validateNullOrUndefined(chars, "string");
      if (chars === "") {
        var byte = this.utf8Len(chars.charCodeAt(0));
        return byte;
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      return this.getByteCountInternal(chars, 0, chars.length);
    };
    Encoding2.prototype.utf8Len = function(codePoint) {
      var bytes = codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : codePoint <= 2097151 ? 4 : 0;
      return bytes;
    };
    Encoding2.prototype.isHighSurrogate = function(codeUnit) {
      return codeUnit >= 55296 && codeUnit <= 56319;
    };
    Encoding2.prototype.toCodepoint = function(highCodeUnit, lowCodeUnit) {
      highCodeUnit = (1023 & highCodeUnit) << 10;
      var u = highCodeUnit | 1023 & lowCodeUnit;
      return u + 65536;
    };
    Encoding2.prototype.getByteCountInternal = function(chars, charIndex, charCount) {
      var byteCount = 0;
      if (this.encodingType === "Utf8" || this.encodingType === "Unicode") {
        var isUtf8 = this.encodingType === "Utf8";
        for (var i = 0; i < charCount; i++) {
          var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);
          if (this.isHighSurrogate(charCode)) {
            if (isUtf8) {
              var high = charCode;
              var low = chars.charCodeAt(++charIndex);
              byteCount += this.utf8Len(this.toCodepoint(high, low));
            } else {
              byteCount += 4;
              ++i;
            }
          } else {
            if (isUtf8) {
              byteCount += this.utf8Len(charCode);
            } else {
              byteCount += 2;
            }
          }
          if (isUtf8) {
            charIndex++;
          }
        }
        return byteCount;
      } else {
        byteCount = charCount;
        return byteCount;
      }
    };
    Encoding2.prototype.getBytes = function(s, charIndex, charCount) {
      validateNullOrUndefined(s, "string");
      validateNullOrUndefined(charIndex, "charIndex");
      validateNullOrUndefined(charCount, "charCount");
      if (charIndex < 0 || charCount < 0) {
        throw new RangeError("Argument Out Of Range Exception: charIndex or charCount is less than zero");
      }
      if (s.length - charIndex < charCount) {
        throw new RangeError("Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string");
      }
      var bytes;
      if (s === "") {
        bytes = new ArrayBuffer(0);
        return bytes;
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      var byteCount = this.getByteCountInternal(s, charIndex, charCount);
      switch (this.type) {
        case "Utf8":
          bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);
          return bytes;
        case "Unicode":
          bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);
          return bytes;
        default:
          bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);
          return bytes;
      }
    };
    Encoding2.prototype.getString = function(bytes, index, count) {
      validateNullOrUndefined(bytes, "bytes");
      validateNullOrUndefined(index, "index");
      validateNullOrUndefined(count, "count");
      if (index < 0 || count < 0) {
        throw new RangeError("Argument Out Of Range Exception: index or count is less than zero");
      }
      if (bytes.byteLength - index < count) {
        throw new RangeError("Argument Out Of Range Exception: index and count do not denote a valid range in bytes");
      }
      if (bytes.byteLength === 0 || count === 0) {
        return "";
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      var out = "";
      var byteCal = new Uint8Array(bytes);
      switch (this.type) {
        case "Utf8":
          var s = this.getStringOfUtf8Encoding(byteCal, index, count);
          return s;
        case "Unicode":
          var byteUnicode = new Uint16Array(bytes);
          out = this.getStringofUnicodeEncoding(byteUnicode, index, count);
          return out;
        default:
          var j = index;
          for (var i = 0; i < count; i++) {
            var c = byteCal[j];
            out += String.fromCharCode(c);
            j++;
          }
          return out;
      }
    };
    Encoding2.prototype.getBytesOfAnsiEncoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var bufview = new Uint8Array(bytes);
      var k = 0;
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(charIndex++);
        if (charcode < 2048) {
          bufview[k] = charcode;
        } else {
          bufview[k] = 63;
        }
        k++;
      }
      return bytes;
    };
    Encoding2.prototype.getBytesOfUtf8Encoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var uint = new Uint8Array(bytes);
      var index = charIndex;
      var j = 0;
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(index);
        if (charcode <= 127) {
          uint[j] = charcode;
        } else if (charcode < 2048) {
          uint[j] = 192 | charcode >> 6;
          uint[++j] = 128 | charcode & 63;
        } else if (charcode < 55296 || charcode >= 57344) {
          uint[j] = 224 | charcode >> 12;
          uint[++j] = 128 | charcode >> 6 & 63;
          uint[++j] = 128 | charcode & 63;
        } else {
          uint[j] = 239;
          uint[++j] = 191;
          uint[++j] = 189;
        }
        ++j;
        ++index;
      }
      return bytes;
    };
    Encoding2.prototype.getBytesOfUnicodeEncoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var uint16 = new Uint16Array(bytes);
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(i);
        uint16[i] = charcode;
      }
      return bytes;
    };
    Encoding2.prototype.getStringOfUtf8Encoding = function(byteCal, index, count) {
      var j = 0;
      var i = index;
      var s = "";
      for (j; j < count; j++) {
        var c = byteCal[i++];
        while (i > byteCal.length) {
          return s;
        }
        if (c > 127) {
          if (c > 191 && c < 224 && i < count) {
            c = (c & 31) << 6 | byteCal[i] & 63;
          } else if (c > 223 && c < 240 && i < byteCal.byteLength) {
            c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;
          } else if (c > 239 && c < 248 && i < byteCal.byteLength) {
            c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;
          }
          ++i;
        }
        s += String.fromCharCode(c);
      }
      return s;
    };
    Encoding2.prototype.getStringofUnicodeEncoding = function(byteUni, index, count) {
      if (count > byteUni.length) {
        throw new RangeError("ArgumentOutOfRange_Count");
      }
      var byte16 = new Uint16Array(count);
      var out = "";
      for (var i = 0; i < count && i < byteUni.length; i++) {
        byte16[i] = byteUni[index++];
      }
      out = String.fromCharCode.apply(null, byte16);
      return out;
    };
    Encoding2.prototype.destroy = function() {
      this.emitBOM = void 0;
      this.encodingType = void 0;
    };
    return Encoding2;
  }()
);
function validateNullOrUndefined(value, message) {
  if (value === null || value === void 0) {
    throw new Error("ArgumentException: " + message + " cannot be null or undefined");
  }
}

// node_modules/@syncfusion/ej2-file-utils/src/stream-writer.js
var StreamWriter = (
  /** @class */
  function() {
    function StreamWriter2(encoding) {
      this.bufferBlob = new Blob([""]);
      this.bufferText = "";
      this.init(encoding);
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(StreamWriter2.prototype, "buffer", {
      /**
       * Gets the content written to the StreamWriter as Blob.
       * @returns Blob
       */
      get: function() {
        this.flush();
        return this.bufferBlob;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StreamWriter2.prototype, "encoding", {
      /**
       * Gets the encoding.
       * @returns Encoding
       */
      get: function() {
        return this.enc;
      },
      enumerable: true,
      configurable: true
    });
    StreamWriter2.prototype.init = function(encoding) {
      if (encoding === null || encoding === void 0) {
        this.enc = new Encoding(false);
        this.enc.type = "Utf8";
      } else {
        this.enc = encoding;
        this.setBomByte();
      }
    };
    StreamWriter2.prototype.setBomByte = function() {
      if (this.encoding.includeBom) {
        switch (this.encoding.type) {
          case "Unicode":
            var arrayUnicode = new ArrayBuffer(2);
            var uint8 = new Uint8Array(arrayUnicode);
            uint8[0] = 255;
            uint8[1] = 254;
            this.bufferBlob = new Blob([arrayUnicode]);
            break;
          case "Utf8":
            var arrayUtf8 = new ArrayBuffer(3);
            var utf8 = new Uint8Array(arrayUtf8);
            utf8[0] = 239;
            utf8[1] = 187;
            utf8[2] = 191;
            this.bufferBlob = new Blob([arrayUtf8]);
            break;
          default:
            this.bufferBlob = new Blob([""]);
            break;
        }
      }
    };
    StreamWriter2.prototype.save = function(fileName) {
      if (this.bufferText !== "") {
        this.flush();
      }
      Save.save(fileName, this.buffer);
    };
    StreamWriter2.prototype.write = function(value) {
      if (this.encoding === void 0) {
        throw new Error("Object Disposed Exception: current writer is disposed");
      }
      validateNullOrUndefined(value, "string");
      this.bufferText += value;
      if (this.bufferText.length >= 10240) {
        this.flush();
      }
    };
    StreamWriter2.prototype.flush = function() {
      if (this.bufferText === void 0 || this.bufferText === null || this.bufferText.length === 0) {
        return;
      }
      var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);
      this.bufferText = "";
      this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);
    };
    StreamWriter2.prototype.writeLine = function(value) {
      if (this.encoding === void 0) {
        throw new Error("Object Disposed Exception: current writer is disposed");
      }
      validateNullOrUndefined(value, "string");
      this.bufferText = this.bufferText + value + "\r\n";
      if (this.bufferText.length >= 10240) {
        this.flush();
      }
    };
    StreamWriter2.prototype.destroy = function() {
      this.bufferBlob = void 0;
      this.bufferText = void 0;
      if (this.enc instanceof Encoding) {
        this.enc.destroy();
      }
      this.enc = void 0;
    };
    return StreamWriter2;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/compression-writer.js
var ARR_LITERAL_CODES = new Int16Array(286);
var ARR_LITERAL_LENGTHS = new Uint8Array(286);
var ARR_DISTANCE_CODES = new Int16Array(30);
var ARR_DISTANCE_LENGTHS = new Uint8Array(30);
var CompressedStreamWriter = (
  /** @class */
  function() {
    function CompressedStreamWriter2(noWrap) {
      this.pendingBuffer = new Uint8Array(1 << 16);
      this.pendingBufLength = 0;
      this.pendingBufCache = 0;
      this.pendingBufBitsInCache = 0;
      this.bufferPosition = 0;
      this.extraBits = 0;
      this.currentHash = 0;
      this.matchStart = 0;
      this.matchLength = 0;
      this.matchPrevAvail = false;
      this.blockStart = 0;
      this.stringStart = 0;
      this.lookAhead = 0;
      this.totalBytesIn = 0;
      this.inputOffset = 0;
      this.inputEnd = 0;
      this.windowSize = 1 << 15;
      this.windowMask = this.windowSize - 1;
      this.hashSize = 1 << 15;
      this.hashMask = this.hashSize - 1;
      this.hashShift = Math.floor((15 + 3 - 1) / 3);
      this.maxDist = this.windowSize - 262;
      this.checkSum = 1;
      this.noWrap = false;
      if (!CompressedStreamWriter2.isHuffmanTreeInitiated) {
        CompressedStreamWriter2.initHuffmanTree();
        CompressedStreamWriter2.isHuffmanTreeInitiated = true;
      }
      this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);
      this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);
      this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);
      this.arrDistances = new Uint16Array(1 << 14);
      this.arrLiterals = new Uint8Array(1 << 14);
      this.stream = [];
      this.dataWindow = new Uint8Array(2 * this.windowSize);
      this.hashHead = new Int16Array(this.hashSize);
      this.hashPrevious = new Int16Array(this.windowSize);
      this.blockStart = this.stringStart = 1;
      this.noWrap = noWrap;
      if (!noWrap) {
        this.writeZLibHeader();
      }
    }
    Object.defineProperty(CompressedStreamWriter2.prototype, "compressedData", {
      /**
       * get compressed data
       */
      get: function() {
        return this.stream;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressedStreamWriter2.prototype, "getCompressedString", {
      get: function() {
        var compressedString = "";
        if (this.stream !== void 0) {
          for (var i = 0; i < this.stream.length; i++) {
            compressedString += String.fromCharCode.apply(null, this.stream[i]);
          }
        }
        return compressedString;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamWriter2.prototype.write = function(data, offset, length) {
      if (data === void 0 || data === null) {
        throw new Error("ArgumentException: data cannot null or undefined");
      }
      var end = offset + length;
      if (0 > offset || offset > end || end > data.length) {
        throw new Error("ArgumentOutOfRangeException: Offset or length is incorrect");
      }
      if (typeof data === "string") {
        var encode = new Encoding(false);
        encode.type = "Utf8";
        data = new Uint8Array(encode.getBytes(data, 0, data.length));
        end = offset + data.length;
      }
      this.inputBuffer = data;
      this.inputOffset = offset;
      this.inputEnd = end;
      if (!this.noWrap) {
        this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);
      }
      while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {
        this.pendingBufferFlush();
        this.compressData(false);
      }
    };
    CompressedStreamWriter2.prototype.writeZLibHeader = function() {
      var headerDate = 8 + (7 << 4) << 8;
      headerDate |= (5 >> 2 & 3) << 6;
      headerDate += 31 - headerDate % 31;
      this.pendingBufferWriteShortBytes(headerDate);
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteShortBytes = function(s) {
      this.pendingBuffer[this.pendingBufLength++] = s >> 8;
      this.pendingBuffer[this.pendingBufLength++] = s;
    };
    CompressedStreamWriter2.prototype.compressData = function(finish) {
      var success;
      do {
        this.fillWindow();
        var canFlush = finish && this.inputEnd === this.inputOffset;
        success = this.compressSlow(canFlush, finish);
      } while (this.pendingBufLength === 0 && success);
      return success;
    };
    CompressedStreamWriter2.prototype.compressSlow = function(flush, finish) {
      if (this.lookAhead < 262 && !flush) {
        return false;
      }
      while (this.lookAhead >= 262 || flush) {
        if (this.lookAhead === 0) {
          return this.lookAheadCompleted(finish);
        }
        if (this.stringStart >= 2 * this.windowSize - 262) {
          this.slideWindow();
        }
        var prevMatch = this.matchStart;
        var prevLen = this.matchLength;
        if (this.lookAhead >= 3) {
          this.discardMatch();
        }
        if (prevLen >= 3 && this.matchLength <= prevLen) {
          prevLen = this.matchPreviousBest(prevMatch, prevLen);
        } else {
          this.matchPreviousAvailable();
        }
        if (this.bufferPosition >= 1 << 14) {
          return this.huffmanIsFull(finish);
        }
      }
      return true;
    };
    CompressedStreamWriter2.prototype.discardMatch = function() {
      var hashHead = this.insertString();
      if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {
        if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {
          this.matchLength = 3 - 1;
        }
      }
    };
    CompressedStreamWriter2.prototype.matchPreviousAvailable = function() {
      if (this.matchPrevAvail) {
        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 255);
      }
      this.matchPrevAvail = true;
      this.stringStart++;
      this.lookAhead--;
    };
    CompressedStreamWriter2.prototype.matchPreviousBest = function(prevMatch, prevLen) {
      this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);
      prevLen -= 2;
      do {
        this.stringStart++;
        this.lookAhead--;
        if (this.lookAhead >= 3) {
          this.insertString();
        }
      } while (--prevLen > 0);
      this.stringStart++;
      this.lookAhead--;
      this.matchPrevAvail = false;
      this.matchLength = 3 - 1;
      return prevLen;
    };
    CompressedStreamWriter2.prototype.lookAheadCompleted = function(finish) {
      if (this.matchPrevAvail) {
        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 255);
      }
      this.matchPrevAvail = false;
      this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);
      this.blockStart = this.stringStart;
      return false;
    };
    CompressedStreamWriter2.prototype.huffmanIsFull = function(finish) {
      var len = this.stringStart - this.blockStart;
      if (this.matchPrevAvail) {
        len--;
      }
      var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;
      this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);
      this.blockStart += len;
      return !lastBlock;
    };
    CompressedStreamWriter2.prototype.fillWindow = function() {
      if (this.stringStart >= this.windowSize + this.maxDist) {
        this.slideWindow();
      }
      while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {
        var more = 2 * this.windowSize - this.lookAhead - this.stringStart;
        if (more > this.inputEnd - this.inputOffset) {
          more = this.inputEnd - this.inputOffset;
        }
        this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);
        this.inputOffset += more;
        this.totalBytesIn += more;
        this.lookAhead += more;
      }
      if (this.lookAhead >= 3) {
        this.updateHash();
      }
    };
    CompressedStreamWriter2.prototype.slideWindow = function() {
      this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);
      this.matchStart -= this.windowSize;
      this.stringStart -= this.windowSize;
      this.blockStart -= this.windowSize;
      for (var i = 0; i < this.hashSize; ++i) {
        var m = this.hashHead[i] & 65535;
        this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;
      }
      for (var i = 0; i < this.windowSize; i++) {
        var m = this.hashPrevious[i] & 65535;
        this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;
      }
    };
    CompressedStreamWriter2.prototype.insertString = function() {
      var match;
      var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;
      this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];
      this.hashHead[hash] = this.stringStart;
      this.currentHash = hash;
      return match & 65535;
    };
    CompressedStreamWriter2.prototype.findLongestMatch = function(curMatch) {
      var chainLen = 4096;
      var niceLen = 258;
      var scan = this.stringStart;
      var match;
      var bestEnd = this.stringStart + this.matchLength;
      var bestLength = Math.max(this.matchLength, 3 - 1);
      var limit = Math.max(this.stringStart - this.maxDist, 0);
      var stringEnd = this.stringStart + 258 - 1;
      var scanEnd1 = this.dataWindow[bestEnd - 1];
      var scanEnd = this.dataWindow[bestEnd];
      var data = this.dataWindow;
      if (bestLength >= 32) {
        chainLen >>= 2;
      }
      if (niceLen > this.lookAhead) {
        niceLen = this.lookAhead;
      }
      do {
        if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {
          continue;
        }
        match = curMatch + 2;
        scan += 2;
        while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {
        }
        if (scan > bestEnd) {
          this.matchStart = curMatch;
          bestEnd = scan;
          bestLength = scan - this.stringStart;
          if (bestLength >= niceLen) {
            break;
          }
          scanEnd1 = data[bestEnd - 1];
          scanEnd = data[bestEnd];
        }
        scan = this.stringStart;
      } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 65535) > limit && --chainLen !== 0);
      this.matchLength = Math.min(bestLength, this.lookAhead);
      return this.matchLength >= 3;
    };
    CompressedStreamWriter2.prototype.updateHash = function() {
      this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];
    };
    CompressedStreamWriter2.prototype.huffmanTallyLit = function(literal) {
      this.arrDistances[this.bufferPosition] = 0;
      this.arrLiterals[this.bufferPosition++] = literal;
      this.treeLiteral.codeFrequencies[literal]++;
      return this.bufferPosition >= 1 << 14;
    };
    CompressedStreamWriter2.prototype.huffmanTallyDist = function(dist, len) {
      this.arrDistances[this.bufferPosition] = dist;
      this.arrLiterals[this.bufferPosition++] = len - 3;
      var lc = this.huffmanLengthCode(len - 3);
      this.treeLiteral.codeFrequencies[lc]++;
      if (lc >= 265 && lc < 285) {
        this.extraBits += Math.floor((lc - 261) / 4);
      }
      var dc = this.huffmanDistanceCode(dist - 1);
      this.treeDistances.codeFrequencies[dc]++;
      if (dc >= 4) {
        this.extraBits += Math.floor(dc / 2 - 1);
      }
      return this.bufferPosition >= 1 << 14;
    };
    CompressedStreamWriter2.prototype.huffmanFlushBlock = function(stored, storedOffset, storedLength, lastBlock) {
      this.treeLiteral.codeFrequencies[256]++;
      this.treeLiteral.buildTree();
      this.treeDistances.buildTree();
      this.treeLiteral.calculateBLFreq(this.treeCodeLengths);
      this.treeDistances.calculateBLFreq(this.treeCodeLengths);
      this.treeCodeLengths.buildTree();
      var blTreeCodes = 4;
      for (var i = 18; i > blTreeCodes; i--) {
        if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {
          blTreeCodes = i + 1;
        }
      }
      var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;
      var static_len = this.extraBits;
      for (var i = 0; i < 286; i++) {
        static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];
      }
      for (var i = 0; i < 30; i++) {
        static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];
      }
      if (opt_len >= static_len) {
        opt_len = static_len;
      }
      if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {
        this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
      } else if (opt_len == static_len) {
        this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);
        this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);
        this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);
        this.huffmanCompressBlock();
        this.huffmanReset();
      } else {
        this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);
        this.huffmanSendAllTrees(blTreeCodes);
        this.huffmanCompressBlock();
        this.huffmanReset();
      }
    };
    CompressedStreamWriter2.prototype.huffmanFlushStoredBlock = function(stored, storedOffset, storedLength, lastBlock) {
      this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);
      this.pendingBufferAlignToByte();
      this.pendingBufferWriteShort(storedLength);
      this.pendingBufferWriteShort(~storedLength);
      this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);
      this.huffmanReset();
    };
    CompressedStreamWriter2.prototype.huffmanLengthCode = function(len) {
      if (len === 255) {
        return 285;
      }
      var code = 257;
      while (len >= 8) {
        code += 4;
        len >>= 1;
      }
      return code + len;
    };
    CompressedStreamWriter2.prototype.huffmanDistanceCode = function(distance) {
      var code = 0;
      while (distance >= 4) {
        code += 2;
        distance >>= 1;
      }
      return code + distance;
    };
    CompressedStreamWriter2.prototype.huffmanSendAllTrees = function(blTreeCodes) {
      this.treeCodeLengths.buildCodes();
      this.treeLiteral.buildCodes();
      this.treeDistances.buildCodes();
      this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);
      this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);
      this.pendingBufferWriteBits(blTreeCodes - 4, 4);
      for (var rank = 0; rank < blTreeCodes; rank++) {
        this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);
      }
      this.treeLiteral.writeTree(this.treeCodeLengths);
      this.treeDistances.writeTree(this.treeCodeLengths);
    };
    CompressedStreamWriter2.prototype.huffmanReset = function() {
      this.bufferPosition = 0;
      this.extraBits = 0;
      this.treeLiteral.reset();
      this.treeDistances.reset();
      this.treeCodeLengths.reset();
    };
    CompressedStreamWriter2.prototype.huffmanCompressBlock = function() {
      for (var i = 0; i < this.bufferPosition; i++) {
        var literalLen = this.arrLiterals[i] & 255;
        var dist = this.arrDistances[i];
        if (dist-- !== 0) {
          var lc = this.huffmanLengthCode(literalLen);
          this.treeLiteral.writeCodeToStream(lc);
          var bits = Math.floor((lc - 261) / 4);
          if (bits > 0 && bits <= 5) {
            this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);
          }
          var dc = this.huffmanDistanceCode(dist);
          this.treeDistances.writeCodeToStream(dc);
          bits = Math.floor(dc / 2 - 1);
          if (bits > 0) {
            this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);
          }
        } else {
          this.treeLiteral.writeCodeToStream(literalLen);
        }
      }
      this.treeLiteral.writeCodeToStream(256);
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteBits = function(b, count) {
      var uint = new Uint32Array(1);
      uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;
      this.pendingBufCache = uint[0];
      this.pendingBufBitsInCache += count;
      this.pendingBufferFlushBits();
    };
    CompressedStreamWriter2.prototype.pendingBufferFlush = function(isClose) {
      this.pendingBufferFlushBits();
      if (this.pendingBufLength > 0) {
        var array = new Uint8Array(this.pendingBufLength);
        array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);
        this.stream.push(array);
      }
      this.pendingBufLength = 0;
    };
    CompressedStreamWriter2.prototype.pendingBufferFlushBits = function() {
      var result = 0;
      while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {
        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
        this.pendingBufCache >>= 8;
        this.pendingBufBitsInCache -= 8;
        result++;
      }
      return result;
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteByteBlock = function(data, offset, length) {
      var array = data.subarray(offset, offset + length);
      this.pendingBuffer.set(array, this.pendingBufLength);
      this.pendingBufLength += length;
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteShort = function(s) {
      this.pendingBuffer[this.pendingBufLength++] = s;
      this.pendingBuffer[this.pendingBufLength++] = s >> 8;
    };
    CompressedStreamWriter2.prototype.pendingBufferAlignToByte = function() {
      if (this.pendingBufBitsInCache > 0) {
        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
      }
      this.pendingBufCache = 0;
      this.pendingBufBitsInCache = 0;
    };
    CompressedStreamWriter2.initHuffmanTree = function() {
      var i = 0;
      while (i < 144) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(48 + i << 8);
        ARR_LITERAL_LENGTHS[i++] = 8;
      }
      while (i < 256) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(400 - 144 + i << 7);
        ARR_LITERAL_LENGTHS[i++] = 9;
      }
      while (i < 280) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0 - 256 + i << 9);
        ARR_LITERAL_LENGTHS[i++] = 7;
      }
      while (i < 286) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(192 - 280 + i << 8);
        ARR_LITERAL_LENGTHS[i++] = 8;
      }
      for (i = 0; i < 30; i++) {
        ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);
        ARR_DISTANCE_LENGTHS[i] = 5;
      }
    };
    CompressedStreamWriter2.prototype.close = function() {
      do {
        this.pendingBufferFlush(true);
        if (!this.compressData(true)) {
          this.pendingBufferFlush(true);
          this.pendingBufferAlignToByte();
          if (!this.noWrap) {
            this.pendingBufferWriteShortBytes(this.checkSum >> 16);
            this.pendingBufferWriteShortBytes(this.checkSum & 65535);
          }
          this.pendingBufferFlush(true);
        }
      } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));
    };
    CompressedStreamWriter2.prototype.destroy = function() {
      this.stream = [];
      this.stream = void 0;
      this.pendingBuffer = void 0;
      this.treeLiteral = void 0;
      this.treeDistances = void 0;
      this.treeCodeLengths = void 0;
      this.arrLiterals = void 0;
      this.arrDistances = void 0;
      this.hashHead = void 0;
      this.hashPrevious = void 0;
      this.dataWindow = void 0;
      this.inputBuffer = void 0;
      this.pendingBufLength = void 0;
      this.pendingBufCache = void 0;
      this.pendingBufBitsInCache = void 0;
      this.bufferPosition = void 0;
      this.extraBits = void 0;
      this.currentHash = void 0;
      this.matchStart = void 0;
      this.matchLength = void 0;
      this.matchPrevAvail = void 0;
      this.blockStart = void 0;
      this.stringStart = void 0;
      this.lookAhead = void 0;
      this.totalBytesIn = void 0;
      this.inputOffset = void 0;
      this.inputEnd = void 0;
      this.windowSize = void 0;
      this.windowMask = void 0;
      this.hashSize = void 0;
      this.hashMask = void 0;
      this.hashShift = void 0;
      this.maxDist = void 0;
      this.checkSum = void 0;
      this.noWrap = void 0;
    };
    CompressedStreamWriter2.isHuffmanTreeInitiated = false;
    return CompressedStreamWriter2;
  }()
);
var CompressorHuffmanTree = (
  /** @class */
  function() {
    function CompressorHuffmanTree2(writer, elementCount, minCodes, maxLength) {
      this.writer = writer;
      this.codeMinCount = minCodes;
      this.maxLength = maxLength;
      this.codeFrequency = new Uint16Array(elementCount);
      this.lengthCount = new Int32Array(maxLength);
    }
    Object.defineProperty(CompressorHuffmanTree2.prototype, "treeLength", {
      get: function() {
        return this.codeCount;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressorHuffmanTree2.prototype, "codeLengths", {
      get: function() {
        return this.codeLength;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressorHuffmanTree2.prototype, "codeFrequencies", {
      get: function() {
        return this.codeFrequency;
      },
      enumerable: true,
      configurable: true
    });
    CompressorHuffmanTree2.prototype.setStaticCodes = function(codes, lengths) {
      var temp = new Int16Array(codes.length);
      temp.set(codes, 0);
      this.codes = temp;
      var lengthTemp = new Uint8Array(lengths.length);
      lengthTemp.set(lengths, 0);
      this.codeLength = lengthTemp;
    };
    CompressorHuffmanTree2.prototype.reset = function() {
      for (var i = 0; i < this.codeFrequency.length; i++) {
        this.codeFrequency[i] = 0;
      }
      this.codes = void 0;
      this.codeLength = void 0;
    };
    CompressorHuffmanTree2.prototype.writeCodeToStream = function(code) {
      this.writer.pendingBufferWriteBits(this.codes[code] & 65535, this.codeLength[code]);
    };
    CompressorHuffmanTree2.prototype.buildCodes = function() {
      var nextCode = new Int32Array(this.maxLength);
      this.codes = new Int16Array(this.codeCount);
      var code = 0;
      for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {
        nextCode[bitsCount] = code;
        code += this.lengthCount[bitsCount] << 15 - bitsCount;
      }
      for (var i = 0; i < this.codeCount; i++) {
        var bits = this.codeLength[i];
        if (bits > 0) {
          this.codes[i] = CompressorHuffmanTree2.bitReverse(nextCode[bits - 1]);
          nextCode[bits - 1] += 1 << 16 - bits;
        }
      }
    };
    CompressorHuffmanTree2.bitReverse = function(value) {
      return CompressorHuffmanTree2.reverseBits[value & 15] << 12 | CompressorHuffmanTree2.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree2.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree2.reverseBits[value >> 12];
    };
    CompressorHuffmanTree2.prototype.getEncodedLength = function() {
      var len = 0;
      for (var i = 0; i < this.codeFrequency.length; i++) {
        len += this.codeFrequency[i] * this.codeLength[i];
      }
      return len;
    };
    CompressorHuffmanTree2.prototype.calculateBLFreq = function(blTree) {
      var maxCount;
      var minCount;
      var count;
      var curLen = -1;
      var i = 0;
      while (i < this.codeCount) {
        count = 1;
        var nextLen = this.codeLength[i];
        if (nextLen === 0) {
          maxCount = 138;
          minCount = 3;
        } else {
          maxCount = 6;
          minCount = 3;
          if (curLen !== nextLen) {
            blTree.codeFrequency[nextLen]++;
            count = 0;
          }
        }
        curLen = nextLen;
        i++;
        while (i < this.codeCount && curLen === this.codeLength[i]) {
          i++;
          if (++count >= maxCount) {
            break;
          }
        }
        if (count < minCount) {
          blTree.codeFrequency[curLen] += count;
        } else if (curLen !== 0) {
          blTree.codeFrequency[16]++;
        } else if (count <= 10) {
          blTree.codeFrequency[17]++;
        } else {
          blTree.codeFrequency[18]++;
        }
      }
    };
    CompressorHuffmanTree2.prototype.writeTree = function(blTree) {
      var maxRepeatCount;
      var minRepeatCount;
      var currentRepeatCount;
      var currentCodeLength = -1;
      var i = 0;
      while (i < this.codeCount) {
        currentRepeatCount = 1;
        var nextLen = this.codeLength[i];
        if (nextLen === 0) {
          maxRepeatCount = 138;
          minRepeatCount = 3;
        } else {
          maxRepeatCount = 6;
          minRepeatCount = 3;
          if (currentCodeLength !== nextLen) {
            blTree.writeCodeToStream(nextLen);
            currentRepeatCount = 0;
          }
        }
        currentCodeLength = nextLen;
        i++;
        while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {
          i++;
          if (++currentRepeatCount >= maxRepeatCount) {
            break;
          }
        }
        if (currentRepeatCount < minRepeatCount) {
          while (currentRepeatCount-- > 0) {
            blTree.writeCodeToStream(currentCodeLength);
          }
        } else if (currentCodeLength !== 0) {
          blTree.writeCodeToStream(16);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);
        } else if (currentRepeatCount <= 10) {
          blTree.writeCodeToStream(17);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);
        } else {
          blTree.writeCodeToStream(18);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);
        }
      }
    };
    CompressorHuffmanTree2.prototype.buildTree = function() {
      var codesCount = this.codeFrequency.length;
      var arrTree = new Int32Array(codesCount);
      var treeLength = 0;
      var maxCount = 0;
      for (var n = 0; n < codesCount; n++) {
        var freq = this.codeFrequency[n];
        if (freq !== 0) {
          var pos = treeLength++;
          var pPos = 0;
          while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {
            arrTree[pos] = arrTree[pPos];
            pos = pPos;
          }
          arrTree[pos] = n;
          maxCount = n;
        }
      }
      while (treeLength < 2) {
        arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;
      }
      this.codeCount = Math.max(maxCount + 1, this.codeMinCount);
      var leafsCount = treeLength;
      var nodesCount = leafsCount;
      var child = new Int32Array(4 * treeLength - 2);
      var values = new Int32Array(2 * treeLength - 1);
      for (var i = 0; i < treeLength; i++) {
        var node = arrTree[i];
        var iIndex = 2 * i;
        child[iIndex] = node;
        child[iIndex + 1] = -1;
        values[i] = this.codeFrequency[node] << 8;
        arrTree[i] = i;
      }
      this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);
      this.buildLength(child);
    };
    CompressorHuffmanTree2.prototype.constructHuffmanTree = function(arrTree, treeLength, values, nodesCount, child) {
      do {
        var first = arrTree[0];
        var last = arrTree[--treeLength];
        var lastVal = values[last];
        var pPos = 0;
        var path = 1;
        while (path < treeLength) {
          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
            path++;
          }
          arrTree[pPos] = arrTree[path];
          pPos = path;
          path = pPos * 2 + 1;
        }
        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
          arrTree[path] = arrTree[pPos];
        }
        arrTree[path] = last;
        var second = arrTree[0];
        last = nodesCount++;
        child[2 * last] = first;
        child[2 * last + 1] = second;
        var minDepth = Math.min(values[first] & 255, values[second] & 255);
        values[last] = lastVal = values[first] + values[second] - minDepth + 1;
        pPos = 0;
        path = 1;
        while (path < treeLength) {
          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
            path++;
          }
          arrTree[pPos] = arrTree[path];
          pPos = path;
          path = pPos * 2 + 1;
        }
        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
          arrTree[path] = arrTree[pPos];
        }
        arrTree[path] = last;
      } while (treeLength > 1);
    };
    CompressorHuffmanTree2.prototype.buildLength = function(child) {
      this.codeLength = new Uint8Array(this.codeFrequency.length);
      var numNodes = Math.floor(child.length / 2);
      var numLeafs = Math.floor((numNodes + 1) / 2);
      var overflow = 0;
      for (var i = 0; i < this.maxLength; i++) {
        this.lengthCount[i] = 0;
      }
      overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);
      if (overflow === 0) {
        return;
      }
      var iIncreasableLength = this.maxLength - 1;
      do {
        while (this.lengthCount[--iIncreasableLength] === 0) {
        }
        do {
          this.lengthCount[iIncreasableLength]--;
          this.lengthCount[++iIncreasableLength]++;
          overflow -= 1 << this.maxLength - 1 - iIncreasableLength;
        } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);
      } while (overflow > 0);
      this.recreateTree(child, overflow, numLeafs);
    };
    CompressorHuffmanTree2.prototype.recreateTree = function(child, overflow, numLeafs) {
      this.lengthCount[this.maxLength - 1] += overflow;
      this.lengthCount[this.maxLength - 2] -= overflow;
      var nodePtr = 2 * numLeafs;
      for (var bits = this.maxLength; bits !== 0; bits--) {
        var n = this.lengthCount[bits - 1];
        while (n > 0) {
          var childPtr = 2 * child[nodePtr++];
          if (child[childPtr + 1] === -1) {
            this.codeLength[child[childPtr]] = bits;
            n--;
          }
        }
      }
    };
    CompressorHuffmanTree2.prototype.calculateOptimalCodeLength = function(child, overflow, numNodes) {
      var lengths = new Int32Array(numNodes);
      lengths[numNodes - 1] = 0;
      for (var i = numNodes - 1; i >= 0; i--) {
        var childIndex = 2 * i + 1;
        if (child[childIndex] !== -1) {
          var bitLength = lengths[i] + 1;
          if (bitLength > this.maxLength) {
            bitLength = this.maxLength;
            overflow++;
          }
          lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;
        } else {
          var bitLength = lengths[i];
          this.lengthCount[bitLength - 1]++;
          this.codeLength[child[childIndex - 1]] = lengths[i];
        }
      }
      return overflow;
    };
    CompressorHuffmanTree2.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
    CompressorHuffmanTree2.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    return CompressorHuffmanTree2;
  }()
);
var ChecksumCalculator = (
  /** @class */
  function() {
    function ChecksumCalculator2() {
    }
    ChecksumCalculator2.checksumUpdate = function(checksum, buffer, offset, length) {
      var uint = new Uint32Array(1);
      uint[0] = checksum;
      var checksum_uint = uint[0];
      var s1 = uint[0] = checksum_uint & 65535;
      var s2 = uint[0] = checksum_uint >> ChecksumCalculator2.checkSumBitOffset;
      while (length > 0) {
        var steps = Math.min(length, ChecksumCalculator2.checksumIterationCount);
        length -= steps;
        while (--steps >= 0) {
          s1 = s1 + (uint[0] = buffer[offset++] & 255);
          s2 = s2 + s1;
        }
        s1 %= ChecksumCalculator2.checksumBase;
        s2 %= ChecksumCalculator2.checksumBase;
      }
      checksum_uint = s2 << ChecksumCalculator2.checkSumBitOffset | s1;
      return checksum_uint;
    };
    ChecksumCalculator2.checkSumBitOffset = 16;
    ChecksumCalculator2.checksumBase = 65521;
    ChecksumCalculator2.checksumIterationCount = 3800;
    return ChecksumCalculator2;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/zip-archive.js
var CRC32TABLE = [];
var ZipArchive = (
  /** @class */
  function() {
    function ZipArchive2() {
      if (CRC32TABLE.length === 0) {
        ZipArchive2.initCrc32Table();
      }
      this.files = [];
      this.level = "Normal";
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(ZipArchive2.prototype, "compressionLevel", {
      /**
       * gets compression level
       */
      get: function() {
        return this.level;
      },
      /**
       * sets compression level
       */
      set: function(level) {
        this.level = level;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchive2.prototype, "length", {
      /**
       * gets items count
       */
      get: function() {
        if (this.files === void 0) {
          return 0;
        }
        return this.files.length;
      },
      enumerable: true,
      configurable: true
    });
    ZipArchive2.prototype.addItem = function(item) {
      if (item === null || item === void 0) {
        throw new Error("ArgumentException: item cannot be null or undefined");
      }
      for (var i = 0; i < this.files.length; i++) {
        var file = this.files[i];
        if (file instanceof ZipArchiveItem) {
          if (file.name === item.name) {
            throw new Error("item with same name already exist");
          }
        }
      }
      this.files.push(item);
    };
    ZipArchive2.prototype.addDirectory = function(directoryName) {
      if (directoryName === null || directoryName === void 0) {
        throw new Error("ArgumentException: string cannot be null or undefined");
      }
      if (directoryName.length === 0) {
        throw new Error("ArgumentException: string cannot be empty");
      }
      if (directoryName.slice(-1) !== "/") {
        directoryName += "/";
      }
      if (this.files.indexOf(directoryName) !== -1) {
        throw new Error("item with same name already exist");
      }
      this.files.push(directoryName);
    };
    ZipArchive2.prototype.getItem = function(index) {
      if (index >= 0 && index < this.files.length) {
        return this.files[index];
      }
      return void 0;
    };
    ZipArchive2.prototype.contains = function(item) {
      return this.files.indexOf(item) !== -1 ? true : false;
    };
    ZipArchive2.prototype.save = function(fileName) {
      if (fileName === null || fileName === void 0 || fileName.length === 0) {
        throw new Error("ArgumentException: fileName cannot be null or undefined");
      }
      if (this.files.length === 0) {
        throw new Error("InvalidOperation");
      }
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        zipArchive.saveInternal(fileName, false).then(function() {
          resolve(zipArchive);
        });
      });
    };
    ZipArchive2.prototype.saveAsBlob = function() {
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        zipArchive.saveInternal("", true).then(function(blob) {
          resolve(blob);
        });
      });
    };
    ZipArchive2.prototype.saveInternal = function(fileName, skipFileSave) {
      var _this = this;
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        var zipData = [];
        var dirLength = 0;
        for (var i = 0; i < zipArchive.files.length; i++) {
          var compressedObject = _this.getCompressedData(_this.files[i]);
          compressedObject.then(function(data) {
            dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);
            if (zipData.length === zipArchive.files.length) {
              var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);
              resolve(blob);
            }
          });
        }
      });
    };
    ZipArchive2.prototype.destroy = function() {
      if (this.files !== void 0 && this.files.length > 0) {
        for (var i = 0; i < this.files.length; i++) {
          var file = this.files[i];
          if (file instanceof ZipArchiveItem) {
            file.destroy();
          }
          file = void 0;
        }
        this.files = [];
      }
      this.files = void 0;
      this.level = void 0;
    };
    ZipArchive2.prototype.getCompressedData = function(item) {
      var zipArchive = this;
      var promise = new Promise(function(resolve, reject) {
        if (item instanceof ZipArchiveItem) {
          var reader_1 = new FileReader();
          reader_1.onload = function() {
            var input = new Uint8Array(reader_1.result);
            var data2 = {
              fileName: item.name,
              crc32Value: 0,
              compressedData: [],
              compressedSize: void 0,
              uncompressedDataSize: input.length,
              compressionType: void 0,
              isDirectory: false
            };
            if (zipArchive.level === "Normal") {
              zipArchive.compressData(input, data2, CRC32TABLE);
              var length_1 = 0;
              for (var i = 0; i < data2.compressedData.length; i++) {
                length_1 += data2.compressedData[i].length;
              }
              data2.compressedSize = length_1;
              data2.compressionType = "\b\0";
            } else {
              data2.compressedSize = input.length;
              data2.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);
              data2.compressionType = "\0\0";
              data2.compressedData.push(input);
            }
            resolve(data2);
          };
          reader_1.readAsArrayBuffer(item.data);
        } else {
          var data = {
            fileName: item,
            crc32Value: 0,
            compressedData: "",
            compressedSize: 0,
            uncompressedDataSize: 0,
            compressionType: "\0\0",
            isDirectory: true
          };
          resolve(data);
        }
      });
      return promise;
    };
    ZipArchive2.prototype.compressData = function(input, data, crc32Table) {
      var compressor = new CompressedStreamWriter(true);
      var currentIndex = 0;
      var nextIndex = 0;
      do {
        if (currentIndex >= input.length) {
          compressor.close();
          break;
        }
        nextIndex = Math.min(input.length, currentIndex + 16384);
        var subArray = input.subarray(currentIndex, nextIndex);
        data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);
        compressor.write(subArray, 0, nextIndex - currentIndex);
        currentIndex = nextIndex;
      } while (currentIndex <= input.length);
      data.compressedData = compressor.compressedData;
      compressor.destroy();
    };
    ZipArchive2.prototype.constructZippedObject = function(zipParts, data, dirLength, isDirectory) {
      var extFileAttr = 0;
      var date = /* @__PURE__ */ new Date();
      if (isDirectory) {
        extFileAttr = extFileAttr | 16;
      }
      extFileAttr = extFileAttr | 0 & 63;
      var header = this.writeHeader(data, date);
      var localHeader = "PK" + header + data.fileName;
      var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);
      zipParts.push({ localHeader, centralDir, compressedData: data });
      return dirLength + localHeader.length + data.compressedSize;
    };
    ZipArchive2.prototype.writeHeader = function(data, date) {
      var zipHeader = "";
      zipHeader += "\n\0\0\0";
      zipHeader += data.compressionType;
      zipHeader += this.getBytes(this.getModifiedTime(date), 2);
      zipHeader += this.getBytes(this.getModifiedDate(date), 2);
      zipHeader += this.getBytes(data.crc32Value, 4);
      zipHeader += this.getBytes(data.compressedSize, 4);
      zipHeader += this.getBytes(data.uncompressedDataSize, 4);
      zipHeader += this.getBytes(data.fileName.length, 2);
      zipHeader += this.getBytes(0, 2);
      return zipHeader;
    };
    ZipArchive2.prototype.writeZippedContent = function(fileName, zipData, localDirLen, skipFileSave) {
      var cenDirLen = 0;
      var buffer = [];
      for (var i = 0; i < zipData.length; i++) {
        var item = zipData[i];
        cenDirLen += item.centralDir.length;
        buffer.push(this.getArrayBuffer(item.localHeader));
        while (item.compressedData.compressedData.length) {
          buffer.push(item.compressedData.compressedData.shift().buffer);
        }
      }
      for (var i = 0; i < zipData.length; i++) {
        buffer.push(this.getArrayBuffer(zipData[i].centralDir));
      }
      buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));
      var blob = new Blob(buffer, { type: "application/zip" });
      if (!skipFileSave) {
        Save.save(fileName, blob);
      }
      return blob;
    };
    ZipArchive2.prototype.writeCentralDirectory = function(data, localHeader, offset, externalFileAttribute) {
      var directoryHeader = "PK" + this.getBytes(20, 2) + localHeader + // inherit from file header
      this.getBytes(0, 2) + // comment length
      "\0\0\0\0" + // internal file attributes 
      this.getBytes(externalFileAttribute, 4) + // external file attributes
      this.getBytes(offset, 4) + // local fileHeader relative offset
      data.fileName;
      return directoryHeader;
    };
    ZipArchive2.prototype.writeFooter = function(zipData, centralLength, localLength) {
      var dirEnd = "PK\0\0\0\0" + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);
      return dirEnd;
    };
    ZipArchive2.prototype.getArrayBuffer = function(input) {
      var a = new Uint8Array(input.length);
      for (var j = 0; j < input.length; ++j) {
        a[j] = input.charCodeAt(j) & 255;
      }
      return a.buffer;
    };
    ZipArchive2.prototype.getBytes = function(value, offset) {
      var bytes = "";
      for (var i = 0; i < offset; i++) {
        bytes += String.fromCharCode(value & 255);
        value = value >>> 8;
      }
      return bytes;
    };
    ZipArchive2.prototype.getModifiedTime = function(date) {
      var modTime = date.getHours();
      modTime = modTime << 6;
      modTime = modTime | date.getMinutes();
      modTime = modTime << 5;
      return modTime = modTime | date.getSeconds() / 2;
    };
    ZipArchive2.prototype.getModifiedDate = function(date) {
      var modiDate = date.getFullYear() - 1980;
      modiDate = modiDate << 4;
      modiDate = modiDate | date.getMonth() + 1;
      modiDate = modiDate << 5;
      return modiDate = modiDate | date.getDate();
    };
    ZipArchive2.prototype.calculateCrc32Value = function(crc32Value, input, crc32Table) {
      crc32Value ^= -1;
      for (var i = 0; i < input.length; i++) {
        crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 255];
      }
      return crc32Value ^ -1;
    };
    ZipArchive2.initCrc32Table = function() {
      var i;
      for (var j = 0; j < 256; j++) {
        i = j;
        for (var k = 0; k < 8; k++) {
          i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
        }
        CRC32TABLE[j] = i;
      }
    };
    return ZipArchive2;
  }()
);
var ZipArchiveItem = (
  /** @class */
  function() {
    function ZipArchiveItem2(data, itemName) {
      if (data === null || data === void 0) {
        throw new Error("ArgumentException: data cannot be null or undefined");
      }
      if (itemName === null || itemName === void 0) {
        throw new Error("ArgumentException: string cannot be null or undefined");
      }
      if (itemName.length === 0) {
        throw new Error("string cannot be empty");
      }
      this.data = data;
      this.name = itemName;
    }
    Object.defineProperty(ZipArchiveItem2.prototype, "name", {
      /**
       * Get the name of archive item
       * @returns string
       */
      get: function() {
        return this.fileName;
      },
      /**
       * Set the name of archive item
       * @param  {string} value
       */
      set: function(value) {
        this.fileName = value;
      },
      enumerable: true,
      configurable: true
    });
    ZipArchiveItem2.prototype.destroy = function() {
      this.fileName = void 0;
      this.data = void 0;
    };
    return ZipArchiveItem2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-stream.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfStream = (
  /** @class */
  function(_super) {
    __extends2(PdfStream2, _super);
    function PdfStream2(dictionary, data) {
      var _this = _super.call(this, dictionary) || this;
      _this.dicPrefix = "stream";
      _this.dicSuffix = "endstream";
      _this.clonedObject2 = null;
      _this.bCompress = true;
      _this.isImageStream = false;
      _this.isFontStream = false;
      if (typeof dictionary !== "undefined" || typeof data !== "undefined") {
        _this.dataStream2 = [];
        _this.dataStream2 = data;
        _this.bCompress2 = false;
      } else {
        _this.dataStream2 = [];
        _this.bCompress2 = true;
      }
      return _this;
    }
    Object.defineProperty(PdfStream2.prototype, "internalStream", {
      /**
       * Gets the `internal` stream.
       * @private
       */
      get: function() {
        return this.dataStream2;
      },
      set: function(value) {
        this.dataStream2 = [];
        this.dataStream2 = value;
        this.modify();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStream2.prototype, "isImage", {
      /**
       * Gets or sets 'is image' flag.
       * @private
       */
      get: function() {
        return this.isImageStream;
      },
      set: function(value) {
        this.isImageStream = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStream2.prototype, "isFont", {
      /**
       * Gets or sets 'is font' flag.
       * @private
       */
      get: function() {
        return this.isFontStream;
      },
      set: function(value) {
        this.isFontStream = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStream2.prototype, "compress", {
      /**
       * Gets or sets `compression` flag.
       * @private
       */
      get: function() {
        return this.bCompress;
      },
      set: function(value) {
        this.bCompress = value;
        this.modify();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStream2.prototype, "data", {
      /**
       * Gets or sets the `data`.
       * @private
       */
      get: function() {
        return this.dataStream2;
      },
      set: function(value) {
        this.dataStream2 = [];
        this.dataStream2 = value;
        this.modify();
      },
      enumerable: true,
      configurable: true
    });
    PdfStream2.prototype.clearStream = function() {
      this.internalStream = [];
      if (this.items.containsKey(this.dictionaryProperties.filter)) {
        this.remove(this.dictionaryProperties.filter);
      }
      this.bCompress = true;
      this.modify();
    };
    PdfStream2.prototype.write = function(text) {
      if (text == null) {
        throw new Error("ArgumentNullException:text");
      }
      if (text.length <= 0) {
        throw new Error("ArgumentException: Can not write an empty string, text");
      }
      this.dataStream2.push(text);
      this.modify();
    };
    PdfStream2.prototype.writeBytes = function(data) {
      if (data === null) {
        throw new Error("ArgumentNullException:data");
      }
      if (data.length <= 0) {
        throw new Error("ArgumentException: Can not write an empty bytes, data");
      }
      var text = "";
      for (var i = 0; i < data.length; i++) {
        text += String.fromCharCode(data[i]);
      }
      this.dataStream2.push(text);
      this.modify();
    };
    PdfStream2.prototype.onCmapBeginSave = function() {
      this.cmapBeginSave.sender.cmapBeginSave();
    };
    PdfStream2.prototype.onFontProgramBeginSave = function() {
      this.fontProgramBeginSave.sender.fontProgramBeginSave();
    };
    PdfStream2.prototype.compressContent = function(data, writer) {
      if (this.bCompress) {
        var byteArray = [];
        for (var i = 0; i < data.length; i++) {
          byteArray.push(data.charCodeAt(i));
        }
        var dataArray = new Uint8Array(byteArray);
        var sw = new CompressedStreamWriter();
        sw.write(dataArray, 0, dataArray.length);
        sw.close();
        data = sw.getCompressedString;
        this.addFilter(this.dictionaryProperties.flatedecode);
      }
      return data;
    };
    PdfStream2.prototype.addFilter = function(filterName) {
      var obj = this.items.getValue(this.dictionaryProperties.filter);
      if (obj instanceof PdfReferenceHolder) {
        var rh = obj;
        obj = rh.object;
      }
      var array = obj;
      var name = obj;
      if (name != null) {
        array = new PdfArray();
        array.insert(0, name);
        this.items.setValue(this.dictionaryProperties.filter, array);
      }
      name = new PdfName(filterName);
      if (array == null) {
        this.items.setValue(this.dictionaryProperties.filter, name);
      } else {
        array.insert(0, name);
      }
    };
    PdfStream2.prototype.save = function(writer) {
      if (typeof this.cmapBeginSave !== "undefined") {
        this.onCmapBeginSave();
      }
      if (typeof this.fontProgramBeginSave !== "undefined") {
        this.onFontProgramBeginSave();
      }
      var data = "";
      for (var i = 0; i < this.data.length; i++) {
        data = data + this.data[i];
      }
      if (data.length > 1 && !this.isImage && !this.isFont) {
        data = "q\r\n" + data + "Q\r\n";
      }
      data = this.compressContent(data, writer);
      var length = data.length;
      this.items.setValue(this.dictionaryProperties.length, new PdfNumber(length));
      _super.prototype.save.call(this, writer, false);
      writer.write(this.dicPrefix);
      writer.write(Operators.newLine);
      if (data.length > 0) {
        writer.write(data);
      }
      writer.write(Operators.newLine);
      writer.write(this.dicSuffix);
      writer.write(Operators.newLine);
    };
    PdfStream2.bytesToString = function(byteArray) {
      var output = "";
      for (var i = 0; i < byteArray.length; i++) {
        output = output + String.fromCharCode(byteArray[i]);
      }
      return output;
    };
    return PdfStream2;
  }(PdfDictionary)
);
var SaveCmapEventHandler = (
  /** @class */
  function() {
    function SaveCmapEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveCmapEventHandler2;
  }()
);
var SaveFontProgramEventHandler = (
  /** @class */
  function() {
    function SaveFontProgramEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveFontProgramEventHandler2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-boolean.js
var PdfBoolean = (
  /** @class */
  function() {
    function PdfBoolean2(value) {
      this.currentPosition = -1;
      this.value = value;
    }
    Object.defineProperty(PdfBoolean2.prototype, "status", {
      //Properties
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.objectStatus;
      },
      set: function(value) {
        this.objectStatus = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.saving;
      },
      set: function(value) {
        this.saving = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index;
      },
      set: function(value) {
        this.index = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.currentPosition;
      },
      set: function(value) {
        this.currentPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        var rValue = null;
        return rValue;
      },
      enumerable: true,
      configurable: true
    });
    PdfBoolean2.prototype.save = function(writer) {
      writer.write(this.boolToStr(this.value));
    };
    PdfBoolean2.prototype.clone = function(crossTable) {
      var newNumber = new PdfBoolean2(this.value);
      return newNumber;
    };
    PdfBoolean2.prototype.boolToStr = function(value) {
      return value ? "true" : "false";
    };
    return PdfBoolean2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/image-decoder.js
var ImageFormat;
(function(ImageFormat2) {
  ImageFormat2[ImageFormat2["Unknown"] = 0] = "Unknown";
  ImageFormat2[ImageFormat2["Bmp"] = 1] = "Bmp";
  ImageFormat2[ImageFormat2["Emf"] = 2] = "Emf";
  ImageFormat2[ImageFormat2["Gif"] = 3] = "Gif";
  ImageFormat2[ImageFormat2["Jpeg"] = 4] = "Jpeg";
  ImageFormat2[ImageFormat2["Png"] = 5] = "Png";
  ImageFormat2[ImageFormat2["Wmf"] = 6] = "Wmf";
  ImageFormat2[ImageFormat2["Icon"] = 7] = "Icon";
})(ImageFormat || (ImageFormat = {}));
var ImageDecoder = (
  /** @class */
  function() {
    function ImageDecoder2(stream) {
      this.sof1Marker = 193;
      this.sof2Marker = 194;
      this.sof3Marker = 195;
      this.sof5Marker = 197;
      this.sof6Marker = 198;
      this.sof7Marker = 199;
      this.sof9Marker = 201;
      this.sof10Marker = 202;
      this.sof11Marker = 203;
      this.sof13Marker = 205;
      this.sof14Marker = 206;
      this.sof15Marker = 207;
      this.mFormat = ImageFormat.Unknown;
      this.mbitsPerComponent = 8;
      this.dictionaryProperties = new DictionaryProperties();
      this.mStream = stream;
      this.initialize();
    }
    Object.defineProperty(ImageDecoder2.prototype, "height", {
      /**
       * Gets the `height` of image.
       * @hidden
       * @private
       */
      get: function() {
        return this.mHeight;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "width", {
      /**
       * Gets the `width` of image.
       * @hidden
       * @private
       */
      get: function() {
        return this.mWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "bitsPerComponent", {
      /**
       * Gets `bits per component`.
       * @hidden
       * @private
       */
      get: function() {
        return this.mbitsPerComponent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "size", {
      /**
       * Gets the `size` of an image data.
       * @hidden
       * @private
       */
      get: function() {
        return this.mImageData.count;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "imageData", {
      /**
       * Gets the value of an `image data`.
       * @hidden
       * @private
       */
      get: function() {
        return this.mImageData;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "imageDataAsNumberArray", {
      /**
       * Gets the value of an `image data as number array`.
       * @hidden
       * @private
       */
      get: function() {
        return this.mImageData.internalBuffer.buffer;
      },
      enumerable: true,
      configurable: true
    });
    ImageDecoder2.prototype.initialize = function() {
      if (this.mFormat === ImageFormat.Unknown && this.checkIfJpeg()) {
        this.mFormat = ImageFormat.Jpeg;
        this.parseJpegImage();
      }
      this.reset();
      this.mImageData = new ByteArray(this.mStream.count);
      this.mStream.read(this.mImageData, 0, this.mImageData.count);
    };
    ImageDecoder2.prototype.reset = function() {
      this.mStream.position = 0;
    };
    ImageDecoder2.prototype.parseJpegImage = function() {
      this.reset();
      var imgData = new ByteArray(this.mStream.count);
      this.mStream.read(imgData, 0, imgData.count);
      var i = 4;
      var isLengthExceed = false;
      var length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);
      while (i < imgData.count) {
        i += length;
        if (i < imgData.count) {
          if (imgData.getBuffer(i + 1) === 192) {
            this.mHeight = imgData.getBuffer(i + 5) * 256 + imgData.getBuffer(i + 6);
            this.mWidth = imgData.getBuffer(i + 7) * 256 + imgData.getBuffer(i + 8);
            return;
          } else {
            i += 2;
            length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);
          }
        } else {
          isLengthExceed = true;
          break;
        }
      }
      if (isLengthExceed) {
        this.mStream.position = 0;
        this.skip(this.mStream, 2);
        this.readExceededJPGImage(this.mStream);
      }
    };
    Object.defineProperty(ImageDecoder2.prototype, "format", {
      /**
       * Gets the image `format`.
       * @private
       * @hidden
       */
      get: function() {
        return this.mFormat;
      },
      enumerable: true,
      configurable: true
    });
    ImageDecoder2.prototype.checkIfJpeg = function() {
      this.reset();
      for (var i = 0; i < ImageDecoder2.mJpegHeader.length; i++) {
        if (ImageDecoder2.mJpegHeader[i] !== this.mStream.readByte(i)) {
          return false;
        }
        this.mStream.position++;
      }
      return true;
    };
    ImageDecoder2.prototype.getImageDictionary = function() {
      if (this.mFormat === ImageFormat.Jpeg) {
        var tempArrayBuffer = this.imageData.internalBuffer.length;
        this.imageStream = new PdfStream();
        this.imageStream.isImage = true;
        var tempString = "";
        var decodedString = "";
        for (var i = 0; i < this.imageDataAsNumberArray.byteLength; i++) {
          tempString += String.fromCharCode(null, this.mStream.readByte(i));
        }
        for (var i = 0; i < tempString.length; i++) {
          if (i % 2 !== 0) {
            decodedString += tempString[i];
          }
        }
        this.imageStream.data = [decodedString];
        this.imageStream.compress = false;
        this.imageStream.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.xObject));
        this.imageStream.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.image));
        this.imageStream.items.setValue(this.dictionaryProperties.width, new PdfNumber(this.width));
        this.imageStream.items.setValue(this.dictionaryProperties.height, new PdfNumber(this.height));
        this.imageStream.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));
        this.imageStream.items.setValue(this.dictionaryProperties.filter, new PdfName(this.dictionaryProperties.dctdecode));
        this.imageStream.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(this.getColorSpace()));
        this.imageStream.items.setValue(this.dictionaryProperties.decodeParms, this.getDecodeParams());
        return this.imageStream;
      } else {
        return this.imageStream;
      }
    };
    ImageDecoder2.prototype.getColorSpace = function() {
      return this.dictionaryProperties.deviceRgb;
    };
    ImageDecoder2.prototype.getDecodeParams = function() {
      var decodeParams = new PdfDictionary();
      decodeParams.items.setValue(this.dictionaryProperties.columns, new PdfNumber(this.width));
      decodeParams.items.setValue(this.dictionaryProperties.blackIs1, new PdfBoolean(true));
      decodeParams.items.setValue(this.dictionaryProperties.k, new PdfNumber(-1));
      decodeParams.items.setValue(this.dictionaryProperties.predictor, new PdfNumber(15));
      decodeParams.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));
      return decodeParams;
    };
    ImageDecoder2.prototype.readExceededJPGImage = function(stream) {
      this.mStream = stream;
      var isContinueReading = true;
      while (isContinueReading) {
        var marker = this.getMarker(stream);
        switch (marker) {
          case this.sof1Marker:
          case this.sof2Marker:
          case this.sof3Marker:
          case this.sof5Marker:
          case this.sof6Marker:
          case this.sof7Marker:
          case this.sof9Marker:
          case this.sof10Marker:
          case this.sof11Marker:
          case this.sof13Marker:
          case this.sof14Marker:
          case this.sof15Marker:
            stream.position += 3;
            this.mHeight = this.mStream.readNextTwoBytes(stream);
            this.mWidth = this.mStream.readNextTwoBytes(stream);
            isContinueReading = false;
            break;
          default:
            this.skipStream(stream);
            break;
        }
      }
    };
    ImageDecoder2.prototype.skip = function(stream, noOfBytes) {
      this.mStream = stream;
      var temp = new ByteArray(noOfBytes);
      this.mStream.read(temp, 0, temp.count);
    };
    ImageDecoder2.prototype.getMarker = function(stream) {
      var skippedByte = 0;
      var marker = 32;
      marker = stream.readByte(this.mStream.position);
      stream.position++;
      while (marker !== 255) {
        skippedByte++;
        marker = stream.readByte(this.mStream.position);
        stream.position++;
      }
      do {
        marker = stream.readByte(this.mStream.position);
        stream.position++;
      } while (marker === 255);
      return marker;
    };
    ImageDecoder2.prototype.skipStream = function(stream) {
      var markerLength = this.mStream.readNextTwoBytes(stream) - 2;
      if (markerLength > 0) {
        stream.position += markerLength;
      }
    };
    ImageDecoder2.mPngHeader = [137, 80, 78, 71, 13, 10, 26, 10];
    ImageDecoder2.mJpegHeader = [255, 216];
    ImageDecoder2.GIF_HEADER = "G,I,F,8";
    ImageDecoder2.BMP_HEADER = "B,M";
    return ImageDecoder2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/unit-convertor.js
var PdfUnitConverter = (
  /** @class */
  function() {
    function PdfUnitConverter2(dpi) {
      this.updateProportionsHelper(dpi);
    }
    PdfUnitConverter2.prototype.convertUnits = function(value, from, to) {
      return this.convertFromPixels(this.convertToPixels(value, from), to);
    };
    PdfUnitConverter2.prototype.convertToPixels = function(value, from) {
      var index = from;
      var result = value * this.proportions[index];
      return result;
    };
    PdfUnitConverter2.prototype.convertFromPixels = function(value, to) {
      var index = to;
      var result = value / this.proportions[index];
      return result;
    };
    PdfUnitConverter2.prototype.updateProportionsHelper = function(pixelPerInch) {
      this.proportions = [
        pixelPerInch / 2.54,
        pixelPerInch / 6,
        1,
        pixelPerInch / 72,
        pixelPerInch,
        pixelPerInch / 300,
        pixelPerInch / 25.4
        // Millimeter
      ];
    };
    PdfUnitConverter2.horizontalResolution = 96;
    PdfUnitConverter2.verticalResolution = 96;
    return PdfUnitConverter2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/pdf-image.js
var PdfImage = (
  /** @class */
  function() {
    function PdfImage2() {
    }
    Object.defineProperty(PdfImage2.prototype, "width", {
      /**
       * Gets and Sets the `width` of an image.
       * @private
       */
      get: function() {
        return this.imageWidth;
      },
      set: function(value) {
        this.imageWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "height", {
      /**
       * Gets and Sets the `height` of an image.
       * @private
       */
      get: function() {
        return this.imageHeight;
      },
      set: function(value) {
        this.imageHeight = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "size", {
      /**
       * Gets or sets the size of the image.
       * @private
       */
      set: function(value) {
        this.width = value.width;
        this.height = value.height;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "physicalDimension", {
      /**
       * Gets the `physical dimension` of an image.
       * @private
       */
      get: function() {
        this.imagePhysicalDimension = this.getPointSize(this.width, this.height, this.horizontalResolution, this.verticalResolution);
        return new SizeF(this.width, this.height);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "element", {
      // /**
      //  * Gets the `image stream as string`.
      //  * @private
      //  */
      // public static fromString(string : string) : PdfImage {
      //     let image : PdfImage = new PdfBitmap(string);
      //     return image;
      // }
      /**
       * Gets the `element` image stream.
       * @private
       */
      get: function() {
        return this.imageStream;
      },
      enumerable: true,
      configurable: true
    });
    PdfImage2.prototype.getPointSize = function(width, height, horizontalResolution, verticalResolution) {
      if (typeof horizontalResolution === "undefined") {
        var dpiX = PdfUnitConverter.horizontalResolution;
        var dpiY = PdfUnitConverter.verticalResolution;
        var size = this.getPointSize(width, height, dpiX, dpiY);
        return size;
      } else {
        var ucX = new PdfUnitConverter(horizontalResolution);
        var ucY = new PdfUnitConverter(verticalResolution);
        var ptWidth = ucX.convertUnits(width, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);
        var ptHeight = ucY.convertUnits(height, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);
        var size = new SizeF(ptWidth, ptHeight);
        return size;
      }
    };
    return PdfImage2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/pdf-bitmap.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfBitmap = (
  /** @class */
  function(_super) {
    __extends3(PdfBitmap2, _super);
    function PdfBitmap2(encodedString) {
      var _this = _super.call(this) || this;
      _this.imageStatus = true;
      _this.dictionaryProperties = new DictionaryProperties();
      _this.loadImage(encodedString);
      return _this;
    }
    PdfBitmap2.prototype.loadImage = function(encodedString) {
      var task = this.initializeAsync(encodedString);
    };
    PdfBitmap2.prototype.initializeAsync = function(encodedString) {
      var byteArray = new ByteArray(encodedString.length);
      byteArray.writeFromBase64String(encodedString);
      this.decoder = new ImageDecoder(byteArray);
      this.height = this.decoder.height;
      this.width = this.decoder.width;
      this.bitsPerComponent = this.decoder.bitsPerComponent;
    };
    PdfBitmap2.prototype.save = function() {
      this.imageStatus = true;
      this.imageStream = this.decoder.getImageDictionary();
    };
    return PdfBitmap2;
  }(PdfImage)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-writer.js
var PdfWriter = (
  /** @class */
  function() {
    function PdfWriter2(stream) {
      this.streamWriter = stream;
    }
    Object.defineProperty(PdfWriter2.prototype, "document", {
      //properties
      /**
       * Gets and Sets the `document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      set: function(value) {
        this.pdfDocument = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfWriter2.prototype, "position", {
      /**
       * Gets the `position`.
       * @private
       */
      get: function() {
        return this.streamWriter.buffer.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfWriter2.prototype, "length", {
      /**
       * Gets  the `length` of the stream'.
       * @private
       */
      get: function() {
        return this.streamWriter.buffer.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfWriter2.prototype, "stream", {
      /**
       * Gets the `stream`.
       * @private
       */
      get: function() {
        var result = this.streamWriter;
        return result;
      },
      enumerable: true,
      configurable: true
    });
    PdfWriter2.prototype.write = function(overload) {
      var data = [];
      var tempOverload = overload;
      this.streamWriter.write(tempOverload);
    };
    return PdfWriter2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/enum.js
var ObjectStatus;
(function(ObjectStatus2) {
  ObjectStatus2[ObjectStatus2["None"] = 0] = "None";
  ObjectStatus2[ObjectStatus2["Registered"] = 1] = "Registered";
})(ObjectStatus || (ObjectStatus = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-main-object-collection.js
var PdfMainObjectCollection = (
  /** @class */
  function() {
    function PdfMainObjectCollection2() {
      this.objectCollections = [];
      this.mainObjectCollection = new Dictionary();
      this.primitiveObjectCollection = new Dictionary();
    }
    Object.defineProperty(PdfMainObjectCollection2.prototype, "count", {
      //Properties
      /**
       * Gets the `count`.
       * @private
       */
      get: function() {
        return this.objectCollections.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfMainObjectCollection2.prototype.items = function(index) {
      return this.objectCollections[index];
    };
    Object.defineProperty(PdfMainObjectCollection2.prototype, "outIsNew", {
      //Methods
      /**
       * Specifies the value of `IsNew`.
       * @private
       */
      get: function() {
        return this.isNew;
      },
      enumerable: true,
      configurable: true
    });
    PdfMainObjectCollection2.prototype.add = function(element) {
      var objInfo = new ObjectInfo(element);
      this.objectCollections.push(objInfo);
      if (!this.primitiveObjectCollection.containsKey(element)) {
        this.primitiveObjectCollection.setValue(element, this.objectCollections.length - 1);
      }
      element.position = this.index = this.objectCollections.length - 1;
      element.status = ObjectStatus.Registered;
    };
    PdfMainObjectCollection2.prototype.lookFor = function(obj) {
      var index = -1;
      if (obj.position !== -1) {
        return obj.position;
      }
      if (this.primitiveObjectCollection.containsKey(obj) && this.count === this.primitiveObjectCollection.size()) {
        index = this.primitiveObjectCollection.getValue(obj);
      } else {
        for (var i = this.count - 1; i >= 0; i--) {
          var oi = this.objectCollections[i];
          if (oi.object === obj) {
            index = i;
            break;
          }
        }
      }
      return index;
    };
    PdfMainObjectCollection2.prototype.getReference = function(index, isNew) {
      this.index = this.lookFor(index);
      var reference;
      this.isNew = false;
      var oi = this.objectCollections[this.index];
      reference = oi.reference;
      var obj = { reference, wasNew: isNew };
      return obj;
    };
    PdfMainObjectCollection2.prototype.trySetReference = function(obj, reference, found) {
      var result = true;
      found = true;
      this.index = this.lookFor(obj);
      var oi = this.objectCollections[this.index];
      oi.setReference(reference);
      return result;
    };
    PdfMainObjectCollection2.prototype.destroy = function() {
      for (var _i = 0, _a = this.objectCollections; _i < _a.length; _i++) {
        var obj = _a[_i];
        if (obj !== void 0) {
          obj.pdfObject.position = -1;
          obj.pdfObject.isSaving = void 0;
          obj.pdfObject.objectCollectionIndex = void 0;
          obj.pdfObject.position = void 0;
        }
      }
      this.objectCollections = [];
      this.mainObjectCollection = new Dictionary();
      this.primitiveObjectCollection = new Dictionary();
    };
    return PdfMainObjectCollection2;
  }()
);
var ObjectInfo = (
  /** @class */
  function() {
    function ObjectInfo2(obj, reference) {
      this.pdfObject = obj;
      this.pdfReference = reference;
    }
    Object.defineProperty(ObjectInfo2.prototype, "object", {
      //Properties
      /**
       * Gets the `object`.
       * @private
       */
      get: function() {
        return this.pdfObject;
      },
      set: function(value) {
        this.pdfObject = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ObjectInfo2.prototype, "reference", {
      /**
       * Gets the `reference`.
       * @private
       */
      get: function() {
        return this.pdfReference;
      },
      enumerable: true,
      configurable: true
    });
    ObjectInfo2.prototype.setReference = function(reference) {
      this.pdfReference = reference;
    };
    return ObjectInfo2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-document-base.js
var PdfDocumentBase = (
  /** @class */
  function() {
    function PdfDocumentBase2(document2) {
      this.isStreamCopied = false;
      if (document2 instanceof PdfDocument) {
        this.document = document2;
      }
    }
    Object.defineProperty(PdfDocumentBase2.prototype, "pdfObjects", {
      //Prpperties
      /**
       * Gets the `PDF objects` collection, which stores all objects and references to it..
       * @private
       */
      get: function() {
        return this.objects;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "crossTable", {
      /**
       * Gets the `cross-reference` table.
       * @private
       */
      get: function() {
        return this.pdfCrossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "currentSavingObj", {
      /**
       * Gets or sets the current saving `object number`.
       * @private
       */
      get: function() {
        return this.currentSavingObject;
      },
      set: function(value) {
        this.currentSavingObject = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "catalog", {
      /**
       * Gets the PDF document `catalog`.
       * @private
       */
      get: function() {
        return this.pdfCatalog;
      },
      set: function(value) {
        this.pdfCatalog = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentBase2.prototype.setMainObjectCollection = function(mainObjectCollection) {
      this.objects = mainObjectCollection;
    };
    PdfDocumentBase2.prototype.setCrossTable = function(cTable) {
      this.pdfCrossTable = cTable;
    };
    PdfDocumentBase2.prototype.setCatalog = function(catalog) {
      this.pdfCatalog = catalog;
    };
    PdfDocumentBase2.prototype.save = function(filename) {
      var _this = this;
      var encoding = new Encoding(true);
      var SW = new StreamWriter(encoding);
      if (typeof filename === "undefined") {
        var encoding_1 = new Encoding(true);
        var SW_1 = new StreamWriter(encoding_1);
        return new Promise(function(resolve, reject) {
          var obj = {};
          obj.blobData = new Blob([_this.document.docSave(SW_1, true)], { type: "application/pdf" });
          resolve(obj);
        });
      } else {
        this.document.docSave(SW, filename, true);
      }
    };
    PdfDocumentBase2.prototype.clone = function() {
      return this.document;
    };
    return PdfDocumentBase2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/cross-table.js
var ObjectType;
(function(ObjectType2) {
  ObjectType2[ObjectType2["Free"] = 0] = "Free";
  ObjectType2[ObjectType2["Normal"] = 1] = "Normal";
  ObjectType2[ObjectType2["Packed"] = 2] = "Packed";
})(ObjectType || (ObjectType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-catalog.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfCatalog = (
  /** @class */
  function(_super) {
    __extends4(PdfCatalog2, _super);
    function PdfCatalog2() {
      var _this = _super.call(this) || this;
      _this.sections = null;
      _this.tempDictionaryProperties = new DictionaryProperties();
      _this.items.setValue(new DictionaryProperties().type, new PdfName("Catalog"));
      return _this;
    }
    Object.defineProperty(PdfCatalog2.prototype, "pages", {
      //Properties
      /**
       * Gets or sets the sections, which contain `pages`.
       * @private
       */
      get: function() {
        return this.sections;
      },
      set: function(value) {
        var dictionary = value.element;
        this.sections = value;
        this.items.setValue(this.tempDictionaryProperties.pages, new PdfReferenceHolder(value));
      },
      enumerable: true,
      configurable: true
    });
    return PdfCatalog2;
  }(PdfDictionary)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-cross-table.js
var PdfCrossTable = (
  /** @class */
  function() {
    function PdfCrossTable2() {
      this.objects = new Dictionary();
      this.maxGenNumIndex = 0;
      this.objectCount = 0;
      this.dictionaryProperties = new DictionaryProperties();
    }
    Object.defineProperty(PdfCrossTable2.prototype, "isMerging", {
      //Properties
      /**
       * Gets or sets if the document `is merged`.
       * @private
       */
      get: function() {
        return this.merging;
      },
      set: function(value) {
        this.merging = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "trailer", {
      /**
       * Gets the `trailer`.
       * @private
       */
      get: function() {
        if (this.internalTrailer == null) {
          this.internalTrailer = new PdfStream();
        }
        return this.internalTrailer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "document", {
      /**
       * Gets or sets the main `PdfDocument` class instance.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      set: function(value) {
        this.pdfDocument = value;
        this.items = this.pdfDocument.pdfObjects;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "pdfObjects", {
      /**
       * Gets the catched `PDF object` main collection.
       * @private
       */
      get: function() {
        return this.items;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "objectCollection", {
      /**
       * Gets the `object collection`.
       * @private
       */
      get: function() {
        return this.pdfDocument.pdfObjects;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "count", {
      /**
       * Gets or sets the `number of the objects` within the document.
       * @private
       */
      get: function() {
        return this.objectCount;
      },
      set: function(value) {
        this.objectCount = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "nextObjNumber", {
      /**
       * Returns `next available object number`.
       * @private
       */
      get: function() {
        this.count = this.count + 1;
        return this.count;
      },
      enumerable: true,
      configurable: true
    });
    PdfCrossTable2.prototype.save = function(writer, filename) {
      this.saveHead(writer);
      var state = false;
      this.mappedReferences = null;
      this.objects.clear();
      this.markTrailerReferences();
      this.saveObjects(writer);
      var saveCount = this.count;
      var xrefPos = writer.position;
      this.registerObject(0, new PdfReference(0, -1), true);
      var prevXRef = 0;
      writer.write(Operators.xref);
      writer.write(Operators.newLine);
      this.saveSections(writer);
      this.saveTrailer(writer, this.count, prevXRef);
      this.saveTheEndess(writer, xrefPos);
      this.count = saveCount;
      for (var i = 0; i < this.objectCollection.count; ++i) {
        var oi = this.objectCollection.items(i);
        oi.object.isSaving = false;
      }
      if (typeof filename === "undefined") {
        return writer.stream.buffer;
      } else {
        writer.stream.save(filename);
      }
    };
    PdfCrossTable2.prototype.saveTheEndess = function(writer, xrefPos) {
      writer.write(Operators.newLine + Operators.startxref + Operators.newLine);
      writer.write(xrefPos.toString() + Operators.newLine);
      writer.write(Operators.eof + Operators.newLine);
    };
    PdfCrossTable2.prototype.saveTrailer = function(writer, count, prevXRef) {
      writer.write(Operators.trailer + Operators.newLine);
      var trailer = this.trailer;
      trailer.items.setValue(this.dictionaryProperties.size, new PdfNumber(this.objectCount + 1));
      trailer = new PdfDictionary(trailer);
      trailer.setEncrypt(false);
      trailer.save(writer);
    };
    PdfCrossTable2.prototype.saveSections = function(writer) {
      var objectNum = 0;
      var count = 0;
      do {
        count = this.prepareSubsection(objectNum);
        this.saveSubsection(writer, objectNum, count);
        objectNum += count;
      } while (count !== 0);
    };
    PdfCrossTable2.prototype.saveSubsection = function(writer, objectNum, count) {
      if (count <= 0 || objectNum >= this.count) {
        return;
      }
      var subsectionHead = "{0} {1}{2}";
      writer.write(objectNum + " " + (count + 1) + Operators.newLine);
      for (var i = objectNum; i <= objectNum + count; ++i) {
        var obj = this.objects.getValue(i);
        var str = "";
        if (obj.type === ObjectType.Free) {
          str = this.getItem(obj.offset, 65535, true);
        } else {
          str = this.getItem(obj.offset, obj.generation, false);
        }
        writer.write(str);
      }
    };
    PdfCrossTable2.prototype.getItem = function(offset, genNumber, isFree) {
      var returnString = "";
      var addOffsetLength = 10 - offset.toString().length;
      if (genNumber <= 0) {
        genNumber = 0;
      }
      var addGenNumberLength = 5 - genNumber.toString().length <= 0 ? 0 : 5 - genNumber.toString().length;
      for (var index = 0; index < addOffsetLength; index++) {
        returnString = returnString + "0";
      }
      returnString = returnString + offset.toString() + " ";
      for (var index = 0; index < addGenNumberLength; index++) {
        returnString = returnString + "0";
      }
      returnString = returnString + genNumber.toString() + " ";
      returnString = returnString + (isFree ? Operators.f : Operators.n) + Operators.newLine;
      return returnString;
    };
    PdfCrossTable2.prototype.prepareSubsection = function(objectNum) {
      var count = 0;
      var i;
      var total = this.count;
      for (var k = 0; k < this.document.pdfObjects.count; k++) {
        var reference = this.document.pdfObjects.items(k).reference;
        var refString = reference.toString();
        var refArray = refString.split(" ");
      }
      if (objectNum >= total) {
        return count;
      }
      for (i = objectNum; i < total; ++i) {
        break;
      }
      objectNum = i;
      for (; i < total; ++i) {
        ++count;
      }
      return count;
    };
    PdfCrossTable2.prototype.markTrailerReferences = function() {
      var tempArray;
      var keys = this.trailer.items.keys();
      var values = this.trailer.items.values();
    };
    PdfCrossTable2.prototype.saveHead = function(writer) {
      var version = this.generateFileVersion(writer.document);
      writer.write("%PDF-" + version);
      writer.write(Operators.newLine);
    };
    PdfCrossTable2.prototype.generateFileVersion = function(document2) {
      var iVersion = 4;
      var version = "1." + iVersion.toString();
      return version;
    };
    PdfCrossTable2.prototype.getReference = function(obj, bNew) {
      if (typeof bNew === "undefined") {
        var wasNew = false;
        return this.getReference(obj, wasNew);
      } else {
        return this.getSubReference(obj, bNew);
      }
    };
    PdfCrossTable2.prototype.getSubReference = function(obj, bNew) {
      var isNew = false;
      var wasNew;
      var reference = null;
      if (this.items.count > 0 && obj.objectCollectionIndex > 0 && this.items.count > obj.objectCollectionIndex - 1) {
        var tempObj = this.document.pdfObjects.getReference(obj, wasNew);
        reference = tempObj.reference;
        wasNew = tempObj.wasNew;
      }
      if (reference == null) {
        if (obj.status === ObjectStatus.Registered) {
          wasNew = false;
        } else {
          wasNew = true;
        }
      } else {
        wasNew = false;
      }
      if (reference == null) {
        var objnumber = this.nextObjNumber;
        reference = new PdfReference(objnumber, 0);
        var found = void 0;
        if (wasNew) {
          this.document.pdfObjects.add(obj);
          this.document.pdfObjects.trySetReference(obj, reference, found);
          var tempIndex = this.document.pdfObjects.count - 1;
          var tempkey = this.document.pdfObjects.objectCollections[tempIndex].reference.objNumber;
          var tempvalue = this.document.pdfObjects.objectCollections[this.document.pdfObjects.count - 1];
          this.document.pdfObjects.mainObjectCollection.setValue(tempkey, tempvalue);
          obj.position = -1;
        } else {
          this.document.pdfObjects.trySetReference(obj, reference, found);
        }
        obj.objectCollectionIndex = reference.objNumber;
        obj.status = ObjectStatus.None;
        isNew = true;
      }
      bNew = isNew || this.bForceNew;
      return reference;
    };
    PdfCrossTable2.prototype.saveObjects = function(writer) {
      var objectCollection = this.objectCollection;
      for (var i = 0; i < objectCollection.count; ++i) {
        var oi = objectCollection.items(i);
        var obj = oi.object;
        obj.isSaving = true;
        this.saveIndirectObject(obj, writer);
      }
    };
    PdfCrossTable2.prototype.saveIndirectObject = function(obj, writer) {
      var reference = this.getReference(obj);
      if (obj instanceof PdfCatalog) {
        this.trailer.items.setValue(this.dictionaryProperties.root, reference);
      }
      this.pdfDocument.currentSavingObj = reference;
      var tempArchive = false;
      tempArchive = obj.getArchive();
      var allowedType = !(obj instanceof PdfStream || !tempArchive || obj instanceof PdfCatalog);
      var sigFlag = false;
      this.registerObject(writer.position, reference);
      this.doSaveObject(obj, reference, writer);
    };
    PdfCrossTable2.prototype.doSaveObject = function(obj, reference, writer) {
      var correctPosition = writer.length;
      writer.write(reference.objNumber.toString());
      writer.write(Operators.whiteSpace);
      writer.write(reference.genNumber.toString());
      writer.write(Operators.whiteSpace);
      writer.write(Operators.obj);
      writer.write(Operators.newLine);
      obj.save(writer);
      var stream = writer.stream;
      writer.write(Operators.endObj);
      writer.write(Operators.newLine);
    };
    PdfCrossTable2.prototype.registerObject = function(offset, reference, free) {
      if (typeof free === "boolean") {
        this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference, free));
        this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);
      } else if (typeof free === "undefined") {
        this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference));
        this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);
      }
    };
    PdfCrossTable2.dereference = function(obj) {
      var rh = obj;
      if (rh != null) {
        obj = rh.object;
      }
      return obj;
    };
    return PdfCrossTable2;
  }()
);
var RegisteredObject = (
  /** @class */
  function() {
    function RegisteredObject2(offset, reference, free) {
      var tempOffset = offset;
      this.offsetNumber = tempOffset;
      var tempReference = reference;
      this.generation = tempReference.genNumber;
      this.object = tempReference.objNumber;
      if (typeof free === "undefined") {
        this.type = ObjectType.Normal;
      } else {
        this.type = ObjectType.Free;
      }
    }
    Object.defineProperty(RegisteredObject2.prototype, "objectNumber", {
      //Properties
      /**
       * Gets the `object number`.
       * @private
       */
      get: function() {
        return this.object;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RegisteredObject2.prototype, "offset", {
      /**
       * Gets the `offset`.
       * @private
       */
      get: function() {
        var result;
        result = this.offsetNumber;
        return result;
      },
      enumerable: true,
      configurable: true
    });
    return RegisteredObject2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-stream-writer.js
var PdfStreamWriter = (
  /** @class */
  function() {
    function PdfStreamWriter2(stream) {
      if (stream == null) {
        throw new Error("ArgumentNullException:stream");
      }
      this.stream = stream;
    }
    PdfStreamWriter2.prototype.clear = function() {
      this.stream.clearStream();
    };
    PdfStreamWriter2.prototype.setGraphicsState = function(dictionaryName) {
      if (dictionaryName instanceof PdfName) {
        this.stream.write(dictionaryName.toString());
        this.stream.write(Operators.whiteSpace);
        this.writeOperator(Operators.setGraphicsState);
      } else {
        this.stream.write(Operators.slash);
        this.stream.write(dictionaryName);
        this.stream.write(Operators.whiteSpace);
        this.writeOperator(Operators.setGraphicsState);
      }
    };
    PdfStreamWriter2.prototype.executeObject = function(name) {
      this.stream.write(name.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.paintXObject);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.closePath = function() {
      this.writeOperator(Operators.closePath);
    };
    PdfStreamWriter2.prototype.clipPath = function(useEvenOddRule) {
      this.stream.write(Operators.clipPath);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
      }
      this.stream.write(Operators.whiteSpace);
      this.stream.write(Operators.endPath);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.closeFillStrokePath = function(useEvenOddRule) {
      this.stream.write(Operators.closeFillStrokePath);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.fillStrokePath = function(useEvenOddRule) {
      this.stream.write(Operators.fillStroke);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.fillPath = function(useEvenOddRule) {
      this.stream.write(Operators.fill);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.endPath = function() {
      this.writeOperator(Operators.n);
    };
    PdfStreamWriter2.prototype.closeFillPath = function(useEvenOddRule) {
      this.writeOperator(Operators.closePath);
      this.stream.write(Operators.fill);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.closeStrokePath = function() {
      this.writeOperator(Operators.closeStrokePath);
    };
    PdfStreamWriter2.prototype.setTextScaling = function(textScaling) {
      this.stream.write(PdfNumber.floatToString(textScaling));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setTextScaling);
    };
    PdfStreamWriter2.prototype.strokePath = function() {
      this.writeOperator(Operators.stroke);
    };
    PdfStreamWriter2.prototype.restoreGraphicsState = function() {
      this.writeOperator(Operators.restoreState);
    };
    PdfStreamWriter2.prototype.saveGraphicsState = function() {
      this.writeOperator(Operators.saveState);
    };
    PdfStreamWriter2.prototype.startNextLine = function(arg1, arg2) {
      if (typeof arg1 === "undefined") {
        this.writeOperator(Operators.goToNextLine);
      } else if (arg1 instanceof PointF) {
        this.writePoint(arg1);
        this.writeOperator(Operators.setCoords);
      } else {
        this.writePoint(arg1, arg2);
        this.writeOperator(Operators.setCoords);
      }
    };
    PdfStreamWriter2.prototype.showText = function(text) {
      this.checkTextParam(text);
      this.writeText(text);
      this.writeOperator(Operators.setText);
    };
    PdfStreamWriter2.prototype.setLeading = function(leading) {
      this.stream.write(PdfNumber.floatToString(leading));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setTextLeading);
    };
    PdfStreamWriter2.prototype.beginPath = function(x, y) {
      this.writePoint(x, y);
      this.writeOperator(Operators.beginPath);
    };
    PdfStreamWriter2.prototype.beginText = function() {
      this.writeOperator(Operators.beginText);
    };
    PdfStreamWriter2.prototype.endText = function() {
      this.writeOperator(Operators.endText);
    };
    PdfStreamWriter2.prototype.appendRectangle = function(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof RectangleF) {
        this.appendRectangle(arg1.x, arg1.y, arg1.width, arg1.height);
      } else {
        this.writePoint(arg1, arg2);
        this.writePoint(arg3, arg4);
        this.writeOperator(Operators.appendRectangle);
      }
    };
    PdfStreamWriter2.prototype.appendLineSegment = function(arg1, arg2) {
      if (arg1 instanceof PointF) {
        this.appendLineSegment(arg1.x, arg1.y);
      } else {
        this.writePoint(arg1, arg2);
        this.writeOperator(Operators.appendLineSegment);
      }
    };
    PdfStreamWriter2.prototype.setTextRenderingMode = function(renderingMode) {
      this.stream.write(renderingMode.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setRenderingMode);
    };
    PdfStreamWriter2.prototype.setCharacterSpacing = function(charSpacing) {
      this.stream.write(PdfNumber.floatToString(charSpacing));
      this.stream.write(Operators.whiteSpace);
      this.stream.write(Operators.setCharacterSpace);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.setWordSpacing = function(wordSpacing) {
      this.stream.write(PdfNumber.floatToString(wordSpacing));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setWordSpace);
    };
    PdfStreamWriter2.prototype.showNextLineText = function(arg1, arg2) {
      if (arg1 instanceof PdfString) {
        this.checkTextParam(arg1);
        this.writeText(arg1);
        this.writeOperator(Operators.setTextOnNewLine);
      } else {
        this.checkTextParam(arg1);
        this.writeText(arg1, arg2);
        this.writeOperator(Operators.setTextOnNewLine);
      }
    };
    PdfStreamWriter2.prototype.setColorSpace = function(arg1, arg2) {
      if (arg1 instanceof PdfName && typeof arg2 === "boolean") {
        var temparg1 = arg1;
        var temparg2 = arg2;
        var op = temparg2 ? Operators.selectcolorspaceforstroking : Operators.selectcolorspacefornonstroking;
        this.stream.write(temparg1.toString());
        this.stream.write(Operators.whiteSpace);
        this.stream.write(op);
        this.stream.write(Operators.newLine);
      } else {
        var temparg1 = arg1;
        var temparg2 = arg2;
        this.setColorSpace(new PdfName(temparg1), temparg2);
      }
    };
    PdfStreamWriter2.prototype.modifyCtm = function(matrix) {
      if (matrix == null) {
        throw new Error("ArgumentNullException:matrix");
      }
      this.stream.write(matrix.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.modifyCtm);
    };
    PdfStreamWriter2.prototype.setFont = function(font, name, size) {
      if (typeof name === "string") {
        this.setFont(font, new PdfName(name), size);
      } else {
        if (font == null) {
          throw new Error("ArgumentNullException:font");
        }
        this.stream.write(name.toString());
        this.stream.write(Operators.whiteSpace);
        this.stream.write(PdfNumber.floatToString(size));
        this.stream.write(Operators.whiteSpace);
        this.writeOperator(Operators.setFont);
      }
    };
    PdfStreamWriter2.prototype.writeOperator = function(opcode) {
      this.stream.write(opcode);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.checkTextParam = function(text) {
      if (text == null) {
        throw new Error("ArgumentNullException:text");
      }
      if (typeof text === "string" && text === "") {
        throw new Error("ArgumentException:The text can not be an empty string, text");
      }
    };
    PdfStreamWriter2.prototype.writeText = function(arg1, arg2) {
      if (arg1 instanceof PdfString && typeof arg2 === "undefined") {
        this.stream.write(arg1.pdfEncode());
      } else {
        var start = void 0;
        var end = void 0;
        if (arg2) {
          start = PdfString.hexStringMark[0];
          end = PdfString.hexStringMark[1];
        } else {
          start = PdfString.stringMark[0];
          end = PdfString.stringMark[1];
        }
        this.stream.write(start);
        this.stream.write(arg1);
        this.stream.write(end);
      }
    };
    PdfStreamWriter2.prototype.writePoint = function(arg1, arg2) {
      if (arg1 instanceof PointF && typeof arg2 === "undefined") {
        this.writePoint(arg1.x, arg1.y);
      } else {
        var temparg1 = arg1;
        this.stream.write(PdfNumber.floatToString(temparg1));
        this.stream.write(Operators.whiteSpace);
        arg2 = this.updateY(arg2);
        this.stream.write(PdfNumber.floatToString(arg2));
        this.stream.write(Operators.whiteSpace);
      }
    };
    PdfStreamWriter2.prototype.updateY = function(arg) {
      return -arg;
    };
    PdfStreamWriter2.prototype.write = function(string) {
      var builder = "";
      builder += string;
      builder += Operators.newLine;
      this.writeOperator(builder);
    };
    PdfStreamWriter2.prototype.writeComment = function(comment) {
      if (comment != null && comment.length > 0) {
        var builder = "";
        builder += Operators.comment;
        builder += Operators.whiteSpace;
        builder += comment;
        this.writeOperator(builder);
      } else {
        throw new Error("Invalid comment");
      }
    };
    PdfStreamWriter2.prototype.setColorAndSpace = function(color, colorSpace, forStroking) {
      if (!color.isEmpty) {
        this.stream.write(color.toString(colorSpace, forStroking));
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.setLineDashPattern = function(pattern, patternOffset) {
      this.setLineDashPatternHelper(pattern, patternOffset);
    };
    PdfStreamWriter2.prototype.setLineDashPatternHelper = function(pattern, patternOffset) {
      var tempPattern = "[";
      if (pattern.length > 1) {
        for (var index = 0; index < pattern.length; index++) {
          if (index === pattern.length - 1) {
            tempPattern += pattern[index].toString();
          } else {
            tempPattern += pattern[index].toString() + " ";
          }
        }
      }
      tempPattern += "] ";
      tempPattern += patternOffset.toString();
      tempPattern += " " + Operators.setDashPattern;
      this.stream.write(tempPattern);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.setMiterLimit = function(miterLimit) {
      this.stream.write(PdfNumber.floatToString(miterLimit));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setMiterLimit);
    };
    PdfStreamWriter2.prototype.setLineWidth = function(width) {
      this.stream.write(PdfNumber.floatToString(width));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setLineWidth);
    };
    PdfStreamWriter2.prototype.setLineCap = function(lineCapStyle) {
      this.stream.write(lineCapStyle.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setLineCapStyle);
    };
    PdfStreamWriter2.prototype.setLineJoin = function(lineJoinStyle) {
      this.stream.write(lineJoinStyle.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setLineJoinStyle);
    };
    Object.defineProperty(PdfStreamWriter2.prototype, "position", {
      //IPdfWriter members
      /**
       * Gets or sets the current `position` within the stream.
       * @private
       */
      get: function() {
        return this.stream.position;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStreamWriter2.prototype, "length", {
      /**
       * Gets `stream length`.
       * @private
       */
      get: function() {
        var returnValue = 0;
        if (this.stream.data.length !== 0 && this.stream.data.length !== -1) {
          for (var index = 0; index < this.stream.data.length; index++) {
            returnValue += this.stream.data[index].length;
          }
        }
        return returnValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStreamWriter2.prototype, "document", {
      /**
       * Gets and Sets the `current document`.
       * @private
       */
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    PdfStreamWriter2.prototype.appendBezierSegment = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF) {
        this.writePoint(arg1.x, arg1.y);
        this.writePoint(arg2.x, arg2.y);
        this.writePoint(arg3.x, arg3.y);
      } else {
        this.writePoint(arg1, arg2);
        this.writePoint(arg3, arg4);
        this.writePoint(arg5, arg6);
      }
      this.writeOperator(Operators.appendbeziercurve);
    };
    PdfStreamWriter2.prototype.setColourWithPattern = function(colours, patternName, forStroking) {
      if (colours != null) {
        var count = colours.length;
        var i = 0;
        for (i = 0; i < count; ++i) {
          this.stream.write(colours[i].toString());
          this.stream.write(Operators.whiteSpace);
        }
      }
      if (patternName != null) {
        this.stream.write(patternName.toString());
        this.stream.write(Operators.whiteSpace);
      }
      if (forStroking) {
        this.writeOperator(Operators.setColorAndPatternStroking);
      } else {
        this.writeOperator(Operators.setColorAndPattern);
      }
    };
    return PdfStreamWriter2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/string-tokenizer.js
var StringTokenizer = (
  /** @class */
  function() {
    function StringTokenizer2(textValue) {
      this.currentPosition = 0;
      if (textValue == null) {
        throw new Error("ArgumentNullException:text");
      }
      this.text = textValue;
    }
    Object.defineProperty(StringTokenizer2.prototype, "length", {
      // Properties
      /**
       * Gets text `length`.
       * @private
       */
      get: function() {
        return this.text.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StringTokenizer2.prototype, "end", {
      get: function() {
        return this.currentPosition === this.text.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StringTokenizer2.prototype, "position", {
      /**
       * Gets or sets the position.
       * @private
       */
      get: function() {
        return this.currentPosition;
      },
      set: function(value) {
        this.currentPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    StringTokenizer2.getCharsCount = function(text, symbols) {
      if (typeof symbols === "string") {
        if (text == null) {
          throw new Error("ArgumentNullException:wholeText");
        }
        var numSymbols = 0;
        var curIndex = 0;
        for (; ; ) {
          curIndex = text.indexOf(symbols, curIndex);
          if (curIndex === -1) {
            break;
          } else {
            numSymbols++;
            curIndex++;
          }
        }
        return numSymbols;
      } else {
        if (text == null) {
          throw new Error("ArgumentNullException:text");
        }
        if (symbols == null) {
          throw new Error("ArgumentNullException:symbols");
        }
        var count = 0;
        for (var i = 0, len = text.length; i < len; i++) {
          var ch = text[i];
          if (this.contains(symbols, ch)) {
            count++;
          }
        }
        return count;
      }
    };
    StringTokenizer2.prototype.readLine = function() {
      var pos = this.currentPosition;
      while (pos < this.length) {
        var ch = this.text[pos];
        switch (ch) {
          case "\r":
          case "\n": {
            var text = this.text.substr(this.currentPosition, pos - this.currentPosition);
            this.currentPosition = pos + 1;
            if (ch === "\r" && this.currentPosition < this.length && this.text[this.currentPosition] === "\n") {
              this.currentPosition++;
            }
            return text;
          }
        }
        pos++;
      }
      if (pos > this.currentPosition) {
        var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);
        this.currentPosition = pos;
        return text2;
      }
      return null;
    };
    StringTokenizer2.prototype.peekLine = function() {
      var pos = this.currentPosition;
      var line = this.readLine();
      this.currentPosition = pos;
      return line;
    };
    StringTokenizer2.prototype.readWord = function() {
      var pos = this.currentPosition;
      while (pos < this.length) {
        var ch = this.text[pos];
        switch (ch) {
          case "\r":
          case "\n":
            var textValue = this.text.substr(this.currentPosition, pos - this.currentPosition);
            this.currentPosition = pos + 1;
            if (ch === "\r" && this.currentPosition < this.length && this.text[this.currentPosition] === "\n") {
              this.currentPosition++;
            }
            return textValue;
          case " ":
          case "	": {
            if (pos === this.currentPosition) {
              pos++;
            }
            var text = this.text.substr(this.currentPosition, pos - this.currentPosition);
            this.currentPosition = pos;
            return text;
          }
        }
        pos++;
      }
      if (pos > this.currentPosition) {
        var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);
        this.currentPosition = pos;
        return text2;
      }
      return null;
    };
    StringTokenizer2.prototype.peekWord = function() {
      var pos = this.currentPosition;
      var word = this.readWord();
      this.currentPosition = pos;
      return word;
    };
    StringTokenizer2.prototype.read = function(count) {
      if (typeof count === "undefined") {
        var ch = "0";
        if (!this.end) {
          ch = this.text[this.currentPosition];
          this.currentPosition++;
        }
        return ch;
      } else {
        var num = 0;
        var builder = "";
        while (!this.end && num < count) {
          var ch = this.read();
          builder = builder + ch;
          num++;
        }
        return builder;
      }
    };
    StringTokenizer2.prototype.peek = function() {
      var ch = "0";
      if (!this.end) {
        ch = this.text[this.currentPosition];
      }
      return ch;
    };
    StringTokenizer2.prototype.close = function() {
      this.text = null;
    };
    StringTokenizer2.prototype.readToEnd = function() {
      var text;
      if (this.currentPosition === 0) {
        text = this.text;
      } else {
        text = this.text.substr(this.currentPosition, this.length - this.currentPosition);
      }
      this.currentPosition = this.length;
      return text;
    };
    StringTokenizer2.contains = function(array, symbol) {
      var contains = false;
      for (var i = 0; i < array.length; i++) {
        if (array[i] === symbol) {
          contains = true;
          break;
        }
      }
      return contains;
    };
    StringTokenizer2.whiteSpace = " ";
    StringTokenizer2.tab = "	";
    StringTokenizer2.spaces = [StringTokenizer2.whiteSpace, StringTokenizer2.tab];
    StringTokenizer2.whiteSpacePattern = "^[ 	]+$";
    return StringTokenizer2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/string-layouter.js
var PdfStringLayouter = (
  /** @class */
  function() {
    function PdfStringLayouter2() {
      this.isOverloadWithPosition = false;
    }
    PdfStringLayouter2.prototype.layout = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      if (arg4 instanceof RectangleF) {
        this.initialize(arg1, arg2, arg3, arg4, arg5);
        this.isOverloadWithPosition = arg6;
        this.clientSize = arg7;
        var result = this.doLayout();
        this.clear();
        return result;
      } else {
        this.initialize(arg1, arg2, arg3, arg4);
        this.isOverloadWithPosition = arg5;
        this.clientSize = arg6;
        var result = this.doLayout();
        this.clear();
        return result;
      }
    };
    PdfStringLayouter2.prototype.initialize = function(text, font, format, rectSize, pageHeight) {
      if (typeof pageHeight === "number") {
        if (text == null) {
          throw new Error("ArgumentNullException:text");
        }
        if (font == null) {
          throw new Error("ArgumentNullException:font");
        }
        this.text = text;
        this.font = font;
        this.format = format;
        this.size = new SizeF(rectSize.width, rectSize.height);
        this.rectangle = rectSize;
        this.pageHeight = pageHeight;
        this.reader = new StringTokenizer(text);
      } else {
        this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);
      }
    };
    PdfStringLayouter2.prototype.clear = function() {
      this.font = null;
      this.format = null;
      this.reader.close();
      this.reader = null;
      this.text = null;
    };
    PdfStringLayouter2.prototype.doLayout = function() {
      var result = new PdfStringLayoutResult();
      var lineResult = new PdfStringLayoutResult();
      var lines = [];
      var line = this.reader.peekLine();
      var lineIndent = this.getLineIndent(true);
      while (line != null) {
        lineResult = this.layoutLine(line, lineIndent);
        if (lineResult !== null || typeof lineResult !== "undefined") {
          var numSymbolsInserted = 0;
          var returnedValue = this.copyToResult(
            result,
            lineResult,
            lines,
            /*out*/
            numSymbolsInserted
          );
          var success = returnedValue.success;
          numSymbolsInserted = returnedValue.numInserted;
          if (!success) {
            this.reader.read(numSymbolsInserted);
            break;
          }
        }
        this.reader.readLine();
        line = this.reader.peekLine();
        lineIndent = this.getLineIndent(false);
      }
      this.finalizeResult(result, lines);
      return result;
    };
    PdfStringLayouter2.prototype.getLineIndent = function(firstLine) {
      var lineIndent = 0;
      if (this.format != null) {
        lineIndent = firstLine ? this.format.firstLineIndent : this.format.paragraphIndent;
        lineIndent = this.size.width > 0 ? Math.min(this.size.width, lineIndent) : lineIndent;
      }
      return lineIndent;
    };
    PdfStringLayouter2.prototype.getLineHeight = function() {
      var height = this.font.height;
      if (this.format != null && this.format.lineSpacing !== 0) {
        height = this.format.lineSpacing + this.font.height;
      }
      return height;
    };
    PdfStringLayouter2.prototype.getLineWidth = function(line) {
      var width = this.font.getLineWidth(line, this.format);
      return width;
    };
    PdfStringLayouter2.prototype.layoutLine = function(line, lineIndent) {
      var lineResult = new PdfStringLayoutResult();
      lineResult.layoutLineHeight = this.getLineHeight();
      var lines = [];
      var maxWidth = this.size.width;
      var lineWidth = this.getLineWidth(line) + lineIndent;
      var lineType = LineType.FirstParagraphLine;
      var readWord = true;
      if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {
        this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);
      } else {
        var builder = "";
        var curLine = "";
        lineWidth = lineIndent;
        var curIndent = lineIndent;
        var reader = new StringTokenizer(line);
        var word = reader.peekWord();
        var isSingleWord = false;
        if (word.length !== reader.length) {
          if (word === " ") {
            curLine = curLine + word;
            builder = builder + word;
            reader.position += 1;
            word = reader.peekWord();
          }
        }
        while (word != null) {
          curLine = curLine + word;
          var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent;
          if (curLine.toString() === " ") {
            curLine = "";
            curLineWidth = 0;
          }
          if (curLineWidth > maxWidth) {
            if (this.getWrapType() === PdfWordWrapType.None) {
              break;
            }
            if (curLine.length === word.length) {
              if (this.getWrapType() === PdfWordWrapType.WordOnly) {
                lineResult.textRemainder = line.substring(reader.position);
                break;
              } else if (curLine.length === 1) {
                builder = builder + word;
                break;
              } else {
                readWord = false;
                curLine = "";
                word = reader.peek().toString();
                continue;
              }
            } else {
              if (this.getLineWidth(word.toString()) > maxWidth) {
                this.format.wordWrap = PdfWordWrapType.Character;
              } else {
                if (typeof this.format !== "undefined" && this.format !== null) {
                  this.format.wordWrap = PdfWordWrapType.Word;
                }
              }
              if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {
                var ln = builder.toString();
                if (ln !== " ") {
                  this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);
                }
                if (this.isOverloadWithPosition) {
                  maxWidth = this.clientSize.width;
                }
                curLine = "";
                builder = "";
                lineWidth = 0;
                curIndent = 0;
                curLineWidth = 0;
                lineType = LineType.None;
                word = readWord ? word : reader.peekWord();
                readWord = true;
              } else {
                readWord = false;
                curLine = "";
                curLine = curLine + builder.toString();
                word = reader.peek().toString();
              }
              continue;
            }
          }
          builder = builder + word;
          lineWidth = curLineWidth;
          if (readWord) {
            reader.readWord();
            word = reader.peekWord();
          } else {
            reader.read();
            word = reader.peek().toString();
          }
        }
        if (builder.length > 0) {
          var ln = builder.toString();
          this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);
        }
        reader.close();
      }
      lineResult.layoutLines = [];
      for (var index = 0; index < lines.length; index++) {
        lineResult.layoutLines.push(lines[index]);
      }
      lines = [];
      return lineResult;
    };
    PdfStringLayouter2.prototype.addToLineResult = function(lineResult, lines, line, lineWidth, breakType) {
      var info = new LineInfo();
      info.text = line;
      info.width = lineWidth;
      info.lineType = breakType;
      lines.push(info);
      var size = lineResult.actualSize;
      size.height += this.getLineHeight();
      size.width = Math.max(size.width, lineWidth);
      lineResult.size = size;
    };
    PdfStringLayouter2.prototype.copyToResult = function(result, lineResult, lines, numInserted) {
      var success = true;
      var allowPartialLines = this.format != null && !this.format.lineLimit;
      var height = result.actualSize.height;
      var maxHeight = this.size.height;
      if (this.pageHeight > 0 && maxHeight + this.rectangle.y > this.pageHeight) {
        maxHeight = this.rectangle.y - this.pageHeight;
        maxHeight = Math.max(maxHeight, -maxHeight);
      }
      numInserted = 0;
      if (lineResult.lines != null) {
        for (var i = 0, len = lineResult.lines.length; i < len; i++) {
          var expHeight = height + lineResult.lineHeight;
          if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {
            var info = lineResult.lines[i];
            numInserted += info.text.length;
            info = this.trimLine(info, lines.length === 0);
            lines.push(info);
            var size = result.actualSize;
            size.width = Math.max(size.width, info.width);
            result.size = size;
            height = expHeight;
          } else {
            success = false;
            break;
          }
        }
      }
      if (height != result.size.height) {
        var size1 = result.actualSize;
        size1.height = height;
        result.size = size1;
      }
      return { success, numInserted };
    };
    PdfStringLayouter2.prototype.finalizeResult = function(result, lines) {
      result.layoutLines = [];
      for (var index = 0; index < lines.length; index++) {
        result.layoutLines.push(lines[index]);
      }
      result.layoutLineHeight = this.getLineHeight();
      if (!this.reader.end) {
        result.textRemainder = this.reader.readToEnd();
      }
      lines = [];
    };
    PdfStringLayouter2.prototype.trimLine = function(info, firstLine) {
      var line = info.text;
      var lineWidth = info.width;
      var trimStartSpaces = (info.lineType & LineType.FirstParagraphLine) === 0;
      var start = this.format == null || !this.format.rightToLeft;
      var spaces = StringTokenizer.spaces;
      line = start ? line.trim() : line.trim();
      if (line.length !== info.text.length) {
        lineWidth = this.getLineWidth(line);
        if ((info.lineType & LineType.FirstParagraphLine) > 0) {
          lineWidth += this.getLineIndent(firstLine);
        }
      }
      info.text = line;
      info.width = lineWidth;
      return info;
    };
    PdfStringLayouter2.prototype.getWrapType = function() {
      var wrapType = this.format != null ? this.format.wordWrap : PdfWordWrapType.Word;
      return wrapType;
    };
    return PdfStringLayouter2;
  }()
);
var PdfStringLayoutResult = (
  /** @class */
  function() {
    function PdfStringLayoutResult2() {
    }
    Object.defineProperty(PdfStringLayoutResult2.prototype, "remainder", {
      // Properties
      /**
       * Gets the `text` which is not lay outed.
       * @private
       */
      get: function() {
        return this.textRemainder;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "actualSize", {
      /**
       * Gets the actual layout text `bounds`.
       * @private
       */
      get: function() {
        if (typeof this.size === "undefined") {
          this.size = new SizeF(0, 0);
        }
        return this.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "lines", {
      /**
       * Gets layout `lines` information.
       * @private
       */
      get: function() {
        return this.layoutLines;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "lineHeight", {
      /**
       * Gets the `height` of the line.
       * @private
       */
      get: function() {
        return this.layoutLineHeight;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "empty", {
      /**
       * Gets value that indicates whether any layout text [`empty`].
       * @private
       */
      get: function() {
        return this.layoutLines == null || this.layoutLines.length === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "lineCount", {
      /**
       * Gets `number of` the layout lines.
       * @private
       */
      get: function() {
        var count = !this.empty ? this.layoutLines.length : 0;
        return count;
      },
      enumerable: true,
      configurable: true
    });
    return PdfStringLayoutResult2;
  }()
);
var LineInfo = (
  /** @class */
  function() {
    function LineInfo2() {
    }
    Object.defineProperty(LineInfo2.prototype, "lineType", {
      //Properties
      /**
       * Gets the `type` of the line text.
       * @private
       */
      get: function() {
        return this.type;
      },
      set: function(value) {
        this.type = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineInfo2.prototype, "text", {
      /**
       * Gets the line `text`.
       * @private
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.content = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineInfo2.prototype, "width", {
      /**
       * Gets `width` of the line text.
       * @private
       */
      get: function() {
        return this.lineWidth;
      },
      set: function(value) {
        this.lineWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    return LineInfo2;
  }()
);
var LineType;
(function(LineType2) {
  LineType2[LineType2["None"] = 0] = "None";
  LineType2[LineType2["NewLineBreak"] = 1] = "NewLineBreak";
  LineType2[LineType2["LayoutBreak"] = 2] = "LayoutBreak";
  LineType2[LineType2["FirstParagraphLine"] = 4] = "FirstParagraphLine";
  LineType2[LineType2["LastParagraphLine"] = 8] = "LastParagraphLine";
})(LineType || (LineType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-font.js
var PdfFont = (
  /** @class */
  function() {
    function PdfFont2(size, style) {
      this.fontStyle = PdfFontStyle.Regular;
      if (typeof size === "number" && typeof style === "undefined") {
        this.fontSize = size;
      } else {
        this.fontSize = size;
        this.setStyle(style);
      }
    }
    Object.defineProperty(PdfFont2.prototype, "name", {
      //Properties
      /**
       * Gets the face name of this Font.
       * @private
       */
      get: function() {
        return this.metrics.name;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "size", {
      /**
       * Gets the size of this font.
       * @private
       */
      get: function() {
        return this.fontSize;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "height", {
      /**
       * Gets the height of the font in points.
       * @private
       */
      get: function() {
        return this.metrics.getHeight(null);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "style", {
      /**
       * Gets the style information for this font.
       * @private
       */
      get: function() {
        return this.fontStyle;
      },
      set: function(value) {
        this.fontStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "bold", {
      /**
       * Gets a value indicating whether this `PdfFont` is `bold`.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Bold) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "italic", {
      /**
       * Gets a value indicating whether this `PdfFont` has the `italic` style applied.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Italic) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "strikeout", {
      /**
       * Gets a value indicating whether this `PdfFont` is `strikeout`.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Strikeout) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "underline", {
      /**
       * Gets a value indicating whether this `PdfFont` is `underline`.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Underline) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "metrics", {
      /**
       * Gets or sets the `metrics` for this font.
       * @private
       */
      get: function() {
        return this.fontMetrics;
      },
      set: function(value) {
        this.fontMetrics = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "element", {
      // /**
      //  * Gets and Sets the font `internals`.
      //  * @private
      //  */
      // public get fontInternal() : IPdfPrimitive {
      //     return this.pdfFontInternals;
      // }
      // public set fontInternal(value : IPdfPrimitive) {
      //     this.pdfFontInternals = value;
      // }
      //IPdfWrapper Members
      /**
       * Gets the `element` representing the font.
       * @private
       */
      get: function() {
        return this.pdfFontInternals;
      },
      enumerable: true,
      configurable: true
    });
    PdfFont2.prototype.measureString = function(text, arg2, arg3, arg4, arg5) {
      if (typeof text === "string" && typeof arg2 === "undefined") {
        return this.measureString(text, null);
      } else if (typeof text === "string" && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === "undefined" && typeof arg4 === "undefined") {
        var temparg2 = arg2;
        var charactersFitted = 0;
        var linesFilled = 0;
        return this.measureString(text, temparg2, charactersFitted, linesFilled);
      } else if (typeof text === "string" && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === "number" && typeof arg4 === "number") {
        var temparg2 = arg2;
        return this.measureString(text, 0, temparg2, arg3, arg4);
      } else if (typeof text === "string" && typeof arg2 === "number" && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === "number" && typeof arg5 === "number") {
        var layoutArea = new SizeF(arg2, 0);
        var temparg3 = arg3;
        return this.measureString(text, layoutArea, temparg3, arg4, arg5);
      } else {
        if (text == null) {
          throw Error('ArgumentNullException("text")');
        }
        var temparg2 = arg2;
        var temparg3 = arg3;
        var layouter = new PdfStringLayouter();
        var result = layouter.layout(text, this, temparg3, temparg2, false, new SizeF(0, 0));
        arg4 = text.length;
        arg5 = result.empty ? 0 : result.lines.length;
        return result.actualSize;
      }
    };
    PdfFont2.prototype.equalsTo = function(obj) {
      var result = this.equalsToFont(obj);
      return result;
    };
    PdfFont2.prototype.getInternals = function() {
      return this.pdfFontInternals;
    };
    PdfFont2.prototype.setInternals = function(internals) {
      if (internals == null) {
        throw new Error("ArgumentNullException:internals");
      }
      this.pdfFontInternals = internals;
    };
    PdfFont2.prototype.setStyle = function(style) {
      this.fontStyle = style;
    };
    PdfFont2.prototype.applyFormatSettings = function(line, format, width) {
      var realWidth = width;
      if (format != null && width > 0) {
        if (format.characterSpacing !== 0) {
          realWidth += (line.length - 1) * format.characterSpacing;
        }
        if (format.wordSpacing !== 0) {
          var symbols = StringTokenizer.spaces;
          var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
          realWidth += whitespacesCount * format.wordSpacing;
        }
      }
      return realWidth;
    };
    PdfFont2.charSizeMultiplier = 1e-3;
    PdfFont2.syncObject = new Object();
    return PdfFont2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-transformation-matrix.js
var PdfTransformationMatrix = (
  /** @class */
  function() {
    function PdfTransformationMatrix2(value) {
      this.radDegFactor = 180 / Math.PI;
      if (typeof value === "undefined") {
        this.transformationMatrix = new Matrix(1, 0, 0, 1, 0, 0);
      } else {
        this.transformationMatrix = new Matrix(1, 0, 0, -1, 0, 0);
      }
    }
    Object.defineProperty(PdfTransformationMatrix2.prototype, "matrix", {
      // Properties
      /**
       * Gets or sets the `internal matrix object`.
       * @private
       */
      get: function() {
        return this.transformationMatrix;
      },
      set: function(value) {
        this.transformationMatrix = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTransformationMatrix2.prototype.translate = function(offsetX, offsetY) {
      this.transformationMatrix.translate(offsetX, offsetY);
    };
    PdfTransformationMatrix2.prototype.scale = function(scaleX, scaleY) {
      this.transformationMatrix.elements[0] = scaleX;
      this.transformationMatrix.elements[3] = scaleY;
    };
    PdfTransformationMatrix2.prototype.rotate = function(angle) {
      angle = angle * Math.PI / 180;
      this.transformationMatrix.elements[0] = Math.cos(angle);
      this.transformationMatrix.elements[1] = Math.sin(angle);
      this.transformationMatrix.elements[2] = -Math.sin(angle);
      this.transformationMatrix.elements[3] = Math.cos(angle);
    };
    PdfTransformationMatrix2.prototype.toString = function() {
      var builder = "";
      var whitespace = " ";
      for (var i = 0, len = this.transformationMatrix.elements.length; i < len; i++) {
        var temp = this.matrix.elements[i];
        builder += PdfNumber.floatToString(this.transformationMatrix.elements[i]);
        builder += whitespace;
      }
      return builder;
    };
    PdfTransformationMatrix2.prototype.multiply = function(matrix) {
      this.transformationMatrix.multiply(matrix.matrix);
    };
    PdfTransformationMatrix2.degreesToRadians = function(degreesX) {
      return this.degRadFactor * degreesX;
    };
    PdfTransformationMatrix2.prototype.radiansToDegrees = function(radians) {
      return this.radDegFactor * radians;
    };
    PdfTransformationMatrix2.prototype.clone = function() {
      return this;
    };
    PdfTransformationMatrix2.degRadFactor = Math.PI / 180;
    return PdfTransformationMatrix2;
  }()
);
var Matrix = (
  /** @class */
  function() {
    function Matrix2(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (typeof arg1 === "undefined") {
        this.metrixElements = [];
      } else if (typeof arg1 === "number") {
        this.metrixElements = [];
        this.metrixElements.push(arg1);
        this.metrixElements.push(arg2);
        this.metrixElements.push(arg3);
        this.metrixElements.push(arg4);
        this.metrixElements.push(arg5);
        this.metrixElements.push(arg6);
      } else {
        this.metrixElements = arg1;
      }
    }
    Object.defineProperty(Matrix2.prototype, "elements", {
      // Properties
      /**
       * Gets the `elements`.
       * @private
       */
      get: function() {
        return this.metrixElements;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Matrix2.prototype, "offsetX", {
      /**
       * Gets the off set `X`.
       * @private
       */
      get: function() {
        return this.metrixElements[4];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Matrix2.prototype, "offsetY", {
      /**
       * Gets the off set `Y`.
       * @private
       */
      get: function() {
        return this.metrixElements[5];
      },
      enumerable: true,
      configurable: true
    });
    Matrix2.prototype.translate = function(offsetX, offsetY) {
      this.metrixElements[4] = offsetX;
      this.metrixElements[5] = offsetY;
    };
    Matrix2.prototype.transform = function(point) {
      var x = point.x;
      var y = point.y;
      var x2 = x * this.elements[0] + y * this.elements[2] + this.offsetX;
      var y2 = x * this.elements[1] + y * this.elements[3] + this.offsetY;
      return new PointF(x2, y2);
    };
    Matrix2.prototype.multiply = function(matrix) {
      var tempMatrix = [];
      tempMatrix.push(this.elements[0] * matrix.elements[0] + this.elements[1] * matrix.elements[2]);
      tempMatrix[1] = this.elements[0] * matrix.elements[1] + this.elements[1] * matrix.elements[3];
      tempMatrix[2] = this.elements[2] * matrix.elements[0] + this.elements[3] * matrix.elements[2];
      tempMatrix[3] = this.elements[2] * matrix.elements[1] + this.elements[3] * matrix.elements[3];
      tempMatrix[4] = this.offsetX * matrix.elements[0] + this.offsetY * matrix.elements[2] + matrix.offsetX;
      tempMatrix[5] = this.offsetX * matrix.elements[1] + this.offsetY * matrix.elements[3] + matrix.offsetY;
      for (var i = 0; i < tempMatrix.length; i++) {
        this.elements[i] = tempMatrix[i];
      }
    };
    Matrix2.prototype.dispose = function() {
      this.metrixElements = null;
    };
    Matrix2.prototype.clone = function() {
      var m = new Matrix2(this.metrixElements);
      return m;
    };
    return Matrix2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/constants.js
var ProcedureSets = (
  /** @class */
  function() {
    function ProcedureSets2() {
      this.pdf = "PDF";
      this.text = "Text";
      this.imageB = "ImageB";
      this.imageC = "ImageC";
      this.imageI = "ImageI";
    }
    return ProcedureSets2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/collections/object-object-pair/dictionary.js
var TemporaryDictionary = (
  /** @class */
  function() {
    function TemporaryDictionary2() {
      this.mKeys = [];
      this.mValues = [];
    }
    TemporaryDictionary2.prototype.size = function() {
      return this.mKeys.length;
    };
    TemporaryDictionary2.prototype.add = function(key, value) {
      if (key === void 0 || key === null || value === void 0 || value === null) {
        throw new ReferenceError("Provided key or value is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        this.mKeys.push(key);
        this.mValues.push(value);
        return 1;
      } else {
        throw new RangeError("An item with the same key has already been added.");
      }
    };
    TemporaryDictionary2.prototype.keys = function() {
      return this.mKeys;
    };
    TemporaryDictionary2.prototype.values = function() {
      return this.mValues;
    };
    TemporaryDictionary2.prototype.getValue = function(key) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        throw new RangeError("No item with the specified key has been added.");
      } else {
        return this.mValues[index];
      }
    };
    TemporaryDictionary2.prototype.setValue = function(key, value) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        this.mKeys.push(key);
        this.mValues.push(value);
      } else {
        this.mValues[index] = value;
      }
    };
    TemporaryDictionary2.prototype.remove = function(key) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        throw new RangeError("No item with the specified key has been added.");
      } else {
        this.mKeys.splice(index, 1);
        this.mValues.splice(index, 1);
        return true;
      }
    };
    TemporaryDictionary2.prototype.containsKey = function(key) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        return false;
      }
      return true;
    };
    TemporaryDictionary2.prototype.clear = function() {
      this.mKeys = [];
      this.mValues = [];
    };
    return TemporaryDictionary2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-transparency.js
var PdfTransparency = (
  /** @class */
  function() {
    function PdfTransparency2(stroke, fill, mode) {
      this.dictionary = new PdfDictionary();
      this.dictionaryProperties = new DictionaryProperties();
      this.dictionary.items.setValue(this.dictionaryProperties.CA, new PdfNumber(stroke));
      this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(fill));
      this.dictionary.items.setValue(this.dictionaryProperties.BM, new PdfName(mode.toString()));
    }
    Object.defineProperty(PdfTransparency2.prototype, "element", {
      // // Implementation
      // /**
      //  * Gets the `number value`.
      //  * @private
      //  */
      // private getNumber(keyName : string) : number {
      //     let result : number = 0.0;
      //     let numb : PdfNumber = this.dictionary.items.getValue(keyName) as PdfNumber;
      //     result = numb.intValue;
      //     return result;
      // }
      // /**
      //  * Gets the `name value`.
      //  * @private
      //  */
      // private getName(keyName : string) : string {
      //     let result : string = null;
      //     let name : PdfName = this.dictionary.items.getValue(keyName) as PdfName;
      //     result = name.value;
      //     return result;
      // }
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.dictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTransparency2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/automatic-field-info-collection.js
var PdfAutomaticFieldInfoCollection = (
  /** @class */
  function() {
    function PdfAutomaticFieldInfoCollection2() {
      this.automaticFieldsInformation = [];
    }
    Object.defineProperty(PdfAutomaticFieldInfoCollection2.prototype, "automaticFields", {
      /**
       * Gets the `page number fields collection`.
       * @private
       */
      get: function() {
        return this.automaticFieldsInformation;
      },
      enumerable: true,
      configurable: true
    });
    PdfAutomaticFieldInfoCollection2.prototype.add = function(fieldInfo) {
      return this.automaticFields.push(fieldInfo);
    };
    return PdfAutomaticFieldInfoCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/graphics-element.js
var PdfGraphicsElement = (
  /** @class */
  function() {
    function PdfGraphicsElement2() {
    }
    PdfGraphicsElement2.prototype.drawHelper = function(graphics, x, y) {
      var bNeedSave = x !== 0 || y !== 0;
      var gState = null;
      if (bNeedSave) {
        gState = graphics.save();
        graphics.translateTransform(x, y);
      }
      this.drawInternal(graphics);
      if (bNeedSave) {
        graphics.restore(gState);
      }
    };
    return PdfGraphicsElement2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/automatic-field.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfAutomaticField = (
  /** @class */
  function(_super) {
    __extends5(PdfAutomaticField2, _super);
    function PdfAutomaticField2() {
      var _this = _super.call(this) || this;
      _this.internalBounds = new RectangleF(0, 0, 0, 0);
      _this.internalTemplateSize = new SizeF(0, 0);
      return _this;
    }
    Object.defineProperty(PdfAutomaticField2.prototype, "bounds", {
      // Properties
      get: function() {
        return this.internalBounds;
      },
      set: function(value) {
        this.internalBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "size", {
      get: function() {
        return new SizeF(this.bounds.width, this.bounds.height);
      },
      set: function(value) {
        this.bounds.width = value.width;
        this.bounds.height = value.height;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "location", {
      get: function() {
        return new PointF(this.bounds.x, this.bounds.y);
      },
      set: function(value) {
        this.bounds.x = value.x;
        this.bounds.y = value.y;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "font", {
      get: function() {
        return this.internalFont;
      },
      set: function(value) {
        this.internalFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "brush", {
      get: function() {
        return this.internalBrush;
      },
      set: function(value) {
        this.internalBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "pen", {
      get: function() {
        return this.internalPen;
      },
      set: function(value) {
        this.internalPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "stringFormat", {
      get: function() {
        return this.internalStringFormat;
      },
      set: function(value) {
        this.internalStringFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfAutomaticField2.prototype.performDrawHelper = function(graphics, location, scalingX, scalingY) {
      if (this.bounds.height === 0 || this.bounds.width === 0) {
        var text = this.getValue(graphics);
        this.internalTemplateSize = this.getFont().measureString(text, this.size, this.stringFormat);
      }
    };
    PdfAutomaticField2.prototype.draw = function(arg1, arg2, arg3) {
      if (typeof arg2 === "undefined") {
        var location_1 = new PointF(0, 0);
        this.draw(arg1, location_1);
      } else if (arg2 instanceof PointF) {
        this.draw(arg1, arg2.x, arg2.y);
      } else {
        this.drawHelper(arg1, arg2, arg3);
        var info = new PdfAutomaticFieldInfo(this, new PointF(arg2, arg3));
        arg1.automaticFields.add(info);
      }
    };
    PdfAutomaticField2.prototype.getSize = function() {
      if (this.bounds.height === 0 || this.bounds.width === 0) {
        return this.internalTemplateSize;
      } else {
        return this.size;
      }
    };
    PdfAutomaticField2.prototype.drawInternal = function(graphics) {
    };
    PdfAutomaticField2.prototype.getBrush = function() {
      return typeof this.internalBrush === "undefined" || this.internalBrush == null ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.internalBrush;
    };
    PdfAutomaticField2.prototype.getFont = function() {
      return typeof this.internalFont === "undefined" || this.internalFont == null ? PdfDocument.defaultFont : this.internalFont;
    };
    PdfAutomaticField2.prototype.getPageFromGraphics = function(graphics) {
      if (typeof graphics.page !== "undefined" && graphics.page !== null) {
        var page = graphics.page;
        return page;
      } else {
        var page = graphics.currentPage;
        return page;
      }
    };
    return PdfAutomaticField2;
  }(PdfGraphicsElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/automatic-field-info.js
var PdfAutomaticFieldInfo = (
  /** @class */
  function() {
    function PdfAutomaticFieldInfo2(field, location, scaleX, scaleY) {
      this.pageNumberFieldLocation = new PointF();
      this.pageNumberField = null;
      this.scaleX = 1;
      this.scaleY = 1;
      if (typeof location === "undefined" && field instanceof PdfAutomaticFieldInfo2) {
        this.pageNumberField = field.field;
        this.pageNumberFieldLocation = field.location;
        this.scaleX = field.scalingX;
        this.scaleY = field.scalingY;
      } else if (typeof scaleX === "undefined" && location instanceof PointF && field instanceof PdfAutomaticField) {
        this.pageNumberField = field;
        this.pageNumberFieldLocation = location;
      } else {
        this.pageNumberField = field;
        this.pageNumberFieldLocation = location;
        this.scaleX = scaleX;
        this.scaleY = scaleY;
      }
    }
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "location", {
      /* tslint:enable */
      // Properties
      /**
       * Gets or sets the location.
       * @private
       */
      get: function() {
        return this.pageNumberFieldLocation;
      },
      set: function(value) {
        this.pageNumberFieldLocation = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "field", {
      /**
       * Gets or sets the field.
       * @private
       */
      get: function() {
        return this.pageNumberField;
      },
      set: function(value) {
        this.pageNumberField = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "scalingX", {
      /**
       * Gets or sets the scaling X factor.
       * @private
       */
      get: function() {
        return this.scaleX;
      },
      set: function(value) {
        this.scaleX = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "scalingY", {
      /**
       * Gets or sets the scaling Y factor.
       * @private
       */
      get: function() {
        return this.scaleY;
      },
      set: function(value) {
        this.scaleY = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAutomaticFieldInfo2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-table-info.js
var TtfTableInfo = (
  /** @class */
  function() {
    function TtfTableInfo2() {
    }
    Object.defineProperty(TtfTableInfo2.prototype, "empty", {
      //Properties
      /**
       * Gets a value indicating whether this table is empty.
       * @private
       */
      get: function() {
        var empty = this.offset === this.length && this.length === this.checksum && this.checksum === 0;
        return empty;
      },
      enumerable: true,
      configurable: true
    });
    return TtfTableInfo2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-name-table.js
var TtfNameTable = (
  /** @class */
  function() {
    function TtfNameTable2() {
    }
    return TtfNameTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-name-record.js
var TtfNameRecord = (
  /** @class */
  function() {
    function TtfNameRecord2() {
    }
    return TtfNameRecord2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-head-table.js
var TtfHeadTable = (
  /** @class */
  function() {
    function TtfHeadTable2() {
    }
    return TtfHeadTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-metrics.js
var TtfMetrics = (
  /** @class */
  function() {
    function TtfMetrics2() {
    }
    Object.defineProperty(TtfMetrics2.prototype, "isItalic", {
      //Properties
      /**
       * Gets a value indicating whether this instance is italic.
       */
      get: function() {
        return (this.macStyle & 2) !== 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfMetrics2.prototype, "isBold", {
      /**
       * Gets a value indicating whether this instance is bold.
       */
      get: function() {
        return (this.macStyle & 1) !== 0;
      },
      enumerable: true,
      configurable: true
    });
    return TtfMetrics2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-horizontal-header-table.js
var TtfHorizontalHeaderTable = (
  /** @class */
  function() {
    function TtfHorizontalHeaderTable2() {
    }
    return TtfHorizontalHeaderTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-OS2-Table.js
var TtfOS2Table = (
  /** @class */
  function() {
    function TtfOS2Table2() {
    }
    return TtfOS2Table2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-post-table.js
var TtfPostTable = (
  /** @class */
  function() {
    function TtfPostTable2() {
    }
    return TtfPostTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-long-hor-metric.js
var TtfLongHorMetric = (
  /** @class */
  function() {
    function TtfLongHorMetric2() {
    }
    return TtfLongHorMetric2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-cmap-sub-table.js
var TtfCmapSubTable = (
  /** @class */
  function() {
    function TtfCmapSubTable2() {
    }
    return TtfCmapSubTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-cmap-table.js
var TtfCmapTable = (
  /** @class */
  function() {
    function TtfCmapTable2() {
    }
    return TtfCmapTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-glyph-info.js
var TtfGlyphInfo = (
  /** @class */
  function() {
    function TtfGlyphInfo2() {
    }
    Object.defineProperty(TtfGlyphInfo2.prototype, "empty", {
      //Properties
      /**
       * Gets a value indicating whether this TtfGlyphInfo is empty.
       */
      get: function() {
        var empty = this.index === this.width && this.width === this.charCode && this.charCode === 0;
        return empty;
      },
      enumerable: true,
      configurable: true
    });
    TtfGlyphInfo2.prototype.compareTo = function(obj) {
      var glyph = obj;
      return this.index - glyph.index;
    };
    return TtfGlyphInfo2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-loca-table.js
var TtfLocaTable = (
  /** @class */
  function() {
    function TtfLocaTable2() {
    }
    return TtfLocaTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-apple-cmap-sub-table.js
var TtfAppleCmapSubTable = (
  /** @class */
  function() {
    function TtfAppleCmapSubTable2() {
    }
    return TtfAppleCmapSubTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-microsoft-cmap-sub-table.js
var TtfMicrosoftCmapSubTable = (
  /** @class */
  function() {
    function TtfMicrosoftCmapSubTable2() {
    }
    return TtfMicrosoftCmapSubTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-trimmed-cmap-sub-table.js
var TtfTrimmedCmapSubTable = (
  /** @class */
  function() {
    function TtfTrimmedCmapSubTable2() {
    }
    return TtfTrimmedCmapSubTable2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-glyph-header.js
var TtfGlyphHeader = (
  /** @class */
  function() {
    function TtfGlyphHeader2() {
    }
    return TtfGlyphHeader2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/big-endian-writer.js
var BigEndianWriter = (
  /** @class */
  function() {
    function BigEndianWriter2(capacity) {
      this.int32Size = 4;
      this.int16Size = 2;
      this.int64Size = 8;
      this.bufferLength = capacity;
      this.buffer = [];
    }
    Object.defineProperty(BigEndianWriter2.prototype, "data", {
      //Properties
      /**
       * Gets data written to the writer.
       */
      get: function() {
        if (this.buffer.length < this.bufferLength) {
          var length_1 = this.bufferLength - this.buffer.length;
          for (var i = 0; i < length_1; i++) {
            this.buffer.push(0);
          }
        }
        return this.buffer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BigEndianWriter2.prototype, "position", {
      /// <summary>
      /// Gets position of the internal buffer.
      /// </summary>
      get: function() {
        if (this.internalPosition === void 0 || this.internalPosition === null) {
          this.internalPosition = 0;
        }
        return this.internalPosition;
      },
      enumerable: true,
      configurable: true
    });
    BigEndianWriter2.prototype.writeShort = function(value) {
      var bytes = [(value & 65280) >> 8, value & 255];
      this.flush(bytes);
    };
    BigEndianWriter2.prototype.writeInt = function(value) {
      var i1 = (value & 4278190080) >> 24;
      i1 = i1 < 0 ? 256 + i1 : i1;
      var i2 = (value & 16711680) >> 16;
      i2 = i2 < 0 ? 256 + i2 : i2;
      var i3 = (value & 65280) >> 8;
      i3 = i3 < 0 ? 256 + i3 : i3;
      var i4 = value & 255;
      i4 = i4 < 0 ? 256 + i4 : i4;
      var bytes = [(value & 4278190080) >> 24, (value & 16711680) >> 16, (value & 65280) >> 8, value & 255];
      this.flush(bytes);
    };
    BigEndianWriter2.prototype.writeUInt = function(value) {
      var buff = [(value & 4278190080) >> 24, (value & 16711680) >> 16, (value & 65280) >> 8, value & 255];
      this.flush(buff);
    };
    BigEndianWriter2.prototype.writeString = function(value) {
      if (value == null) {
        throw new Error("Argument Null Exception : value");
      }
      var bytes = [];
      for (var i = 0; i < value.length; i++) {
        bytes.push(value.charCodeAt(i));
      }
      this.flush(bytes);
    };
    BigEndianWriter2.prototype.writeBytes = function(value) {
      this.flush(value);
    };
    BigEndianWriter2.prototype.flush = function(buff) {
      if (buff === null) {
        throw new Error("Argument Null Exception : buff");
      }
      var position = this.position;
      for (var i = 0; i < buff.length; i++) {
        this.buffer[position] = buff[i];
        position++;
      }
      this.internalPosition += buff.length;
    };
    return BigEndianWriter2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-reader.js
var TtfReader = (
  /** @class */
  function() {
    function TtfReader2(fontData) {
      this.int32Size = 4;
      this.isTtcFont = false;
      this.isMacTtf = false;
      this.metricsName = "";
      this.isMacTTF = false;
      this.missedGlyphs = 0;
      this.tableNames = ["cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "prep"];
      this.entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];
      this.fontData = fontData;
      this.initialize();
    }
    Object.defineProperty(TtfReader2.prototype, "macintosh", {
      //Properties
      /**
       * Gets glyphs for Macintosh or Symbol fonts (char - key, glyph - value).
       */
      get: function() {
        if (this.macintoshDictionary === null || this.macintoshDictionary === void 0) {
          this.macintoshDictionary = new Dictionary();
        }
        return this.macintoshDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfReader2.prototype, "microsoft", {
      /**
       * Gets glyphs for Microsoft or Symbol fonts (char - key, glyph - value).
       */
      get: function() {
        if (this.microsoftDictionary === null || this.microsoftDictionary === void 0) {
          this.microsoftDictionary = new Dictionary();
        }
        return this.microsoftDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfReader2.prototype, "macintoshGlyphs", {
      /**
       * Gets glyphs for Macintosh or Symbol fonts (glyph index - key, glyph - value).
       */
      get: function() {
        if (this.internalMacintoshGlyphs === null || this.internalMacintoshGlyphs === void 0) {
          this.internalMacintoshGlyphs = new Dictionary();
        }
        return this.internalMacintoshGlyphs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfReader2.prototype, "microsoftGlyphs", {
      /**
       * Gets glyphs for Microsoft Unicode fonts (glyph index - key, glyph - value).
       */
      get: function() {
        if (this.internalMicrosoftGlyphs === null || this.internalMicrosoftGlyphs === void 0) {
          this.internalMicrosoftGlyphs = new Dictionary();
        }
        return this.internalMicrosoftGlyphs;
      },
      enumerable: true,
      configurable: true
    });
    TtfReader2.prototype.initialize = function() {
      if (this.metrics === void 0) {
        this.metrics = new TtfMetrics();
      }
      this.readFontDictionary();
      var nameTable = this.readNameTable();
      var headTable = this.readHeadTable();
      this.initializeFontName(nameTable);
      this.metrics.macStyle = headTable.macStyle;
    };
    TtfReader2.prototype.readFontDictionary = function() {
      this.offset = 0;
      var version = this.checkPreambula();
      var numTables = this.readInt16(this.offset);
      var searchRange = this.readInt16(this.offset);
      var entrySelector = this.readInt16(this.offset);
      var rangeShift = this.readInt16(this.offset);
      if (this.tableDirectory === void 0) {
        this.tableDirectory = new Dictionary();
      }
      for (var i = 0; i < numTables; ++i) {
        var table = new TtfTableInfo();
        var tableKey = this.readString(this.int32Size);
        table.checksum = this.readInt32(this.offset);
        table.offset = this.readInt32(this.offset);
        table.length = this.readInt32(this.offset);
        this.tableDirectory.setValue(tableKey, table);
      }
      this.lowestPosition = this.offset;
      if (!this.isTtcFont) {
        this.fixOffsets();
      }
    };
    TtfReader2.prototype.fixOffsets = function() {
      var minOffset = Number.MAX_VALUE;
      var tableKeys = this.tableDirectory.keys();
      for (var i = 0; i < tableKeys.length; i++) {
        var value = this.tableDirectory.getValue(tableKeys[i]);
        var offset = value.offset;
        if (minOffset > offset) {
          minOffset = offset;
          if (minOffset <= this.lowestPosition) {
            break;
          }
        }
      }
      var shift = minOffset - this.lowestPosition;
      if (shift !== 0) {
        var table = new Dictionary();
        for (var i = 0; i < tableKeys.length; i++) {
          var value = this.tableDirectory.getValue(tableKeys[i]);
          value.offset -= shift;
          table.setValue(tableKeys[i], value);
        }
        this.tableDirectory = table;
      }
    };
    TtfReader2.prototype.checkPreambula = function() {
      var version = this.readInt32(this.offset);
      this.isMacTtf = version === 1953658213 ? true : false;
      if (version !== 65536 && version !== 1953658213 && version !== 1330926671) {
        this.isTtcFont = true;
        this.offset = 0;
        var fontTag = this.readString(4);
        if (fontTag !== "ttcf") {
          throw new Error("Can not read TTF font data");
        }
        this.offset += 4;
        var ttcIdentificationNumber = this.readInt32(this.offset);
        if (ttcIdentificationNumber < 0) {
          throw new Error("Can not read TTF font data");
        }
        this.offset = this.readInt32(this.offset);
        version = this.readInt32(this.offset);
      }
      return version;
    };
    TtfReader2.prototype.readNameTable = function() {
      var tableInfo = this.getTable("name");
      this.offset = tableInfo.offset;
      var table = new TtfNameTable();
      table.formatSelector = this.readUInt16(this.offset);
      table.recordsCount = this.readUInt16(this.offset);
      table.offset = this.readUInt16(this.offset);
      table.nameRecords = [];
      var recordSize = 12;
      var position = this.offset;
      for (var i = 0; i < table.recordsCount; i++) {
        this.offset = position;
        var record = new TtfNameRecord();
        record.platformID = this.readUInt16(this.offset);
        record.encodingID = this.readUInt16(this.offset);
        record.languageID = this.readUInt16(this.offset);
        record.nameID = this.readUInt16(this.offset);
        record.length = this.readUInt16(this.offset);
        record.offset = this.readUInt16(this.offset);
        this.offset = tableInfo.offset + table.offset + record.offset;
        var unicode = record.platformID === 0 || record.platformID === 3;
        record.name = this.readString(record.length, unicode);
        table.nameRecords[i] = record;
        position += recordSize;
      }
      return table;
    };
    TtfReader2.prototype.readHeadTable = function() {
      var tableInfo = this.getTable("head");
      this.offset = tableInfo.offset;
      var table = new TtfHeadTable();
      table.version = this.readFixed(this.offset);
      table.fontRevision = this.readFixed(this.offset);
      table.checkSumAdjustment = this.readUInt32(this.offset);
      table.magicNumber = this.readUInt32(this.offset);
      table.flags = this.readUInt16(this.offset);
      table.unitsPerEm = this.readUInt16(this.offset);
      table.created = this.readInt64(this.offset);
      table.modified = this.readInt64(this.offset);
      table.xMin = this.readInt16(this.offset);
      table.yMin = this.readInt16(this.offset);
      table.xMax = this.readInt16(this.offset);
      table.yMax = this.readInt16(this.offset);
      table.macStyle = this.readUInt16(this.offset);
      table.lowestReadableSize = this.readUInt16(this.offset);
      table.fontDirectionHint = this.readInt16(this.offset);
      table.indexToLocalFormat = this.readInt16(this.offset);
      table.glyphDataFormat = this.readInt16(this.offset);
      return table;
    };
    TtfReader2.prototype.readHorizontalHeaderTable = function() {
      var tableInfo = this.getTable("hhea");
      this.offset = tableInfo.offset;
      var table = new TtfHorizontalHeaderTable();
      table.version = this.readFixed(this.offset);
      table.ascender = this.readInt16(this.offset);
      table.descender = this.readInt16(this.offset);
      table.lineGap = this.readInt16(this.offset);
      table.advanceWidthMax = this.readUInt16(this.offset);
      table.minLeftSideBearing = this.readInt16(this.offset);
      table.minRightSideBearing = this.readInt16(this.offset);
      table.xMaxExtent = this.readInt16(this.offset);
      table.caretSlopeRise = this.readInt16(this.offset);
      table.caretSlopeRun = this.readInt16(this.offset);
      this.offset += 10;
      table.metricDataFormat = this.readInt16(this.offset);
      table.numberOfHMetrics = this.readUInt16(this.offset);
      return table;
    };
    TtfReader2.prototype.readOS2Table = function() {
      var tableInfo = this.getTable("OS/2");
      this.offset = tableInfo.offset;
      var table = new TtfOS2Table();
      table.version = this.readUInt16(this.offset);
      table.xAvgCharWidth = this.readInt16(this.offset);
      table.usWeightClass = this.readUInt16(this.offset);
      table.usWidthClass = this.readUInt16(this.offset);
      table.fsType = this.readInt16(this.offset);
      table.ySubscriptXSize = this.readInt16(this.offset);
      table.ySubscriptYSize = this.readInt16(this.offset);
      table.ySubscriptXOffset = this.readInt16(this.offset);
      table.ySubscriptYOffset = this.readInt16(this.offset);
      table.ySuperscriptXSize = this.readInt16(this.offset);
      table.ySuperscriptYSize = this.readInt16(this.offset);
      table.ySuperscriptXOffset = this.readInt16(this.offset);
      table.ySuperscriptYOffset = this.readInt16(this.offset);
      table.yStrikeoutSize = this.readInt16(this.offset);
      table.yStrikeoutPosition = this.readInt16(this.offset);
      table.sFamilyClass = this.readInt16(this.offset);
      table.panose = this.readBytes(10);
      table.ulUnicodeRange1 = this.readUInt32(this.offset);
      table.ulUnicodeRange2 = this.readUInt32(this.offset);
      table.ulUnicodeRange3 = this.readUInt32(this.offset);
      table.ulUnicodeRange4 = this.readUInt32(this.offset);
      table.vendorIdentifier = this.readBytes(4);
      table.fsSelection = this.readUInt16(this.offset);
      table.usFirstCharIndex = this.readUInt16(this.offset);
      table.usLastCharIndex = this.readUInt16(this.offset);
      table.sTypoAscender = this.readInt16(this.offset);
      table.sTypoDescender = this.readInt16(this.offset);
      table.sTypoLineGap = this.readInt16(this.offset);
      table.usWinAscent = this.readUInt16(this.offset);
      table.usWinDescent = this.readUInt16(this.offset);
      table.ulCodePageRange1 = this.readUInt32(this.offset);
      table.ulCodePageRange2 = this.readUInt32(this.offset);
      if (table.version > 1) {
        table.sxHeight = this.readInt16(this.offset);
        table.sCapHeight = this.readInt16(this.offset);
        table.usDefaultChar = this.readUInt16(this.offset);
        table.usBreakChar = this.readUInt16(this.offset);
        table.usMaxContext = this.readUInt16(this.offset);
      } else {
        table.sxHeight = 0;
        table.sCapHeight = 0;
        table.usDefaultChar = 0;
        table.usBreakChar = 0;
        table.usMaxContext = 0;
      }
      return table;
    };
    TtfReader2.prototype.readPostTable = function() {
      var tableInfo = this.getTable("post");
      this.offset = tableInfo.offset;
      var table = new TtfPostTable();
      table.formatType = this.readFixed(this.offset);
      table.italicAngle = this.readFixed(this.offset);
      table.underlinePosition = this.readInt16(this.offset);
      table.underlineThickness = this.readInt16(this.offset);
      table.isFixedPitch = this.readUInt32(this.offset);
      table.minType42 = this.readUInt32(this.offset);
      table.maxType42 = this.readUInt32(this.offset);
      table.minType1 = this.readUInt32(this.offset);
      table.maxType1 = this.readUInt32(this.offset);
      return table;
    };
    TtfReader2.prototype.readWidthTable = function(glyphCount, unitsPerEm) {
      var tableInfo = this.getTable("hmtx");
      this.offset = tableInfo.offset;
      var width = [];
      for (var i = 0; i < glyphCount; i++) {
        var glyph = new TtfLongHorMetric();
        glyph.advanceWidth = this.readUInt16(this.offset);
        glyph.lsb = this.readInt16(this.offset);
        var glyphWidth = glyph.advanceWidth * 1e3 / unitsPerEm;
        width.push(Math.floor(glyphWidth));
      }
      return width;
    };
    TtfReader2.prototype.readCmapTable = function() {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset;
      var table = new TtfCmapTable();
      table.version = this.readUInt16(this.offset);
      table.tablesCount = this.readUInt16(this.offset);
      var position = this.offset;
      var subTables = [];
      for (var i = 0; i < table.tablesCount; i++) {
        this.offset = position;
        var subTable = new TtfCmapSubTable();
        subTable.platformID = this.readUInt16(this.offset);
        subTable.encodingID = this.readUInt16(this.offset);
        subTable.offset = this.readUInt32(this.offset);
        position = this.offset;
        this.readCmapSubTable(subTable);
        subTables[i] = subTable;
      }
      return subTables;
    };
    TtfReader2.prototype.readCmapSubTable = function(subTable) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var format = this.readUInt16(this.offset);
      var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
      var platform = encoding === TtfCmapEncoding.Macintosh ? TtfPlatformID.Macintosh : TtfPlatformID.Microsoft;
      if (encoding !== TtfCmapEncoding.Unknown) {
        switch (format) {
          case TtfCmapFormat.Apple:
            this.readAppleCmapTable(subTable, encoding);
            break;
          case TtfCmapFormat.Microsoft:
            this.readMicrosoftCmapTable(subTable, encoding);
            break;
          case TtfCmapFormat.Trimmed:
            this.readTrimmedCmapTable(subTable, encoding);
            break;
        }
      }
    };
    TtfReader2.prototype.readAppleCmapTable = function(subTable, encoding) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var table = new TtfAppleCmapSubTable();
      table.format = this.readUInt16(this.offset);
      table.length = this.readUInt16(this.offset);
      table.version = this.readUInt16(this.offset);
      if (this.maxMacIndex === null || this.maxMacIndex === void 0) {
        this.maxMacIndex = 0;
      }
      for (var i = 0; i < 256; ++i) {
        var glyphInfo = new TtfGlyphInfo();
        glyphInfo.index = this.readByte(this.offset);
        glyphInfo.width = this.getWidth(glyphInfo.index);
        glyphInfo.charCode = i;
        this.macintosh.setValue(i, glyphInfo);
        this.addGlyph(glyphInfo, encoding);
        this.maxMacIndex = Math.max(i, this.maxMacIndex);
      }
    };
    TtfReader2.prototype.readMicrosoftCmapTable = function(subTable, encoding) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var collection = encoding === TtfCmapEncoding.Unicode ? this.microsoft : this.macintosh;
      var table = new TtfMicrosoftCmapSubTable();
      table.format = this.readUInt16(this.offset);
      table.length = this.readUInt16(this.offset);
      table.version = this.readUInt16(this.offset);
      table.segCountX2 = this.readUInt16(this.offset);
      table.searchRange = this.readUInt16(this.offset);
      table.entrySelector = this.readUInt16(this.offset);
      table.rangeShift = this.readUInt16(this.offset);
      var segCount = table.segCountX2 / 2;
      table.endCount = this.readUshortArray(segCount);
      table.reservedPad = this.readUInt16(this.offset);
      table.startCount = this.readUshortArray(segCount);
      table.idDelta = this.readUshortArray(segCount);
      table.idRangeOffset = this.readUshortArray(segCount);
      var length = table.length / 2 - 8 - segCount * 4;
      table.glyphID = this.readUshortArray(length);
      var codeOffset = 0;
      var index = 0;
      for (var j = 0; j < segCount; j++) {
        for (var k = table.startCount[j]; k <= table.endCount[j] && k !== 65535; k++) {
          if (table.idRangeOffset[j] === 0) {
            codeOffset = k + table.idDelta[j] & 65535;
          } else {
            index = j + table.idRangeOffset[j] / 2 - segCount + k - table.startCount[j];
            if (index >= table.glyphID.length) {
              continue;
            }
            codeOffset = table.glyphID[index] + table.idDelta[j] & 65535;
          }
          var glyph = new TtfGlyphInfo();
          glyph.index = codeOffset;
          glyph.width = this.getWidth(glyph.index);
          var id = encoding === TtfCmapEncoding.Symbol ? (k & 65280) === 61440 ? k & 255 : k : k;
          glyph.charCode = id;
          collection.setValue(id, glyph);
          this.addGlyph(glyph, encoding);
        }
      }
    };
    TtfReader2.prototype.readTrimmedCmapTable = function(subTable, encoding) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var table = new TtfTrimmedCmapSubTable();
      table.format = this.readUInt16(this.offset);
      table.length = this.readUInt16(this.offset);
      table.version = this.readUInt16(this.offset);
      table.firstCode = this.readUInt16(this.offset);
      table.entryCount = this.readUInt16(this.offset);
      for (var i = 0; i < table.entryCount; ++i) {
        var glyphInfo = new TtfGlyphInfo();
        glyphInfo.index = this.readUInt16(this.offset);
        glyphInfo.width = this.getWidth(glyphInfo.index);
        glyphInfo.charCode = i + table.firstCode;
        this.macintosh.setValue(i, glyphInfo);
        this.addGlyph(glyphInfo, encoding);
        this.maxMacIndex = Math.max(i, this.maxMacIndex);
      }
    };
    TtfReader2.prototype.initializeFontName = function(nameTable) {
      for (var i = 0; i < nameTable.recordsCount; i++) {
        var record = nameTable.nameRecords[i];
        if (record.nameID === 1) {
          this.metrics.fontFamily = record.name;
        } else if (record.nameID === 6) {
          this.metrics.postScriptName = record.name;
        }
        if (this.metrics.fontFamily !== null && this.metrics.fontFamily !== void 0 && this.metrics.postScriptName !== null && this.metrics.postScriptName !== void 0) {
          break;
        }
      }
    };
    TtfReader2.prototype.getTable = function(name) {
      var table = new TtfTableInfo();
      var obj;
      if (this.tableDirectory.containsKey(name)) {
        obj = this.tableDirectory.getValue(name);
      }
      if (obj !== null && obj !== void 0) {
        table = obj;
      }
      return table;
    };
    TtfReader2.prototype.getWidth = function(glyphCode) {
      glyphCode = glyphCode < this.width.length ? glyphCode : this.width.length - 1;
      return this.width[glyphCode];
    };
    TtfReader2.prototype.getCmapEncoding = function(platformID, encodingID) {
      var format = TtfCmapEncoding.Unknown;
      if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Undefined) {
        format = TtfCmapEncoding.Symbol;
      } else if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Unicode) {
        format = TtfCmapEncoding.Unicode;
      } else if (platformID == TtfPlatformID.Macintosh && encodingID == TtfMacintoshEncodingID.Roman) {
        format = TtfCmapEncoding.Macintosh;
      }
      return format;
    };
    TtfReader2.prototype.addGlyph = function(glyph, encoding) {
      var collection = null;
      switch (encoding) {
        case TtfCmapEncoding.Unicode:
          collection = this.microsoftGlyphs;
          break;
        case TtfCmapEncoding.Macintosh:
        case TtfCmapEncoding.Symbol:
          collection = this.macintoshGlyphs;
          break;
      }
      collection.setValue(glyph.index, glyph);
    };
    TtfReader2.prototype.initializeMetrics = function(nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {
      this.initializeFontName(nameTable);
      var bSymbol = false;
      for (var i = 0; i < cmapTables.length; i++) {
        var subTable = cmapTables[i];
        var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
        if (encoding === TtfCmapEncoding.Symbol) {
          bSymbol = true;
          break;
        }
      }
      this.metrics.isSymbol = bSymbol;
      this.metrics.macStyle = headTable.macStyle;
      this.metrics.isFixedPitch = postTable.isFixedPitch !== 0;
      this.metrics.italicAngle = postTable.italicAngle;
      var factor = 1e3 / headTable.unitsPerEm;
      this.metrics.winAscent = os2Table.sTypoAscender * factor;
      this.metrics.macAscent = horizontalHeadTable.ascender * factor;
      this.metrics.capHeight = os2Table.sCapHeight !== 0 ? os2Table.sCapHeight : 0.7 * headTable.unitsPerEm * factor;
      this.metrics.winDescent = os2Table.sTypoDescender * factor;
      this.metrics.macDescent = horizontalHeadTable.descender * factor;
      this.metrics.leading = (os2Table.sTypoAscender - os2Table.sTypoDescender + os2Table.sTypoLineGap) * factor;
      this.metrics.lineGap = Math.ceil(horizontalHeadTable.lineGap * factor);
      var left = headTable.xMin * factor;
      var top = Math.ceil(this.metrics.macAscent + this.metrics.lineGap);
      var right = headTable.xMax * factor;
      var bottom = this.metrics.macDescent;
      this.metrics.fontBox = new Rectangle(left, top, right, bottom);
      this.metrics.stemV = 80;
      this.metrics.widthTable = this.updateWidth();
      this.metrics.contains = this.tableDirectory.containsKey("CFF");
      this.metrics.subScriptSizeFactor = headTable.unitsPerEm / os2Table.ySubscriptYSize;
      this.metrics.superscriptSizeFactor = headTable.unitsPerEm / os2Table.ySuperscriptYSize;
    };
    TtfReader2.prototype.updateWidth = function() {
      var count = 256;
      var bytes = [];
      if (this.metrics.isSymbol) {
        for (var i = 0; i < count; i++) {
          var glyphInfo = this.getGlyph(String.fromCharCode(i));
          bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;
        }
      } else {
        var byteToProcess = [];
        var unknown = "?";
        var space = String.fromCharCode(32);
        for (var i = 0; i < count; i++) {
          byteToProcess[0] = i;
          var text = this.getString(byteToProcess, 0, byteToProcess.length);
          var ch = text.length > 0 ? text[0] : unknown;
          var glyphInfo = this.getGlyph(ch);
          if (!glyphInfo.empty) {
            bytes[i] = glyphInfo.width;
          } else {
            glyphInfo = this.getGlyph(space);
            bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;
          }
        }
      }
      return bytes;
    };
    TtfReader2.prototype.getDefaultGlyph = function() {
      var glyph = this.getGlyph(StringTokenizer.whiteSpace);
      return glyph;
    };
    TtfReader2.prototype.getString = function(byteToProcess, start, length) {
      var result = "";
      for (var index = 0; index < length; index++) {
        result += String.fromCharCode(byteToProcess[index + start]);
      }
      return result;
    };
    TtfReader2.prototype.readLocaTable = function(bShort) {
      var tableInfo = this.getTable("loca");
      this.offset = tableInfo.offset;
      var table = new TtfLocaTable();
      var buffer = null;
      if (bShort) {
        var len = tableInfo.length / 2;
        buffer = [];
        for (var i = 0; i < len; i++) {
          buffer[i] = this.readUInt16(this.offset) * 2;
        }
      } else {
        var len = tableInfo.length / 4;
        buffer = [];
        for (var i = 0; i < len; i++) {
          buffer[i] = this.readUInt32(this.offset);
        }
      }
      table.offsets = buffer;
      return table;
    };
    TtfReader2.prototype.updateGlyphChars = function(glyphChars, locaTable) {
      if (!glyphChars.containsKey(0)) {
        glyphChars.setValue(0, 0);
      }
      var clone = new Dictionary();
      var glyphCharKeys = glyphChars.keys();
      for (var i = 0; i < glyphCharKeys.length; i++) {
        clone.setValue(glyphCharKeys[i], glyphChars.getValue(glyphCharKeys[i]));
      }
      for (var i = 0; i < glyphCharKeys.length; i++) {
        var nextKey = glyphCharKeys[i];
        this.processCompositeGlyph(glyphChars, nextKey, locaTable);
      }
    };
    TtfReader2.prototype.processCompositeGlyph = function(glyphChars, glyph, locaTable) {
      if (glyph < locaTable.offsets.length - 1) {
        var glyphOffset = locaTable.offsets[glyph];
        if (glyphOffset !== locaTable.offsets[glyph + 1]) {
          var tableInfo = this.getTable("glyf");
          this.offset = tableInfo.offset + glyphOffset;
          var glyphHeader = new TtfGlyphHeader();
          glyphHeader.numberOfContours = this.readInt16(this.offset);
          glyphHeader.xMin = this.readInt16(this.offset);
          glyphHeader.yMin = this.readInt16(this.offset);
          glyphHeader.xMax = this.readInt16(this.offset);
          glyphHeader.yMax = this.readInt16(this.offset);
          if (glyphHeader.numberOfContours < 0) {
            var skipBytes = 0;
            var entry = true;
            while (entry) {
              var flags = this.readUInt16(this.offset);
              var glyphIndex = this.readUInt16(this.offset);
              if (!glyphChars.containsKey(glyphIndex)) {
                glyphChars.setValue(glyphIndex, 0);
              }
              if ((flags & TtfCompositeGlyphFlags.MoreComponents) === 0) {
                break;
              }
              skipBytes = (flags & TtfCompositeGlyphFlags.Arg1And2AreWords) !== 0 ? 4 : 2;
              if ((flags & TtfCompositeGlyphFlags.WeHaveScale) !== 0) {
                skipBytes += 2;
              } else if ((flags & TtfCompositeGlyphFlags.WeHaveAnXyScale) !== 0) {
                skipBytes += 4;
              } else if ((flags & TtfCompositeGlyphFlags.WeHaveTwoByTwo) !== 0) {
                skipBytes += 2 * 4;
              }
              this.offset += skipBytes;
            }
          }
        }
      }
    };
    TtfReader2.prototype.generateGlyphTable = function(glyphChars, locaTable, newLocaTable, newGlyphTable) {
      newLocaTable = [];
      var activeGlyphs = glyphChars.keys();
      activeGlyphs.sort(function(a, b) {
        return a - b;
      });
      var glyphSize = 0;
      for (var i = 0; i < activeGlyphs.length; i++) {
        var glyphIndex = activeGlyphs[i];
        if (locaTable.offsets.length > 0) {
          glyphSize += locaTable.offsets[glyphIndex + 1] - locaTable.offsets[glyphIndex];
        }
      }
      var glyphSizeAligned = this.align(glyphSize);
      newGlyphTable = [];
      for (var i = 0; i < glyphSizeAligned; i++) {
        newGlyphTable.push(0);
      }
      var nextGlyphOffset = 0;
      var nextGlyphIndex = 0;
      var table = this.getTable("glyf");
      for (var i = 0; i < locaTable.offsets.length; i++) {
        newLocaTable.push(nextGlyphOffset);
        if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[nextGlyphIndex] === i) {
          ++nextGlyphIndex;
          newLocaTable[i] = nextGlyphOffset;
          var oldGlyphOffset = locaTable.offsets[i];
          var oldNextGlyphOffset = locaTable.offsets[i + 1] - oldGlyphOffset;
          if (oldNextGlyphOffset > 0) {
            this.offset = table.offset + oldGlyphOffset;
            var result = this.read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);
            newGlyphTable = result.buffer;
            nextGlyphOffset += oldNextGlyphOffset;
          }
        }
      }
      return { glyphTableSize: glyphSize, newLocaTable, newGlyphTable };
    };
    TtfReader2.prototype.updateLocaTable = function(newLocaTable, bLocaIsShort, newLocaTableOut) {
      if (newLocaTable === null) {
        throw new Error("Argument Null Exception : newLocaTable");
      }
      var size = bLocaIsShort ? newLocaTable.length * 2 : newLocaTable.length * 4;
      var count = this.align(size);
      var writer = new BigEndianWriter(count);
      for (var i = 0; i < newLocaTable.length; i++) {
        var value = newLocaTable[i];
        if (bLocaIsShort) {
          value /= 2;
          writer.writeShort(value);
        } else {
          writer.writeInt(value);
        }
      }
      return { newLocaUpdated: writer.data, newLocaSize: size };
    };
    TtfReader2.prototype.align = function(value) {
      return value + 3 & ~3;
    };
    TtfReader2.prototype.getFontProgram = function(newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
      if (newLocaTableOut === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      var tableNames = this.tableNames;
      var result = this.getFontProgramLength(newLocaTableOut, newGlyphTable, 0);
      var fontProgramLength = result.fontProgramLength;
      var numTables = result.numTables;
      var writer = new BigEndianWriter(fontProgramLength);
      writer.writeInt(65536);
      writer.writeShort(numTables);
      var entrySelector = this.entrySelectors[numTables];
      writer.writeShort((1 << (entrySelector & 31)) * 16);
      writer.writeShort(entrySelector);
      writer.writeShort((numTables - (1 << (entrySelector & 31))) * 16);
      this.writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize);
      this.writeGlyphs(writer, newLocaTableOut, newGlyphTable);
      return writer.data;
    };
    TtfReader2.prototype.getFontProgramLength = function(newLocaTableOut, newGlyphTable, numTables) {
      if (newLocaTableOut === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      numTables = 2;
      var tableNames = this.tableNames;
      var fontProgramLength = 0;
      for (var i = 0; i < tableNames.length; i++) {
        var tableName = tableNames[i];
        if (tableName !== "glyf" && tableName !== "loca") {
          var table = this.getTable(tableName);
          if (!table.empty) {
            ++numTables;
            fontProgramLength += this.align(table.length);
          }
        }
      }
      fontProgramLength += newLocaTableOut.length;
      fontProgramLength += newGlyphTable.length;
      var usedTablesSize = numTables * 16 + 3 * 4;
      fontProgramLength += usedTablesSize;
      return { fontProgramLength, numTables };
    };
    TtfReader2.prototype.writeCheckSums = function(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
      if (writer === null) {
        throw new Error("Argument Null Exception : writer");
      }
      if (newLocaTableOut === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      var tableNames = this.tableNames;
      var usedTablesSize = numTables * 16 + 3 * 4;
      var nextTableSize = 0;
      for (var i = 0; i < tableNames.length; i++) {
        var tableName = tableNames[i];
        var tableInfo = this.getTable(tableName);
        if (tableInfo.empty) {
          continue;
        }
        writer.writeString(tableName);
        if (tableName === "glyf") {
          var checksum = this.calculateCheckSum(newGlyphTable);
          writer.writeInt(checksum);
          nextTableSize = glyphTableSize;
        } else if (tableName === "loca") {
          var checksum = this.calculateCheckSum(newLocaTableOut);
          writer.writeInt(checksum);
          nextTableSize = locaTableSize;
        } else {
          writer.writeInt(tableInfo.checksum);
          nextTableSize = tableInfo.length;
        }
        writer.writeUInt(usedTablesSize);
        writer.writeUInt(nextTableSize);
        usedTablesSize += this.align(nextTableSize);
      }
    };
    TtfReader2.prototype.calculateCheckSum = function(bytes) {
      if (bytes === null) {
        throw new Error("Argument Null Exception : bytes");
      }
      var pos = 0;
      var byte1 = 0;
      var byte2 = 0;
      var byte3 = 0;
      var byte4 = 0;
      for (var i = 0; i < (bytes.length + 1) / 4; i++) {
        byte4 += bytes[pos++] & 255;
        byte3 += bytes[pos++] & 255;
        byte2 += bytes[pos++] & 255;
        byte1 += bytes[pos++] & 255;
      }
      var result = byte1;
      result += byte2 << 8;
      result += byte3 << 16;
      result += byte4 << 24;
      return result;
    };
    TtfReader2.prototype.writeGlyphs = function(writer, newLocaTable, newGlyphTable) {
      if (writer === null) {
        throw new Error("Argument Null Exception : writer");
      }
      if (newLocaTable === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      var tableNames = this.tableNames;
      for (var i = 0; i < tableNames.length; i++) {
        var tableName = tableNames[i];
        var tableInfo = this.getTable(tableName);
        if (tableInfo.empty) {
          continue;
        }
        if (tableName === "glyf") {
          writer.writeBytes(newGlyphTable);
        } else if (tableName === "loca") {
          writer.writeBytes(newLocaTable);
        } else {
          var count = this.align(tableInfo.length);
          var buff = [];
          for (var i_1 = 0; i_1 < count; i_1++) {
            buff.push(0);
          }
          this.offset = tableInfo.offset;
          var result = this.read(buff, 0, tableInfo.length);
          writer.writeBytes(result.buffer);
        }
      }
    };
    TtfReader2.prototype.setOffset = function(offset) {
      this.offset = offset;
    };
    TtfReader2.prototype.createInternals = function() {
      this.metrics = new TtfMetrics();
      var nameTable = this.readNameTable();
      var headTable = this.readHeadTable();
      this.bIsLocaShort = headTable.indexToLocalFormat === 0;
      var horizontalHeadTable = this.readHorizontalHeaderTable();
      var os2Table = this.readOS2Table();
      var postTable = this.readPostTable();
      this.width = this.readWidthTable(horizontalHeadTable.numberOfHMetrics, headTable.unitsPerEm);
      var subTables = this.readCmapTable();
      this.initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);
    };
    TtfReader2.prototype.getGlyph = function(charCode) {
      if (typeof charCode === "number") {
        var obj1 = null;
        if (!this.metrics.isSymbol && this.microsoftGlyphs != null) {
          if (this.microsoftGlyphs.containsKey(charCode)) {
            obj1 = this.microsoftGlyphs.getValue(charCode);
          }
        } else if (this.metrics.isSymbol && this.macintoshGlyphs != null) {
          if (this.macintoshGlyphs.containsKey(charCode)) {
            obj1 = this.macintoshGlyphs.getValue(charCode);
          }
        }
        var glyph = obj1 != null ? obj1 : this.getDefaultGlyph();
        return glyph;
      } else {
        var obj = null;
        var code = charCode.charCodeAt(0);
        if (!this.metrics.isSymbol && this.microsoft !== null) {
          if (this.microsoft.containsKey(code)) {
            obj = this.microsoft.getValue(code);
            if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {
              this.isFontPresent = true;
            }
          } else if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {
            this.isFontPresent = false;
          }
        } else if (this.metrics.isSymbol && this.macintosh !== null || this.isMacTTF) {
          if (this.maxMacIndex !== 0) {
            code %= this.maxMacIndex + 1;
          } else {
            code = (code & 65280) === 61440 ? code & 255 : code;
          }
          if (this.macintosh.containsKey(code)) {
            obj = this.macintosh.getValue(code);
            this.isFontPresent = true;
          }
        }
        if (charCode === StringTokenizer.whiteSpace && obj === null) {
          obj = new TtfGlyphInfo();
        }
        var glyph = obj !== null ? obj : this.getDefaultGlyph();
        return glyph;
      }
    };
    TtfReader2.prototype.getGlyphChars = function(chars) {
      if (chars === null || chars === void 0) {
        throw new Error("Argument Null Exception : chars");
      }
      var dictionary = new Dictionary();
      var charKeys = chars.keys();
      for (var i = 0; i < charKeys.length; i++) {
        var ch = charKeys[i];
        var glyph = this.getGlyph(ch);
        if (!glyph.empty) {
          dictionary.setValue(glyph.index, ch.charCodeAt(0));
        }
      }
      return dictionary;
    };
    TtfReader2.prototype.getAllGlyphs = function() {
      var allGlyphInfo = [];
      var info = new TtfGlyphInfo();
      var index = 0;
      for (var i = 0; i < this.width.length; i++) {
        var width = this.width[i];
        info.index = index;
        info.width = width;
        allGlyphInfo.push(info);
        index++;
      }
      return allGlyphInfo;
    };
    TtfReader2.prototype.readFontProgram = function(chars) {
      var glyphChars = this.getGlyphChars(chars);
      var locaTable = this.readLocaTable(this.bIsLocaShort);
      if (glyphChars.size() < chars.size()) {
        this.missedGlyphs = chars.size() - glyphChars.size();
      }
      this.updateGlyphChars(glyphChars, locaTable);
      var result1 = this.generateGlyphTable(glyphChars, locaTable, null, null);
      var glyphTableSize = result1.glyphTableSize;
      var newLocaTable = result1.newLocaTable;
      var newGlyphTable = result1.newGlyphTable;
      var result2 = this.updateLocaTable(newLocaTable, this.bIsLocaShort, null);
      var newLocaSize = result2.newLocaSize;
      var newLocaUpdated = result2.newLocaUpdated;
      var fontProgram = this.getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);
      return fontProgram;
    };
    TtfReader2.prototype.convertString = function(text) {
      if (text === null) {
        throw new Error("Argument Null Exception : text");
      }
      var glyph = "";
      var i = 0;
      for (var k = 0; k < text.length; k++) {
        var ch = text[k];
        var glyphInfo = this.getGlyph(ch);
        if (!glyphInfo.empty) {
          glyph += String.fromCharCode(glyphInfo.index);
          i++;
        }
      }
      return glyph;
    };
    TtfReader2.prototype.getCharWidth = function(code) {
      var glyphInfo = this.getGlyph(code);
      glyphInfo = !glyphInfo.empty ? glyphInfo : this.getDefaultGlyph();
      var codeWidth = !glyphInfo.empty ? glyphInfo.width : 0;
      return codeWidth;
    };
    TtfReader2.prototype.readString = function(length, isUnicode) {
      if (isUnicode === void 0) {
        return this.readString(length, false);
      } else {
        var result = "";
        if (isUnicode) {
          for (var i = 0; i < length; i++) {
            if (i % 2 !== 0) {
              result += String.fromCharCode(this.fontData[this.offset]);
            }
            this.offset += 1;
          }
        } else {
          for (var i = 0; i < length; i++) {
            result += String.fromCharCode(this.fontData[this.offset]);
            this.offset += 1;
          }
        }
        return result;
      }
    };
    TtfReader2.prototype.readFixed = function(offset) {
      var integer = this.readInt16(offset);
      var sFraction = this.readInt16(offset + 2);
      var fraction = sFraction / 16384;
      return integer + fraction;
    };
    TtfReader2.prototype.readInt32 = function(offset) {
      var i1 = this.fontData[offset + 3];
      var i2 = this.fontData[offset + 2];
      var i3 = this.fontData[offset + 1];
      var i4 = this.fontData[offset];
      this.offset += 4;
      return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);
    };
    TtfReader2.prototype.readUInt32 = function(offset) {
      var i1 = this.fontData[offset + 3];
      var i2 = this.fontData[offset + 2];
      var i3 = this.fontData[offset + 1];
      var i4 = this.fontData[offset];
      this.offset += 4;
      return i1 | i2 << 8 | i3 << 16 | i4 << 24;
    };
    TtfReader2.prototype.readInt16 = function(offset) {
      var result = (this.fontData[offset] << 8) + this.fontData[offset + 1];
      result = result & 1 << 15 ? result - 65536 : result;
      this.offset += 2;
      return result;
    };
    TtfReader2.prototype.readInt64 = function(offset) {
      var low = this.readInt32(offset + 4);
      var n = this.readInt32(offset) * 4294967296 + low;
      if (low < 0) {
        n += 4294967296;
      }
      return n;
    };
    TtfReader2.prototype.readUInt16 = function(offset) {
      var result = this.fontData[offset] << 8 | this.fontData[offset + 1];
      this.offset += 2;
      return result;
    };
    TtfReader2.prototype.readUshortArray = function(length) {
      var buffer = [];
      for (var i = 0; i < length; i++) {
        buffer[i] = this.readUInt16(this.offset);
      }
      return buffer;
    };
    TtfReader2.prototype.readBytes = function(length) {
      var result = [];
      for (var i = 0; i < length; i++) {
        result.push(this.fontData[this.offset]);
        this.offset += 1;
      }
      return result;
    };
    TtfReader2.prototype.readByte = function(offset) {
      var result = this.fontData[offset];
      this.offset += 1;
      return result;
    };
    TtfReader2.prototype.read = function(buffer, index, count) {
      if (buffer === null) {
        throw new Error("Argument Null Exception : buffer");
      }
      var written = 0;
      var read = 0;
      do {
        for (var i = 0; i < count - written && this.offset + i < this.fontData.length; i++) {
          buffer[index + i] = this.fontData[this.offset + i];
        }
        read = count - written;
        this.offset += read;
        written += read;
      } while (written < count);
      return { buffer, written };
    };
    return TtfReader2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-font-metrics.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfFontMetrics = (
  /** @class */
  function() {
    function PdfFontMetrics2() {
      this.lineGap = 0;
    }
    PdfFontMetrics2.prototype.getAscent = function(format) {
      var returnValue = this.ascent * PdfFont.charSizeMultiplier * this.getSize(format);
      return returnValue;
    };
    PdfFontMetrics2.prototype.getDescent = function(format) {
      var returnValue = this.descent * PdfFont.charSizeMultiplier * this.getSize(format);
      return returnValue;
    };
    PdfFontMetrics2.prototype.getLineGap = function(format) {
      var returnValue = this.lineGap * PdfFont.charSizeMultiplier * this.getSize(format);
      return returnValue;
    };
    PdfFontMetrics2.prototype.getHeight = function(format) {
      var height;
      var clearTypeFonts = ["cambria", "candara", "constantia", "corbel", "cariadings"];
      var clearTypeFontCollection = [];
      for (var index = 0; index < clearTypeFonts.length; index++) {
        var font = clearTypeFonts[index];
        clearTypeFontCollection.push(font);
      }
      if (this.getDescent(format) < 0) {
        height = this.getAscent(format) - this.getDescent(format) + this.getLineGap(format);
      } else {
        height = this.getAscent(format) + this.getDescent(format) + this.getLineGap(format);
      }
      return height;
    };
    PdfFontMetrics2.prototype.getSize = function(format) {
      var size = this.size;
      if (format != null) {
        switch (format.subSuperScript) {
          case PdfSubSuperScript.SubScript:
            size /= this.subScriptSizeFactor;
            break;
          case PdfSubSuperScript.SuperScript:
            size /= this.superscriptSizeFactor;
            break;
        }
      }
      return size;
    };
    PdfFontMetrics2.prototype.clone = function() {
      var metrics = this;
      metrics.widthTable = WidthTable.clone();
      return metrics;
    };
    Object.defineProperty(PdfFontMetrics2.prototype, "widthTable", {
      //  Properies
      /**
       * Gets or sets the `width table`.
       * @private
       */
      get: function() {
        return this.internalWidthTable;
      },
      set: function(value) {
        this.internalWidthTable = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfFontMetrics2;
  }()
);
var WidthTable = (
  /** @class */
  function() {
    function WidthTable2() {
    }
    WidthTable2.clone = function() {
      return null;
    };
    return WidthTable2;
  }()
);
var StandardWidthTable = (
  /** @class */
  function(_super) {
    __extends6(StandardWidthTable2, _super);
    function StandardWidthTable2(widths) {
      var _this = _super.call(this) || this;
      if (widths == null) {
        throw new Error("ArgumentNullException:widths");
      }
      _this.widths = widths;
      return _this;
    }
    StandardWidthTable2.prototype.items = function(index) {
      if (index < 0 || index >= this.widths.length) {
        throw new Error("ArgumentOutOfRangeException:index, The character is not supported by the font.");
      }
      var result = this.widths[index];
      return result;
    };
    Object.defineProperty(StandardWidthTable2.prototype, "length", {
      /**
       * Gets the `length` of the internal array.
       * @private
       */
      get: function() {
        return this.widths.length;
      },
      enumerable: true,
      configurable: true
    });
    StandardWidthTable2.prototype.clone = function() {
      var swt = this;
      swt.widths = this.widths;
      return swt;
    };
    StandardWidthTable2.prototype.toArray = function() {
      var arr = new PdfArray(this.widths);
      return arr;
    };
    return StandardWidthTable2;
  }(WidthTable)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/unicode-true-type-font.js
var UnicodeTrueTypeFont = (
  /** @class */
  function() {
    function UnicodeTrueTypeFont2(base64String, size) {
      this.nameString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      this.dictionaryProperties = new DictionaryProperties();
      this.isCompress = false;
      this.isEmbedFont = false;
      this.cmapPrefix = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap" + Operators.newLine + "/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange" + Operators.newLine;
      this.cmapEndCodespaceRange = "endcodespacerange" + Operators.newLine;
      this.cmapBeginRange = "beginbfrange" + Operators.newLine;
      this.cmapEndRange = "endbfrange" + Operators.newLine;
      this.cmapSuffix = "endbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend end" + Operators.newLine;
      if (base64String === null || base64String === void 0) {
        throw new Error("ArgumentNullException:base64String");
      }
      this.fontSize = size;
      this.fontString = base64String;
      this.Initialize();
    }
    UnicodeTrueTypeFont2.prototype.getCharWidth = function(charCode) {
      var codeWidth = this.ttfReader.getCharWidth(charCode);
      return codeWidth;
    };
    UnicodeTrueTypeFont2.prototype.getLineWidth = function(line) {
      var width = 0;
      for (var i = 0, len = line.length; i < len; i++) {
        var ch = line[i];
        var charWidth = this.getCharWidth(ch);
        width += charWidth;
      }
      return width;
    };
    UnicodeTrueTypeFont2.prototype.Initialize = function() {
      var byteArray = new ByteArray(this.fontString.length);
      byteArray.writeFromBase64String(this.fontString);
      this.fontData = byteArray.internalBuffer;
      this.ttfReader = new TtfReader(this.fontData);
      this.ttfMetrics = this.ttfReader.metrics;
    };
    UnicodeTrueTypeFont2.prototype.createInternals = function() {
      this.fontDictionary = new PdfDictionary();
      this.fontProgram = new PdfStream();
      this.cmap = new PdfStream();
      this.descendantFont = new PdfDictionary();
      this.metrics = new PdfFontMetrics();
      this.ttfReader.createInternals();
      this.ttfMetrics = this.ttfReader.metrics;
      this.initializeMetrics();
      this.subsetName = this.getFontName();
      this.createDescendantFont();
      this.createCmap();
      this.createFontDictionary();
      this.createFontProgram();
    };
    UnicodeTrueTypeFont2.prototype.getInternals = function() {
      return this.fontDictionary;
    };
    UnicodeTrueTypeFont2.prototype.initializeMetrics = function() {
      var ttfMetrics = this.ttfReader.metrics;
      this.metrics.ascent = ttfMetrics.macAscent;
      this.metrics.descent = ttfMetrics.macDescent;
      this.metrics.height = ttfMetrics.macAscent - ttfMetrics.macDescent + ttfMetrics.lineGap;
      this.metrics.name = ttfMetrics.fontFamily;
      this.metrics.postScriptName = ttfMetrics.postScriptName;
      this.metrics.size = this.fontSize;
      this.metrics.widthTable = new StandardWidthTable(ttfMetrics.widthTable);
      this.metrics.lineGap = ttfMetrics.lineGap;
      this.metrics.subScriptSizeFactor = ttfMetrics.subScriptSizeFactor;
      this.metrics.superscriptSizeFactor = ttfMetrics.superscriptSizeFactor;
      this.metrics.isBold = ttfMetrics.isBold;
    };
    UnicodeTrueTypeFont2.prototype.getFontName = function() {
      var builder = "";
      var name;
      for (var i = 0; i < 6; i++) {
        var index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;
        builder += this.nameString[index];
      }
      builder += "+";
      builder += this.ttfReader.metrics.postScriptName;
      name = builder.toString();
      name = this.formatName(name);
      return name;
    };
    UnicodeTrueTypeFont2.prototype.formatName = function(fontName) {
      var ret = fontName.replace("(", "#28");
      ret = ret.replace(")", "#29");
      ret = ret.replace("[", "#5B");
      ret = ret.replace("]", "#5D");
      ret = ret.replace("<", "#3C");
      ret = ret.replace(">", "#3E");
      ret = ret.replace("{", "#7B");
      ret = ret.replace("}", "#7D");
      ret = ret.replace("/", "#2F");
      ret = ret.replace("%", "#25");
      return ret.replace(" ", "#20");
    };
    UnicodeTrueTypeFont2.prototype.createDescendantFont = function() {
      this.descendantFont.isFont = true;
      this.descendantFont.descendantFontBeginSave = new SaveDescendantFontEventHandler(this);
      this.descendantFont.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
      this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType2));
      this.descendantFont.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));
      this.descendantFont.items.setValue(this.dictionaryProperties.cIDToGIDMap, new PdfName(this.dictionaryProperties.identity));
      this.descendantFont.items.setValue(this.dictionaryProperties.dw, new PdfNumber(1e3));
      this.fontDescriptor = this.createFontDescriptor();
      this.descendantFont.items.setValue(this.dictionaryProperties.fontDescriptor, new PdfReferenceHolder(this.fontDescriptor));
      var systemInfo = this.createSystemInfo();
      this.descendantFont.items.setValue(this.dictionaryProperties.cIDSystemInfo, systemInfo);
    };
    UnicodeTrueTypeFont2.prototype.createFontDescriptor = function() {
      var descriptor = new PdfDictionary();
      var metrics = this.ttfReader.metrics;
      descriptor.isFont = true;
      descriptor.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.fontDescriptor));
      descriptor.items.setValue(this.dictionaryProperties.fontName, new PdfName(this.subsetName));
      descriptor.items.setValue(this.dictionaryProperties.flags, new PdfNumber(this.getDescriptorFlags()));
      descriptor.items.setValue(this.dictionaryProperties.fontBBox, PdfArray.fromRectangle(this.getBoundBox()));
      descriptor.items.setValue(this.dictionaryProperties.missingWidth, new PdfNumber(metrics.widthTable[32]));
      descriptor.items.setValue(this.dictionaryProperties.stemV, new PdfNumber(metrics.stemV));
      descriptor.items.setValue(this.dictionaryProperties.italicAngle, new PdfNumber(metrics.italicAngle));
      descriptor.items.setValue(this.dictionaryProperties.capHeight, new PdfNumber(metrics.capHeight));
      descriptor.items.setValue(this.dictionaryProperties.ascent, new PdfNumber(metrics.winAscent));
      descriptor.items.setValue(this.dictionaryProperties.descent, new PdfNumber(metrics.winDescent));
      descriptor.items.setValue(this.dictionaryProperties.leading, new PdfNumber(metrics.leading));
      descriptor.items.setValue(this.dictionaryProperties.avgWidth, new PdfNumber(metrics.widthTable[32]));
      descriptor.items.setValue(this.dictionaryProperties.fontFile2, new PdfReferenceHolder(this.fontProgram));
      descriptor.items.setValue(this.dictionaryProperties.maxWidth, new PdfNumber(metrics.widthTable[32]));
      descriptor.items.setValue(this.dictionaryProperties.xHeight, new PdfNumber(0));
      descriptor.items.setValue(this.dictionaryProperties.stemH, new PdfNumber(0));
      return descriptor;
    };
    UnicodeTrueTypeFont2.prototype.createCmap = function() {
      this.cmap.cmapBeginSave = new SaveCmapEventHandler(this);
    };
    UnicodeTrueTypeFont2.prototype.createFontDictionary = function() {
      this.fontDictionary.isFont = true;
      this.fontDictionary.fontDictionaryBeginSave = new SaveFontDictionaryEventHandler(this);
      this.fontDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
      this.fontDictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));
      this.fontDictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type0));
      this.fontDictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(this.dictionaryProperties.identityH));
      var descFonts = new PdfArray();
      var reference = new PdfReferenceHolder(this.descendantFont);
      descFonts.isFont = true;
      descFonts.add(reference);
      this.fontDictionary.items.setValue(this.dictionaryProperties.descendantFonts, descFonts);
    };
    UnicodeTrueTypeFont2.prototype.createFontProgram = function() {
      this.fontProgram.fontProgramBeginSave = new SaveFontProgramEventHandler(this);
    };
    UnicodeTrueTypeFont2.prototype.createSystemInfo = function() {
      var systemInfo = new PdfDictionary();
      systemInfo.items.setValue(this.dictionaryProperties.registry, new PdfString("Adobe"));
      systemInfo.items.setValue(this.dictionaryProperties.ordering, new PdfString(this.dictionaryProperties.identity));
      systemInfo.items.setValue(this.dictionaryProperties.supplement, new PdfNumber(0));
      return systemInfo;
    };
    UnicodeTrueTypeFont2.prototype.descendantFontBeginSave = function() {
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0) {
        var width = this.getDescendantWidth();
        if (width !== null) {
          this.descendantFont.items.setValue(this.dictionaryProperties.w, width);
        }
      }
    };
    UnicodeTrueTypeFont2.prototype.cmapBeginSave = function() {
      this.generateCmap();
    };
    UnicodeTrueTypeFont2.prototype.fontDictionaryBeginSave = function() {
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0 && !this.fontDictionary.containsKey(this.dictionaryProperties.toUnicode)) {
        this.fontDictionary.items.setValue(this.dictionaryProperties.toUnicode, new PdfReferenceHolder(this.cmap));
      }
    };
    UnicodeTrueTypeFont2.prototype.fontProgramBeginSave = function() {
      this.isCompress = true;
      this.generateFontProgram();
    };
    UnicodeTrueTypeFont2.prototype.getDescendantWidth = function() {
      var array = new PdfArray();
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0) {
        var glyphInfo = [];
        var keys = this.usedChars.keys();
        for (var i = 0; i < keys.length; i++) {
          var chLen = keys[i];
          var glyph = this.ttfReader.getGlyph(chLen);
          if (glyph.empty) {
            continue;
          }
          glyphInfo.push(glyph);
        }
        glyphInfo.sort(function(a, b) {
          return a.index - b.index;
        });
        var firstGlyphIndex = 0;
        var lastGlyphIndex = 0;
        var firstGlyphIndexWasSet = false;
        var widthDetails = new PdfArray();
        for (var i = 0; i < glyphInfo.length; i++) {
          var glyph = glyphInfo[i];
          if (!firstGlyphIndexWasSet) {
            firstGlyphIndexWasSet = true;
            firstGlyphIndex = glyph.index;
            lastGlyphIndex = glyph.index - 1;
          }
          if ((lastGlyphIndex + 1 !== glyph.index || i + 1 === glyphInfo.length) && glyphInfo.length > 1) {
            array.add(new PdfNumber(firstGlyphIndex));
            if (i !== 0) {
              array.add(widthDetails);
            }
            firstGlyphIndex = glyph.index;
            widthDetails = new PdfArray();
          }
          widthDetails.add(new PdfNumber(glyph.width));
          if (i + 1 === glyphInfo.length) {
            array.add(new PdfNumber(firstGlyphIndex));
            array.add(widthDetails);
          }
          lastGlyphIndex = glyph.index;
        }
      }
      return array;
    };
    UnicodeTrueTypeFont2.prototype.generateCmap = function() {
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0) {
        var glyphChars = this.ttfReader.getGlyphChars(this.usedChars);
        if (glyphChars.size() > 0) {
          var keys = glyphChars.keys().sort();
          var first = keys[0];
          var last = keys[keys.length - 1];
          var middlePart = this.toHexString(first, false) + this.toHexString(last, false) + Operators.newLine;
          var builder = "";
          builder += this.cmapPrefix;
          builder += middlePart;
          builder += this.cmapEndCodespaceRange;
          var nextRange = 0;
          for (var i = 0; i < keys.length; i++) {
            if (nextRange === 0) {
              if (i !== 0) {
                builder += this.cmapEndRange;
              }
              nextRange = Math.min(100, keys.length - i);
              builder += nextRange;
              builder += Operators.whiteSpace;
              builder += this.cmapBeginRange;
            }
            nextRange -= 1;
            var key = keys[i];
            builder += this.toHexString(key, true) + this.toHexString(key, true) + this.toHexString(glyphChars.getValue(key), true) + "\n";
          }
          builder += this.cmapSuffix;
          this.cmap.clearStream();
          this.cmap.isFont = true;
          this.cmap.write(builder);
        }
      }
    };
    UnicodeTrueTypeFont2.prototype.generateFontProgram = function() {
      var fontProgram = null;
      this.usedChars = this.usedChars === null || this.usedChars === void 0 ? new Dictionary() : this.usedChars;
      this.ttfReader.setOffset(0);
      fontProgram = this.ttfReader.readFontProgram(this.usedChars);
      this.fontProgram.clearStream();
      this.fontProgram.isFont = true;
      this.fontProgram.writeBytes(fontProgram);
    };
    UnicodeTrueTypeFont2.prototype.getDescriptorFlags = function() {
      var flags = 0;
      var metrics = this.ttfReader.metrics;
      if (metrics.isFixedPitch) {
        flags |= FontDescriptorFlags.FixedPitch;
      }
      if (metrics.isSymbol) {
        flags |= FontDescriptorFlags.Symbolic;
      } else {
        flags |= FontDescriptorFlags.Nonsymbolic;
      }
      if (metrics.isItalic) {
        flags |= FontDescriptorFlags.Italic;
      }
      if (metrics.isBold) {
        flags |= FontDescriptorFlags.ForceBold;
      }
      return flags;
    };
    UnicodeTrueTypeFont2.prototype.getBoundBox = function() {
      var rect = this.ttfReader.metrics.fontBox;
      var width = Math.abs(rect.right - rect.left);
      var height = Math.abs(rect.top - rect.bottom);
      var rectangle = new RectangleF(rect.left, rect.bottom, width, height);
      return rectangle;
    };
    UnicodeTrueTypeFont2.prototype.toHexString = function(n, isCaseChange) {
      var s = n.toString(16);
      if (isCaseChange) {
        s = s.toUpperCase();
      }
      return "<0000".substring(0, 5 - s.length) + s + ">";
    };
    UnicodeTrueTypeFont2.prototype.setSymbols = function(text) {
      if (text === null) {
        throw new Error("Argument Null Exception : text");
      }
      if (this.usedChars === null || this.usedChars === void 0) {
        this.usedChars = new Dictionary();
      }
      for (var i = 0; i < text.length; i++) {
        var ch = text[i];
        this.usedChars.setValue(ch, String.fromCharCode(0));
      }
      if (this.isEmbedFont === false) {
        this.getDescendantWidth();
      }
    };
    return UnicodeTrueTypeFont2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl/rtl-text-shape.js
var ArabicShapeRenderer = (
  /** @class */
  function() {
    function ArabicShapeRenderer2() {
      this.arabicCharTable = [
        ["ء", "ﺀ"],
        ["آ", "ﺁ", "ﺂ"],
        ["أ", "ﺃ", "ﺄ"],
        ["ؤ", "ﺅ", "ﺆ"],
        ["إ", "ﺇ", "ﺈ"],
        ["ئ", "ﺉ", "ﺊ", "ﺋ", "ﺌ"],
        ["ا", "ﺍ", "ﺎ"],
        ["ب", "ﺏ", "ﺐ", "ﺑ", "ﺒ"],
        ["ة", "ﺓ", "ﺔ"],
        ["ت", "ﺕ", "ﺖ", "ﺗ", "ﺘ"],
        ["ث", "ﺙ", "ﺚ", "ﺛ", "ﺜ"],
        ["ج", "ﺝ", "ﺞ", "ﺟ", "ﺠ"],
        ["ح", "ﺡ", "ﺢ", "ﺣ", "ﺤ"],
        ["خ", "ﺥ", "ﺦ", "ﺧ", "ﺨ"],
        ["د", "ﺩ", "ﺪ"],
        ["ذ", "ﺫ", "ﺬ"],
        ["ر", "ﺭ", "ﺮ"],
        ["ز", "ﺯ", "ﺰ"],
        ["س", "ﺱ", "ﺲ", "ﺳ", "ﺴ"],
        ["ش", "ﺵ", "ﺶ", "ﺷ", "ﺸ"],
        ["ص", "ﺹ", "ﺺ", "ﺻ", "ﺼ"],
        ["ض", "ﺽ", "ﺾ", "ﺿ", "ﻀ"],
        ["ط", "ﻁ", "ﻂ", "ﻃ", "ﻄ"],
        ["ظ", "ﻅ", "ﻆ", "ﻇ", "ﻈ"],
        ["ع", "ﻉ", "ﻊ", "ﻋ", "ﻌ"],
        ["غ", "ﻍ", "ﻎ", "ﻏ", "ﻐ"],
        ["ـ", "ـ", "ـ", "ـ", "ـ"],
        ["ف", "ﻑ", "ﻒ", "ﻓ", "ﻔ"],
        ["ق", "ﻕ", "ﻖ", "ﻗ", "ﻘ"],
        ["ك", "ﻙ", "ﻚ", "ﻛ", "ﻜ"],
        ["ل", "ﻝ", "ﻞ", "ﻟ", "ﻠ"],
        ["م", "ﻡ", "ﻢ", "ﻣ", "ﻤ"],
        ["ن", "ﻥ", "ﻦ", "ﻧ", "ﻨ"],
        ["ه", "ﻩ", "ﻪ", "ﻫ", "ﻬ"],
        ["و", "ﻭ", "ﻮ"],
        ["ى", "ﻯ", "ﻰ", "ﯨ", "ﯩ"],
        ["ي", "ﻱ", "ﻲ", "ﻳ", "ﻴ"],
        ["ٱ", "ﭐ", "ﭑ"],
        ["ٹ", "ﭦ", "ﭧ", "ﭨ", "ﭩ"],
        ["ٺ", "ﭞ", "ﭟ", "ﭠ", "ﭡ"],
        ["ٻ", "ﭒ", "ﭓ", "ﭔ", "ﭕ"],
        ["پ", "ﭖ", "ﭗ", "ﭘ", "ﭙ"],
        ["ٿ", "ﭢ", "ﭣ", "ﭤ", "ﭥ"],
        ["ڀ", "ﭚ", "ﭛ", "ﭜ", "ﭝ"],
        ["ڃ", "ﭶ", "ﭷ", "ﭸ", "ﭹ"],
        ["ڄ", "ﭲ", "ﭳ", "ﭴ", "ﭵ"],
        ["چ", "ﭺ", "ﭻ", "ﭼ", "ﭽ"],
        ["ڇ", "ﭾ", "ﭿ", "ﮀ", "ﮁ"],
        ["ڈ", "ﮈ", "ﮉ"],
        ["ڌ", "ﮄ", "ﮅ"],
        ["ڍ", "ﮂ", "ﮃ"],
        ["ڎ", "ﮆ", "ﮇ"],
        ["ڑ", "ﮌ", "ﮍ"],
        ["ژ", "ﮊ", "ﮋ"],
        ["ڤ", "ﭪ", "ﭫ", "ﭬ", "ﭭ"],
        ["ڦ", "ﭮ", "ﭯ", "ﭰ", "ﭱ"],
        ["ک", "ﮎ", "ﮏ", "ﮐ", "ﮑ"],
        ["ڭ", "ﯓ", "ﯔ", "ﯕ", "ﯖ"],
        ["گ", "ﮒ", "ﮓ", "ﮔ", "ﮕ"],
        ["ڱ", "ﮚ", "ﮛ", "ﮜ", "ﮝ"],
        ["ڳ", "ﮖ", "ﮗ", "ﮘ", "ﮙ"],
        ["ں", "ﮞ", "ﮟ"],
        ["ڻ", "ﮠ", "ﮡ", "ﮢ", "ﮣ"],
        ["ھ", "ﮪ", "ﮫ", "ﮬ", "ﮭ"],
        ["ۀ", "ﮤ", "ﮥ"],
        ["ہ", "ﮦ", "ﮧ", "ﮨ", "ﮩ"],
        ["ۅ", "ﯠ", "ﯡ"],
        ["ۆ", "ﯙ", "ﯚ"],
        ["ۇ", "ﯗ", "ﯘ"],
        ["ۈ", "ﯛ", "ﯜ"],
        ["ۉ", "ﯢ", "ﯣ"],
        ["ۋ", "ﯞ", "ﯟ"],
        ["ی", "ﯼ", "ﯽ", "ﯾ", "ﯿ"],
        ["ې", "ﯤ", "ﯥ", "ﯦ", "ﯧ"],
        ["ے", "ﮮ", "ﮯ"],
        ["ۓ", "ﮰ", "ﮱ"]
      ];
      this.alef = "ا";
      this.alefHamza = "أ";
      this.alefHamzaBelow = "إ";
      this.alefMadda = "آ";
      this.lam = "ل";
      this.hamza = "ء";
      this.zeroWidthJoiner = "‍";
      this.hamzaAbove = "ٔ";
      this.hamzaBelow = "ٕ";
      this.wawHamza = "ؤ";
      this.yehHamza = "ئ";
      this.waw = "و";
      this.alefMaksura = "ى";
      this.yeh = "ي";
      this.farsiYeh = "ی";
      this.shadda = "ّ";
      this.madda = "ٓ";
      this.lwa = "ﻻ";
      this.lwawh = "ﻷ";
      this.lwawhb = "ﻹ";
      this.lwawm = "ﻵ";
      this.bwhb = "ۓ";
      this.fathatan = "ً";
      this.superScriptalef = "ٰ";
      this.vowel = 1;
      this.arabicMapTable = new Dictionary();
      for (var i = 0; i < this.arabicCharTable.length; i++) {
        this.arabicMapTable.setValue(this.arabicCharTable[i][0], this.arabicCharTable[i]);
      }
    }
    ArabicShapeRenderer2.prototype.getCharacterShape = function(input, index) {
      if (input >= this.hamza && input <= this.bwhb) {
        var value = [];
        if (this.arabicMapTable.getValue(input)) {
          value = this.arabicMapTable.getValue(input);
          return value[index + 1];
        }
      } else if (input >= this.lwawm && input <= this.lwa) {
        return input;
      }
      return input;
    };
    ArabicShapeRenderer2.prototype.shape = function(text, level) {
      var builder = "";
      var str2 = "";
      for (var i = 0; i < text.length; i++) {
        var c = text[i];
        if (c >= "؀" && c <= "ۿ") {
          str2 = str2 + c;
        } else {
          if (str2.length > 0) {
            var st = this.doShape(str2.toString(), 0);
            builder = builder + st;
            str2 = "";
          }
          builder = builder + c;
        }
      }
      if (str2.length > 0) {
        var st = this.doShape(str2.toString(), 0);
        builder = builder + st;
      }
      return builder.toString();
    };
    ArabicShapeRenderer2.prototype.doShape = function(input, level) {
      var str = "";
      var ligature = 0;
      var len = 0;
      var i = 0;
      var next = "";
      var previous = new ArabicShape();
      var present = new ArabicShape();
      while (i < input.length) {
        next = input[i++];
        ligature = this.ligature(next, present);
        if (ligature === 0) {
          var shapeCount = this.getShapeCount(next);
          len = shapeCount === 1 ? 0 : 2;
          if (previous.Shapes > 2) {
            len += 1;
          }
          len = len % present.Shapes;
          present.Value = this.getCharacterShape(present.Value, len);
          str = this.append(str, previous, level);
          previous = present;
          present = new ArabicShape();
          present.Value = next;
          present.Shapes = shapeCount;
          present.Ligature++;
        }
      }
      len = previous.Shapes > 2 ? 1 : 0;
      len = len % present.Shapes;
      present.Value = this.getCharacterShape(present.Value, len);
      str = this.append(str, previous, level);
      str = this.append(str, present, level);
      return str.toString();
    };
    ArabicShapeRenderer2.prototype.append = function(builder, shape, level) {
      if (shape.Value !== "") {
        builder = builder + shape.Value;
        shape.Ligature -= 1;
        if (shape.Type !== "") {
          if ((level & this.vowel) === 0) {
            builder = builder + shape.Type;
            shape.Ligature -= 1;
          } else {
            shape.Ligature -= 1;
          }
        }
        if (shape.vowel !== "") {
          if ((level & this.vowel) === 0) {
            builder = builder + shape.vowel;
            shape.Ligature -= 1;
          } else {
            shape.Ligature -= 1;
          }
        }
      }
      return builder;
    };
    ArabicShapeRenderer2.prototype.ligature = function(value, shape) {
      if (shape.Value !== "") {
        var result = 0;
        if (value >= this.fathatan && value <= this.hamzaBelow || value === this.superScriptalef) {
          result = 1;
          if (shape.vowel !== "" && value !== this.shadda) {
            result = 2;
          }
          if (value === this.shadda) {
            if (shape.Type == null) {
              shape.Type = this.shadda;
            } else {
              return 0;
            }
          } else if (value === this.hamzaBelow) {
            if (shape.Value === this.alef) {
              shape.Value = this.alefHamzaBelow;
              result = 2;
            } else if (value === this.lwa) {
              shape.Value = this.lwawhb;
              result = 2;
            } else {
              shape.Type = this.hamzaBelow;
            }
          } else if (value === this.hamzaAbove) {
            if (shape.Value === this.alef) {
              shape.Value = this.alefHamza;
              result = 2;
            } else if (shape.Value === this.lwa) {
              shape.Value = this.lwawh;
              result = 2;
            } else if (shape.Value === this.waw) {
              shape.Value = this.wawHamza;
              result = 2;
            } else if (shape.Value === this.yeh || shape.Value === this.alefMaksura || shape.Value === this.farsiYeh) {
              shape.Value = this.yehHamza;
              result = 2;
            } else {
              shape.Type = this.hamzaAbove;
            }
          } else if (value === this.madda) {
            if (shape.Value === this.alef) {
              shape.Value = this.alefMadda;
              result = 2;
            }
          } else {
            shape.vowel = value;
          }
          if (result === 1) {
            shape.Ligature++;
          }
          return result;
        }
        if (shape.vowel !== "") {
          return 0;
        }
        if (shape.Value === this.lam) {
          if (value === this.alef) {
            shape.Value = this.lwa;
            shape.Shapes = 2;
            result = 3;
          } else if (value === this.alefHamza) {
            shape.Value = this.lwawh;
            shape.Shapes = 2;
            result = 3;
          } else if (value === this.alefHamzaBelow) {
            shape.Value = this.lwawhb;
            shape.Shapes = 2;
            result = 3;
          } else if (value === this.alefMadda) {
            shape.Value = this.lwawm;
            shape.Shapes = 2;
            result = 3;
          }
        }
        return result;
      } else {
        return 0;
      }
    };
    ArabicShapeRenderer2.prototype.getShapeCount = function(shape) {
      if (shape >= this.hamza && shape <= this.bwhb && !(shape >= this.fathatan && shape <= this.hamzaBelow || shape === this.superScriptalef)) {
        var c = [];
        if (this.arabicMapTable.getValue(shape)) {
          c = this.arabicMapTable.getValue(shape);
          return c.length - 1;
        }
      } else if (shape === this.zeroWidthJoiner) {
        return 4;
      }
      return 1;
    };
    return ArabicShapeRenderer2;
  }()
);
var ArabicShape = (
  /** @class */
  function() {
    function ArabicShape2() {
      this.shapeValue = "";
      this.shapeType = "";
      this.shapeVowel = "";
      this.shapeLigature = 0;
      this.shapeShapes = 1;
    }
    Object.defineProperty(ArabicShape2.prototype, "Value", {
      //#endregion
      //#region Properties 
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeValue;
      },
      set: function(value) {
        this.shapeValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "Type", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeType;
      },
      set: function(value) {
        this.shapeType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "vowel", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeVowel;
      },
      set: function(value) {
        this.shapeVowel = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "Ligature", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeLigature;
      },
      set: function(value) {
        this.shapeLigature = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "Shapes", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeShapes;
      },
      set: function(value) {
        this.shapeShapes = value;
      },
      enumerable: true,
      configurable: true
    });
    return ArabicShape2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl/rtl-bidirectional.js
var Bidi = (
  /** @class */
  function() {
    function Bidi2() {
      this.indexes = [];
      this.indexLevels = [];
      this.mirroringShapeCharacters = new Dictionary();
      this.update();
    }
    Bidi2.prototype.doMirrorShaping = function(text) {
      var result = [];
      for (var i = 0; i < text.length; i++) {
        if ((this.indexLevels[i] & 1) === 1 && this.mirroringShapeCharacters.containsKey(text[i].charCodeAt(0))) {
          result[i] = String.fromCharCode(this.mirroringShapeCharacters.getValue(text[i].charCodeAt(0)));
        } else {
          result[i] = text[i].toString();
        }
      }
      var res = "";
      for (var j = 0; j < result.length; j++) {
        res = res + result[j];
      }
      return res;
    };
    Bidi2.prototype.getLogicalToVisualString = function(inputText, isRtl) {
      var rtlCharacters = new RtlCharacters();
      this.indexLevels = rtlCharacters.getVisualOrder(inputText, isRtl);
      this.setDefaultIndexLevel();
      this.doOrder(0, this.indexLevels.length - 1);
      var text = this.doMirrorShaping(inputText);
      var resultBuilder = "";
      for (var i = 0; i < this.indexes.length; i++) {
        var index = this.indexes[i];
        resultBuilder += text[index];
      }
      return resultBuilder.toString();
    };
    Bidi2.prototype.setDefaultIndexLevel = function() {
      for (var i = 0; i < this.indexLevels.length; i++) {
        this.indexes[i] = i;
      }
    };
    Bidi2.prototype.doOrder = function(sIndex, eIndex) {
      var max = this.indexLevels[sIndex];
      var min = max;
      var odd = max;
      var even = max;
      for (var i = sIndex + 1; i <= eIndex; ++i) {
        var data = this.indexLevels[i];
        if (data > max) {
          max = data;
        } else if (data < min) {
          min = data;
        }
        odd &= data;
        even |= data;
      }
      if ((even & 1) === 0) {
        return;
      }
      if ((odd & 1) === 1) {
        this.reArrange(sIndex, eIndex + 1);
        return;
      }
      min |= 1;
      while (max >= min) {
        var pstart = sIndex;
        while (true) {
          while (pstart <= eIndex) {
            if (this.indexLevels[pstart] >= max) {
              break;
            }
            pstart += 1;
          }
          if (pstart > eIndex) {
            break;
          }
          var pend = pstart + 1;
          while (pend <= eIndex) {
            if (this.indexLevels[pend] < max) {
              break;
            }
            pend += 1;
          }
          this.reArrange(pstart, pend);
          pstart = pend + 1;
        }
        max -= 1;
      }
    };
    Bidi2.prototype.reArrange = function(i, j) {
      var length = (i + j) / 2;
      --j;
      for (; i < length; ++i, --j) {
        var temp = this.indexes[i];
        this.indexes[i] = this.indexes[j];
        this.indexes[j] = temp;
      }
    };
    Bidi2.prototype.update = function() {
      this.mirroringShapeCharacters.setValue(40, 41);
      this.mirroringShapeCharacters.setValue(41, 40);
      this.mirroringShapeCharacters.setValue(60, 62);
      this.mirroringShapeCharacters.setValue(62, 60);
      this.mirroringShapeCharacters.setValue(91, 93);
      this.mirroringShapeCharacters.setValue(93, 91);
      this.mirroringShapeCharacters.setValue(123, 125);
      this.mirroringShapeCharacters.setValue(125, 123);
      this.mirroringShapeCharacters.setValue(171, 187);
      this.mirroringShapeCharacters.setValue(187, 171);
      this.mirroringShapeCharacters.setValue(8249, 8250);
      this.mirroringShapeCharacters.setValue(8250, 8249);
      this.mirroringShapeCharacters.setValue(8261, 8262);
      this.mirroringShapeCharacters.setValue(8262, 8261);
      this.mirroringShapeCharacters.setValue(8317, 8318);
      this.mirroringShapeCharacters.setValue(8318, 8317);
      this.mirroringShapeCharacters.setValue(8333, 8334);
      this.mirroringShapeCharacters.setValue(8334, 8333);
      this.mirroringShapeCharacters.setValue(8712, 8715);
      this.mirroringShapeCharacters.setValue(8713, 8716);
      this.mirroringShapeCharacters.setValue(8714, 8717);
      this.mirroringShapeCharacters.setValue(8715, 8712);
      this.mirroringShapeCharacters.setValue(8716, 8713);
      this.mirroringShapeCharacters.setValue(8717, 8714);
      this.mirroringShapeCharacters.setValue(8725, 10741);
      this.mirroringShapeCharacters.setValue(8764, 8765);
      this.mirroringShapeCharacters.setValue(8765, 8764);
      this.mirroringShapeCharacters.setValue(8771, 8909);
      this.mirroringShapeCharacters.setValue(8786, 8787);
      this.mirroringShapeCharacters.setValue(8787, 8786);
      this.mirroringShapeCharacters.setValue(8788, 8789);
      this.mirroringShapeCharacters.setValue(8789, 8788);
      this.mirroringShapeCharacters.setValue(8804, 8805);
      this.mirroringShapeCharacters.setValue(8805, 8804);
      this.mirroringShapeCharacters.setValue(8806, 8807);
      this.mirroringShapeCharacters.setValue(8807, 8806);
      this.mirroringShapeCharacters.setValue(8808, 8809);
      this.mirroringShapeCharacters.setValue(8809, 8808);
      this.mirroringShapeCharacters.setValue(8810, 8811);
      this.mirroringShapeCharacters.setValue(8811, 8810);
      this.mirroringShapeCharacters.setValue(8814, 8815);
      this.mirroringShapeCharacters.setValue(8815, 8814);
      this.mirroringShapeCharacters.setValue(8816, 8817);
      this.mirroringShapeCharacters.setValue(8817, 8816);
      this.mirroringShapeCharacters.setValue(8818, 8819);
      this.mirroringShapeCharacters.setValue(8819, 8818);
      this.mirroringShapeCharacters.setValue(8820, 8821);
      this.mirroringShapeCharacters.setValue(8821, 8820);
      this.mirroringShapeCharacters.setValue(8822, 8823);
      this.mirroringShapeCharacters.setValue(8823, 8822);
      this.mirroringShapeCharacters.setValue(8824, 8825);
      this.mirroringShapeCharacters.setValue(8825, 8824);
      this.mirroringShapeCharacters.setValue(8826, 8827);
      this.mirroringShapeCharacters.setValue(8827, 8826);
      this.mirroringShapeCharacters.setValue(8828, 8829);
      this.mirroringShapeCharacters.setValue(8829, 8828);
      this.mirroringShapeCharacters.setValue(8830, 8831);
      this.mirroringShapeCharacters.setValue(8831, 8830);
      this.mirroringShapeCharacters.setValue(8832, 8833);
      this.mirroringShapeCharacters.setValue(8833, 8832);
      this.mirroringShapeCharacters.setValue(8834, 8835);
      this.mirroringShapeCharacters.setValue(8835, 8834);
      this.mirroringShapeCharacters.setValue(8836, 8837);
      this.mirroringShapeCharacters.setValue(8837, 8836);
      this.mirroringShapeCharacters.setValue(8838, 8839);
      this.mirroringShapeCharacters.setValue(8839, 8838);
      this.mirroringShapeCharacters.setValue(8840, 8841);
      this.mirroringShapeCharacters.setValue(8841, 8840);
      this.mirroringShapeCharacters.setValue(8842, 8843);
      this.mirroringShapeCharacters.setValue(8843, 8842);
      this.mirroringShapeCharacters.setValue(8847, 8848);
      this.mirroringShapeCharacters.setValue(8848, 8847);
      this.mirroringShapeCharacters.setValue(8849, 8850);
      this.mirroringShapeCharacters.setValue(8850, 8849);
      this.mirroringShapeCharacters.setValue(8856, 10680);
      this.mirroringShapeCharacters.setValue(8866, 8867);
      this.mirroringShapeCharacters.setValue(8867, 8866);
      this.mirroringShapeCharacters.setValue(8870, 10974);
      this.mirroringShapeCharacters.setValue(8872, 10980);
      this.mirroringShapeCharacters.setValue(8873, 10979);
      this.mirroringShapeCharacters.setValue(8875, 10981);
      this.mirroringShapeCharacters.setValue(8880, 8881);
      this.mirroringShapeCharacters.setValue(8881, 8880);
      this.mirroringShapeCharacters.setValue(8882, 8883);
      this.mirroringShapeCharacters.setValue(8883, 8882);
      this.mirroringShapeCharacters.setValue(8884, 8885);
      this.mirroringShapeCharacters.setValue(8885, 8884);
      this.mirroringShapeCharacters.setValue(8886, 8887);
      this.mirroringShapeCharacters.setValue(8887, 8886);
      this.mirroringShapeCharacters.setValue(8905, 8906);
      this.mirroringShapeCharacters.setValue(8906, 8905);
      this.mirroringShapeCharacters.setValue(8907, 8908);
      this.mirroringShapeCharacters.setValue(8908, 8907);
      this.mirroringShapeCharacters.setValue(8909, 8771);
      this.mirroringShapeCharacters.setValue(8912, 8913);
      this.mirroringShapeCharacters.setValue(8913, 8912);
      this.mirroringShapeCharacters.setValue(8918, 8919);
      this.mirroringShapeCharacters.setValue(8919, 8918);
      this.mirroringShapeCharacters.setValue(8920, 8921);
      this.mirroringShapeCharacters.setValue(8921, 8920);
      this.mirroringShapeCharacters.setValue(8922, 8923);
      this.mirroringShapeCharacters.setValue(8923, 8922);
      this.mirroringShapeCharacters.setValue(8924, 8925);
      this.mirroringShapeCharacters.setValue(8925, 8924);
      this.mirroringShapeCharacters.setValue(8926, 8927);
      this.mirroringShapeCharacters.setValue(8927, 8926);
      this.mirroringShapeCharacters.setValue(8928, 8929);
      this.mirroringShapeCharacters.setValue(8929, 8928);
      this.mirroringShapeCharacters.setValue(8930, 8931);
      this.mirroringShapeCharacters.setValue(8931, 8930);
      this.mirroringShapeCharacters.setValue(8932, 8933);
      this.mirroringShapeCharacters.setValue(8933, 8932);
      this.mirroringShapeCharacters.setValue(8934, 8935);
      this.mirroringShapeCharacters.setValue(8935, 8934);
      this.mirroringShapeCharacters.setValue(8936, 8937);
      this.mirroringShapeCharacters.setValue(8937, 8936);
      this.mirroringShapeCharacters.setValue(8938, 8939);
      this.mirroringShapeCharacters.setValue(8939, 8938);
      this.mirroringShapeCharacters.setValue(8940, 8941);
      this.mirroringShapeCharacters.setValue(8941, 8940);
      this.mirroringShapeCharacters.setValue(8944, 8945);
      this.mirroringShapeCharacters.setValue(8945, 8944);
      this.mirroringShapeCharacters.setValue(8946, 8954);
      this.mirroringShapeCharacters.setValue(8947, 8955);
      this.mirroringShapeCharacters.setValue(8948, 8956);
      this.mirroringShapeCharacters.setValue(8950, 8957);
      this.mirroringShapeCharacters.setValue(8951, 8958);
      this.mirroringShapeCharacters.setValue(8954, 8946);
      this.mirroringShapeCharacters.setValue(8955, 8947);
      this.mirroringShapeCharacters.setValue(8956, 8948);
      this.mirroringShapeCharacters.setValue(8957, 8950);
      this.mirroringShapeCharacters.setValue(8958, 8951);
      this.mirroringShapeCharacters.setValue(8968, 8969);
      this.mirroringShapeCharacters.setValue(8969, 8968);
      this.mirroringShapeCharacters.setValue(8970, 8971);
      this.mirroringShapeCharacters.setValue(8971, 8970);
      this.mirroringShapeCharacters.setValue(9001, 9002);
      this.mirroringShapeCharacters.setValue(9002, 9001);
      this.mirroringShapeCharacters.setValue(10088, 10089);
      this.mirroringShapeCharacters.setValue(10089, 10088);
      this.mirroringShapeCharacters.setValue(10090, 10091);
      this.mirroringShapeCharacters.setValue(10091, 10090);
      this.mirroringShapeCharacters.setValue(10092, 10093);
      this.mirroringShapeCharacters.setValue(10093, 10092);
      this.mirroringShapeCharacters.setValue(10094, 10095);
      this.mirroringShapeCharacters.setValue(10095, 10094);
      this.mirroringShapeCharacters.setValue(10096, 10097);
      this.mirroringShapeCharacters.setValue(10097, 10096);
      this.mirroringShapeCharacters.setValue(10098, 10099);
      this.mirroringShapeCharacters.setValue(10099, 10098);
      this.mirroringShapeCharacters.setValue(10100, 10101);
      this.mirroringShapeCharacters.setValue(10101, 10100);
      this.mirroringShapeCharacters.setValue(10197, 10198);
      this.mirroringShapeCharacters.setValue(10198, 10197);
      this.mirroringShapeCharacters.setValue(10205, 10206);
      this.mirroringShapeCharacters.setValue(10206, 10205);
      this.mirroringShapeCharacters.setValue(10210, 10211);
      this.mirroringShapeCharacters.setValue(10211, 10210);
      this.mirroringShapeCharacters.setValue(10212, 10213);
      this.mirroringShapeCharacters.setValue(10213, 10212);
      this.mirroringShapeCharacters.setValue(10214, 10215);
      this.mirroringShapeCharacters.setValue(10215, 10214);
      this.mirroringShapeCharacters.setValue(10216, 10217);
      this.mirroringShapeCharacters.setValue(10217, 10216);
      this.mirroringShapeCharacters.setValue(10218, 10219);
      this.mirroringShapeCharacters.setValue(10219, 10218);
      this.mirroringShapeCharacters.setValue(10627, 10628);
      this.mirroringShapeCharacters.setValue(10628, 10627);
      this.mirroringShapeCharacters.setValue(10629, 10630);
      this.mirroringShapeCharacters.setValue(10630, 10629);
      this.mirroringShapeCharacters.setValue(10631, 10632);
      this.mirroringShapeCharacters.setValue(10632, 10631);
      this.mirroringShapeCharacters.setValue(10633, 10634);
      this.mirroringShapeCharacters.setValue(10634, 10633);
      this.mirroringShapeCharacters.setValue(10635, 10636);
      this.mirroringShapeCharacters.setValue(10636, 10635);
      this.mirroringShapeCharacters.setValue(10637, 10640);
      this.mirroringShapeCharacters.setValue(10638, 10639);
      this.mirroringShapeCharacters.setValue(10639, 10638);
      this.mirroringShapeCharacters.setValue(10640, 10637);
      this.mirroringShapeCharacters.setValue(10641, 10642);
      this.mirroringShapeCharacters.setValue(10642, 10641);
      this.mirroringShapeCharacters.setValue(10643, 10644);
      this.mirroringShapeCharacters.setValue(10644, 10643);
      this.mirroringShapeCharacters.setValue(10645, 10646);
      this.mirroringShapeCharacters.setValue(10646, 10645);
      this.mirroringShapeCharacters.setValue(10647, 10648);
      this.mirroringShapeCharacters.setValue(10648, 10647);
      this.mirroringShapeCharacters.setValue(10680, 8856);
      this.mirroringShapeCharacters.setValue(10688, 10689);
      this.mirroringShapeCharacters.setValue(10689, 10688);
      this.mirroringShapeCharacters.setValue(10692, 10693);
      this.mirroringShapeCharacters.setValue(10693, 10692);
      this.mirroringShapeCharacters.setValue(10703, 10704);
      this.mirroringShapeCharacters.setValue(10704, 10703);
      this.mirroringShapeCharacters.setValue(10705, 10706);
      this.mirroringShapeCharacters.setValue(10706, 10705);
      this.mirroringShapeCharacters.setValue(10708, 10709);
      this.mirroringShapeCharacters.setValue(10709, 10708);
      this.mirroringShapeCharacters.setValue(10712, 10713);
      this.mirroringShapeCharacters.setValue(10713, 10712);
      this.mirroringShapeCharacters.setValue(10714, 10715);
      this.mirroringShapeCharacters.setValue(10715, 10714);
      this.mirroringShapeCharacters.setValue(10741, 8725);
      this.mirroringShapeCharacters.setValue(10744, 10745);
      this.mirroringShapeCharacters.setValue(10745, 10744);
      this.mirroringShapeCharacters.setValue(10748, 10749);
      this.mirroringShapeCharacters.setValue(10749, 10748);
      this.mirroringShapeCharacters.setValue(10795, 10796);
      this.mirroringShapeCharacters.setValue(10796, 10795);
      this.mirroringShapeCharacters.setValue(10797, 10796);
      this.mirroringShapeCharacters.setValue(10798, 10797);
      this.mirroringShapeCharacters.setValue(10804, 10805);
      this.mirroringShapeCharacters.setValue(10805, 10804);
      this.mirroringShapeCharacters.setValue(10812, 10813);
      this.mirroringShapeCharacters.setValue(10813, 10812);
      this.mirroringShapeCharacters.setValue(10852, 10853);
      this.mirroringShapeCharacters.setValue(10853, 10852);
      this.mirroringShapeCharacters.setValue(10873, 10874);
      this.mirroringShapeCharacters.setValue(10874, 10873);
      this.mirroringShapeCharacters.setValue(10877, 10878);
      this.mirroringShapeCharacters.setValue(10878, 10877);
      this.mirroringShapeCharacters.setValue(10879, 10880);
      this.mirroringShapeCharacters.setValue(10880, 10879);
      this.mirroringShapeCharacters.setValue(10881, 10882);
      this.mirroringShapeCharacters.setValue(10882, 10881);
      this.mirroringShapeCharacters.setValue(10883, 10884);
      this.mirroringShapeCharacters.setValue(10884, 10883);
      this.mirroringShapeCharacters.setValue(10891, 10892);
      this.mirroringShapeCharacters.setValue(10892, 10891);
      this.mirroringShapeCharacters.setValue(10897, 10898);
      this.mirroringShapeCharacters.setValue(10898, 10897);
      this.mirroringShapeCharacters.setValue(10899, 10900);
      this.mirroringShapeCharacters.setValue(10900, 10899);
      this.mirroringShapeCharacters.setValue(10901, 10902);
      this.mirroringShapeCharacters.setValue(10902, 10901);
      this.mirroringShapeCharacters.setValue(10903, 10904);
      this.mirroringShapeCharacters.setValue(10904, 10903);
      this.mirroringShapeCharacters.setValue(10905, 10906);
      this.mirroringShapeCharacters.setValue(10906, 10905);
      this.mirroringShapeCharacters.setValue(10907, 10908);
      this.mirroringShapeCharacters.setValue(10908, 10907);
      this.mirroringShapeCharacters.setValue(10913, 10914);
      this.mirroringShapeCharacters.setValue(10914, 10913);
      this.mirroringShapeCharacters.setValue(10918, 10919);
      this.mirroringShapeCharacters.setValue(10919, 10918);
      this.mirroringShapeCharacters.setValue(10920, 10921);
      this.mirroringShapeCharacters.setValue(10921, 10920);
      this.mirroringShapeCharacters.setValue(10922, 10923);
      this.mirroringShapeCharacters.setValue(10923, 10922);
      this.mirroringShapeCharacters.setValue(10924, 10925);
      this.mirroringShapeCharacters.setValue(10925, 10924);
      this.mirroringShapeCharacters.setValue(10927, 10928);
      this.mirroringShapeCharacters.setValue(10928, 10927);
      this.mirroringShapeCharacters.setValue(10931, 10932);
      this.mirroringShapeCharacters.setValue(10932, 10931);
      this.mirroringShapeCharacters.setValue(10939, 10940);
      this.mirroringShapeCharacters.setValue(10940, 10939);
      this.mirroringShapeCharacters.setValue(10941, 10942);
      this.mirroringShapeCharacters.setValue(10942, 10941);
      this.mirroringShapeCharacters.setValue(10943, 10944);
      this.mirroringShapeCharacters.setValue(10944, 10943);
      this.mirroringShapeCharacters.setValue(10945, 10946);
      this.mirroringShapeCharacters.setValue(10946, 10945);
      this.mirroringShapeCharacters.setValue(10947, 10948);
      this.mirroringShapeCharacters.setValue(10948, 10947);
      this.mirroringShapeCharacters.setValue(10949, 10950);
      this.mirroringShapeCharacters.setValue(10950, 10949);
      this.mirroringShapeCharacters.setValue(10957, 10958);
      this.mirroringShapeCharacters.setValue(10958, 10957);
      this.mirroringShapeCharacters.setValue(10959, 10960);
      this.mirroringShapeCharacters.setValue(10960, 10959);
      this.mirroringShapeCharacters.setValue(10961, 10962);
      this.mirroringShapeCharacters.setValue(10962, 10961);
      this.mirroringShapeCharacters.setValue(10963, 10964);
      this.mirroringShapeCharacters.setValue(10964, 10963);
      this.mirroringShapeCharacters.setValue(10965, 10966);
      this.mirroringShapeCharacters.setValue(10966, 10965);
      this.mirroringShapeCharacters.setValue(10974, 8870);
      this.mirroringShapeCharacters.setValue(10979, 8873);
      this.mirroringShapeCharacters.setValue(10980, 8872);
      this.mirroringShapeCharacters.setValue(10981, 8875);
      this.mirroringShapeCharacters.setValue(10988, 10989);
      this.mirroringShapeCharacters.setValue(10989, 10988);
      this.mirroringShapeCharacters.setValue(10999, 11e3);
      this.mirroringShapeCharacters.setValue(11e3, 10999);
      this.mirroringShapeCharacters.setValue(11001, 11002);
      this.mirroringShapeCharacters.setValue(11002, 11001);
      this.mirroringShapeCharacters.setValue(12296, 12297);
      this.mirroringShapeCharacters.setValue(12297, 12296);
      this.mirroringShapeCharacters.setValue(12298, 12299);
      this.mirroringShapeCharacters.setValue(12299, 12298);
      this.mirroringShapeCharacters.setValue(12300, 12301);
      this.mirroringShapeCharacters.setValue(12301, 12300);
      this.mirroringShapeCharacters.setValue(12302, 12303);
      this.mirroringShapeCharacters.setValue(12303, 12302);
      this.mirroringShapeCharacters.setValue(12304, 12305);
      this.mirroringShapeCharacters.setValue(12305, 12304);
      this.mirroringShapeCharacters.setValue(12308, 12309);
      this.mirroringShapeCharacters.setValue(12309, 12308);
      this.mirroringShapeCharacters.setValue(12310, 12311);
      this.mirroringShapeCharacters.setValue(12311, 12310);
      this.mirroringShapeCharacters.setValue(12312, 12313);
      this.mirroringShapeCharacters.setValue(12313, 12312);
      this.mirroringShapeCharacters.setValue(12314, 12315);
      this.mirroringShapeCharacters.setValue(12315, 12314);
      this.mirroringShapeCharacters.setValue(65288, 65289);
      this.mirroringShapeCharacters.setValue(65289, 65288);
      this.mirroringShapeCharacters.setValue(65308, 65310);
      this.mirroringShapeCharacters.setValue(65310, 65308);
      this.mirroringShapeCharacters.setValue(65339, 65341);
      this.mirroringShapeCharacters.setValue(65341, 65339);
      this.mirroringShapeCharacters.setValue(65371, 65373);
      this.mirroringShapeCharacters.setValue(65373, 65371);
      this.mirroringShapeCharacters.setValue(65375, 65376);
      this.mirroringShapeCharacters.setValue(65376, 65375);
      this.mirroringShapeCharacters.setValue(65378, 65379);
      this.mirroringShapeCharacters.setValue(65379, 65378);
    };
    return Bidi2;
  }()
);
var RtlCharacters = (
  /** @class */
  function() {
    function RtlCharacters2() {
      this.types = [];
      this.textOrder = -1;
      this.rtlCharacterTypes = new Array(65536);
      this.L = 0;
      this.LRE = 1;
      this.LRO = 2;
      this.R = 3;
      this.AL = 4;
      this.RLE = 5;
      this.RLO = 6;
      this.PDF = 7;
      this.EN = 8;
      this.ES = 9;
      this.ET = 10;
      this.AN = 11;
      this.CS = 12;
      this.NSM = 13;
      this.BN = 14;
      this.B = 15;
      this.S = 16;
      this.WS = 17;
      this.ON = 18;
      this.charTypes = [
        this.L,
        this.EN,
        this.BN,
        this.ES,
        this.ES,
        this.S,
        this.ET,
        this.ET,
        this.B,
        this.AN,
        this.AN,
        this.S,
        this.CS,
        this.CS,
        this.WS,
        this.NSM,
        this.NSM,
        this.B,
        this.BN,
        27,
        this.BN,
        28,
        30,
        this.B,
        31,
        31,
        this.S,
        32,
        32,
        this.WS,
        33,
        34,
        this.ON,
        35,
        37,
        this.ET,
        38,
        42,
        this.ON,
        43,
        43,
        this.ET,
        44,
        44,
        this.CS,
        45,
        45,
        this.ET,
        46,
        46,
        this.CS,
        47,
        47,
        this.CS,
        48,
        57,
        this.EN,
        58,
        58,
        this.CS,
        59,
        64,
        this.ON,
        65,
        90,
        this.L,
        91,
        96,
        this.ON,
        97,
        122,
        this.L,
        123,
        126,
        this.ON,
        127,
        132,
        this.BN,
        133,
        133,
        this.B,
        134,
        159,
        this.BN,
        160,
        160,
        this.CS,
        161,
        161,
        this.ON,
        162,
        165,
        this.ET,
        166,
        169,
        this.ON,
        170,
        170,
        this.L,
        171,
        175,
        this.ON,
        176,
        177,
        this.ET,
        178,
        179,
        this.EN,
        180,
        180,
        this.ON,
        181,
        181,
        this.L,
        182,
        184,
        this.ON,
        185,
        185,
        this.EN,
        186,
        186,
        this.L,
        187,
        191,
        this.ON,
        192,
        214,
        this.L,
        215,
        215,
        this.ON,
        216,
        246,
        this.L,
        247,
        247,
        this.ON,
        248,
        696,
        this.L,
        697,
        698,
        this.ON,
        699,
        705,
        this.L,
        706,
        719,
        this.ON,
        720,
        721,
        this.L,
        722,
        735,
        this.ON,
        736,
        740,
        this.L,
        741,
        749,
        this.ON,
        750,
        750,
        this.L,
        751,
        767,
        this.ON,
        768,
        855,
        this.NSM,
        856,
        860,
        this.L,
        861,
        879,
        this.NSM,
        880,
        883,
        this.L,
        884,
        885,
        this.ON,
        886,
        893,
        this.L,
        894,
        894,
        this.ON,
        895,
        899,
        this.L,
        900,
        901,
        this.ON,
        902,
        902,
        this.L,
        903,
        903,
        this.ON,
        904,
        1013,
        this.L,
        1014,
        1014,
        this.ON,
        1015,
        1154,
        this.L,
        1155,
        1158,
        this.NSM,
        1159,
        1159,
        this.L,
        1160,
        1161,
        this.NSM,
        1162,
        1417,
        this.L,
        1418,
        1418,
        this.ON,
        1419,
        1424,
        this.L,
        1425,
        1441,
        this.NSM,
        1442,
        1442,
        this.L,
        1443,
        1465,
        this.NSM,
        1466,
        1466,
        this.L,
        1467,
        1469,
        this.NSM,
        1470,
        1470,
        this.R,
        1471,
        1471,
        this.NSM,
        1472,
        1472,
        this.R,
        1473,
        1474,
        this.NSM,
        1475,
        1475,
        this.R,
        1476,
        1476,
        this.NSM,
        1477,
        1487,
        this.L,
        1488,
        1514,
        this.R,
        1515,
        1519,
        this.L,
        1520,
        1524,
        this.R,
        1525,
        1535,
        this.L,
        1536,
        1539,
        this.AL,
        1540,
        1547,
        this.L,
        1548,
        1548,
        this.CS,
        1549,
        1549,
        this.AL,
        1550,
        1551,
        this.ON,
        1552,
        1557,
        this.NSM,
        1558,
        1562,
        this.L,
        1563,
        1563,
        this.AL,
        1564,
        1566,
        this.L,
        1567,
        1567,
        this.AL,
        1568,
        1568,
        this.L,
        1569,
        1594,
        this.AL,
        1595,
        1599,
        this.L,
        1600,
        1610,
        this.AL,
        1611,
        1624,
        this.NSM,
        1625,
        1631,
        this.L,
        1632,
        1641,
        this.AN,
        1642,
        1642,
        this.ET,
        1643,
        1644,
        this.AN,
        1645,
        1647,
        this.AL,
        1648,
        1648,
        this.NSM,
        1649,
        1749,
        this.AL,
        1750,
        1756,
        this.NSM,
        1757,
        1757,
        this.AL,
        1758,
        1764,
        this.NSM,
        1765,
        1766,
        this.AL,
        1767,
        1768,
        this.NSM,
        1769,
        1769,
        this.ON,
        1770,
        1773,
        this.NSM,
        1774,
        1775,
        this.AL,
        1776,
        1785,
        this.EN,
        1786,
        1805,
        this.AL,
        1806,
        1806,
        this.L,
        1807,
        1807,
        this.BN,
        1808,
        1808,
        this.AL,
        1809,
        1809,
        this.NSM,
        1810,
        1839,
        this.AL,
        1840,
        1866,
        this.NSM,
        1867,
        1868,
        this.L,
        1869,
        1871,
        this.AL,
        1872,
        1919,
        this.L,
        1920,
        1957,
        this.AL,
        1958,
        1968,
        this.NSM,
        1969,
        1969,
        this.AL,
        1970,
        2304,
        this.L,
        2305,
        2306,
        this.NSM,
        2307,
        2363,
        this.L,
        2364,
        2364,
        this.NSM,
        2365,
        2368,
        this.L,
        2369,
        2376,
        this.NSM,
        2377,
        2380,
        this.L,
        2381,
        2381,
        this.NSM,
        2382,
        2384,
        this.L,
        2385,
        2388,
        this.NSM,
        2389,
        2401,
        this.L,
        2402,
        2403,
        this.NSM,
        2404,
        2432,
        this.L,
        2433,
        2433,
        this.NSM,
        2434,
        2491,
        this.L,
        2492,
        2492,
        this.NSM,
        2493,
        2496,
        this.L,
        2497,
        2500,
        this.NSM,
        2501,
        2508,
        this.L,
        2509,
        2509,
        this.NSM,
        2510,
        2529,
        this.L,
        2530,
        2531,
        this.NSM,
        2532,
        2545,
        this.L,
        2546,
        2547,
        this.ET,
        2548,
        2560,
        this.L,
        2561,
        2562,
        this.NSM,
        2563,
        2619,
        this.L,
        2620,
        2620,
        this.NSM,
        2621,
        2624,
        this.L,
        2625,
        2626,
        this.NSM,
        2627,
        2630,
        this.L,
        2631,
        2632,
        this.NSM,
        2633,
        2634,
        this.L,
        2635,
        2637,
        this.NSM,
        2638,
        2671,
        this.L,
        2672,
        2673,
        this.NSM,
        2674,
        2688,
        this.L,
        2689,
        2690,
        this.NSM,
        2691,
        2747,
        this.L,
        2748,
        2748,
        this.NSM,
        2749,
        2752,
        this.L,
        2753,
        2757,
        this.NSM,
        2758,
        2758,
        this.L,
        2759,
        2760,
        this.NSM,
        2761,
        2764,
        this.L,
        2765,
        2765,
        this.NSM,
        2766,
        2785,
        this.L,
        2786,
        2787,
        this.NSM,
        2788,
        2800,
        this.L,
        2801,
        2801,
        this.ET,
        2802,
        2816,
        this.L,
        2817,
        2817,
        this.NSM,
        2818,
        2875,
        this.L,
        2876,
        2876,
        this.NSM,
        2877,
        2878,
        this.L,
        2879,
        2879,
        this.NSM,
        2880,
        2880,
        this.L,
        2881,
        2883,
        this.NSM,
        2884,
        2892,
        this.L,
        2893,
        2893,
        this.NSM,
        2894,
        2901,
        this.L,
        2902,
        2902,
        this.NSM,
        2903,
        2945,
        this.L,
        2946,
        2946,
        this.NSM,
        2947,
        3007,
        this.L,
        3008,
        3008,
        this.NSM,
        3009,
        3020,
        this.L,
        3021,
        3021,
        this.NSM,
        3022,
        3058,
        this.L,
        3059,
        3064,
        this.ON,
        3065,
        3065,
        this.ET,
        3066,
        3066,
        this.ON,
        3067,
        3133,
        this.L,
        3134,
        3136,
        this.NSM,
        3137,
        3141,
        this.L,
        3142,
        3144,
        this.NSM,
        3145,
        3145,
        this.L,
        3146,
        3149,
        this.NSM,
        3150,
        3156,
        this.L,
        3157,
        3158,
        this.NSM,
        3159,
        3259,
        this.L,
        3260,
        3260,
        this.NSM,
        3261,
        3275,
        this.L,
        3276,
        3277,
        this.NSM,
        3278,
        3392,
        this.L,
        3393,
        3395,
        this.NSM,
        3396,
        3404,
        this.L,
        3405,
        3405,
        this.NSM,
        3406,
        3529,
        this.L,
        3530,
        3530,
        this.NSM,
        3531,
        3537,
        this.L,
        3538,
        3540,
        this.NSM,
        3541,
        3541,
        this.L,
        3542,
        3542,
        this.NSM,
        3543,
        3632,
        this.L,
        3633,
        3633,
        this.NSM,
        3634,
        3635,
        this.L,
        3636,
        3642,
        this.NSM,
        3643,
        3646,
        this.L,
        3647,
        3647,
        this.ET,
        3648,
        3654,
        this.L,
        3655,
        3662,
        this.NSM,
        3663,
        3760,
        this.L,
        3761,
        3761,
        this.NSM,
        3762,
        3763,
        this.L,
        3764,
        3769,
        this.NSM,
        3770,
        3770,
        this.L,
        3771,
        3772,
        this.NSM,
        3773,
        3783,
        this.L,
        3784,
        3789,
        this.NSM,
        3790,
        3863,
        this.L,
        3864,
        3865,
        this.NSM,
        3866,
        3892,
        this.L,
        3893,
        3893,
        this.NSM,
        3894,
        3894,
        this.L,
        3895,
        3895,
        this.NSM,
        3896,
        3896,
        this.L,
        3897,
        3897,
        this.NSM,
        3898,
        3901,
        this.ON,
        3902,
        3952,
        this.L,
        3953,
        3966,
        this.NSM,
        3967,
        3967,
        this.L,
        3968,
        3972,
        this.NSM,
        3973,
        3973,
        this.L,
        3974,
        3975,
        this.NSM,
        3976,
        3983,
        this.L,
        3984,
        3991,
        this.NSM,
        3992,
        3992,
        this.L,
        3993,
        4028,
        this.NSM,
        4029,
        4037,
        this.L,
        4038,
        4038,
        this.NSM,
        4039,
        4140,
        this.L,
        4141,
        4144,
        this.NSM,
        4145,
        4145,
        this.L,
        4146,
        4146,
        this.NSM,
        4147,
        4149,
        this.L,
        4150,
        4151,
        this.NSM,
        4152,
        4152,
        this.L,
        4153,
        4153,
        this.NSM,
        4154,
        4183,
        this.L,
        4184,
        4185,
        this.NSM,
        4186,
        5759,
        this.L,
        5760,
        5760,
        this.WS,
        5761,
        5786,
        this.L,
        5787,
        5788,
        this.ON,
        5789,
        5905,
        this.L,
        5906,
        5908,
        this.NSM,
        5909,
        5937,
        this.L,
        5938,
        5940,
        this.NSM,
        5941,
        5969,
        this.L,
        5970,
        5971,
        this.NSM,
        5972,
        6001,
        this.L,
        6002,
        6003,
        this.NSM,
        6004,
        6070,
        this.L,
        6071,
        6077,
        this.NSM,
        6078,
        6085,
        this.L,
        6086,
        6086,
        this.NSM,
        6087,
        6088,
        this.L,
        6089,
        6099,
        this.NSM,
        6100,
        6106,
        this.L,
        6107,
        6107,
        this.ET,
        6108,
        6108,
        this.L,
        6109,
        6109,
        this.NSM,
        6110,
        6127,
        this.L,
        6128,
        6137,
        this.ON,
        6138,
        6143,
        this.L,
        6144,
        6154,
        this.ON,
        6155,
        6157,
        this.NSM,
        6158,
        6158,
        this.WS,
        6159,
        6312,
        this.L,
        6313,
        6313,
        this.NSM,
        6314,
        6431,
        this.L,
        6432,
        6434,
        this.NSM,
        6435,
        6438,
        this.L,
        6439,
        6443,
        this.NSM,
        6444,
        6449,
        this.L,
        6450,
        6450,
        this.NSM,
        6451,
        6456,
        this.L,
        6457,
        6459,
        this.NSM,
        6460,
        6463,
        this.L,
        6464,
        6464,
        this.ON,
        6465,
        6467,
        this.L,
        6468,
        6469,
        this.ON,
        6470,
        6623,
        this.L,
        6624,
        6655,
        this.ON,
        6656,
        8124,
        this.L,
        8125,
        8125,
        this.ON,
        8126,
        8126,
        this.L,
        8127,
        8129,
        this.ON,
        8130,
        8140,
        this.L,
        8141,
        8143,
        this.ON,
        8144,
        8156,
        this.L,
        8157,
        8159,
        this.ON,
        8160,
        8172,
        this.L,
        8173,
        8175,
        this.ON,
        8176,
        8188,
        this.L,
        8189,
        8190,
        this.ON,
        8191,
        8191,
        this.L,
        8192,
        8202,
        this.WS,
        8203,
        8205,
        this.BN,
        8206,
        8206,
        this.L,
        8207,
        8207,
        this.R,
        8208,
        8231,
        this.ON,
        8232,
        8232,
        this.WS,
        8233,
        8233,
        this.B,
        8234,
        8234,
        this.LRE,
        8235,
        8235,
        this.RLE,
        8236,
        8236,
        this.PDF,
        8237,
        8237,
        this.LRO,
        8238,
        8238,
        this.RLO,
        8239,
        8239,
        this.WS,
        8240,
        8244,
        this.ET,
        8245,
        8276,
        this.ON,
        8277,
        8278,
        this.L,
        8279,
        8279,
        this.ON,
        8280,
        8286,
        this.L,
        8287,
        8287,
        this.WS,
        8288,
        8291,
        this.BN,
        8292,
        8297,
        this.L,
        8298,
        8303,
        this.BN,
        8304,
        8304,
        this.EN,
        8305,
        8307,
        this.L,
        8308,
        8313,
        this.EN,
        8314,
        8315,
        this.ET,
        8316,
        8318,
        this.ON,
        8319,
        8319,
        this.L,
        8320,
        8329,
        this.EN,
        8330,
        8331,
        this.ET,
        8332,
        8334,
        this.ON,
        8335,
        8351,
        this.L,
        8352,
        8369,
        this.ET,
        8370,
        8399,
        this.L,
        8400,
        8426,
        this.NSM,
        8427,
        8447,
        this.L,
        8448,
        8449,
        this.ON,
        8450,
        8450,
        this.L,
        8451,
        8454,
        this.ON,
        8455,
        8455,
        this.L,
        8456,
        8457,
        this.ON,
        8458,
        8467,
        this.L,
        8468,
        8468,
        this.ON,
        8469,
        8469,
        this.L,
        8470,
        8472,
        this.ON,
        8473,
        8477,
        this.L,
        8478,
        8483,
        this.ON,
        8484,
        8484,
        this.L,
        8485,
        8485,
        this.ON,
        8486,
        8486,
        this.L,
        8487,
        8487,
        this.ON,
        8488,
        8488,
        this.L,
        8489,
        8489,
        this.ON,
        8490,
        8493,
        this.L,
        8494,
        8494,
        this.ET,
        8495,
        8497,
        this.L,
        8498,
        8498,
        this.ON,
        8499,
        8505,
        this.L,
        8506,
        8507,
        this.ON,
        8508,
        8511,
        this.L,
        8512,
        8516,
        this.ON,
        8517,
        8521,
        this.L,
        8522,
        8523,
        this.ON,
        8524,
        8530,
        this.L,
        8531,
        8543,
        this.ON,
        8544,
        8591,
        this.L,
        8592,
        8721,
        this.ON,
        8722,
        8723,
        this.ET,
        8724,
        9013,
        this.ON,
        9014,
        9082,
        this.L,
        9083,
        9108,
        this.ON,
        9109,
        9109,
        this.L,
        9110,
        9168,
        this.ON,
        9169,
        9215,
        this.L,
        9216,
        9254,
        this.ON,
        9255,
        9279,
        this.L,
        9280,
        9290,
        this.ON,
        9291,
        9311,
        this.L,
        9312,
        9371,
        this.EN,
        9372,
        9449,
        this.L,
        9450,
        9450,
        this.EN,
        9451,
        9751,
        this.ON,
        9752,
        9752,
        this.L,
        9753,
        9853,
        this.ON,
        9854,
        9855,
        this.L,
        9856,
        9873,
        this.ON,
        9874,
        9887,
        this.L,
        9888,
        9889,
        this.ON,
        9890,
        9984,
        this.L,
        9985,
        9988,
        this.ON,
        9989,
        9989,
        this.L,
        9990,
        9993,
        this.ON,
        9994,
        9995,
        this.L,
        9996,
        10023,
        this.ON,
        10024,
        10024,
        this.L,
        10025,
        10059,
        this.ON,
        10060,
        10060,
        this.L,
        10061,
        10061,
        this.ON,
        10062,
        10062,
        this.L,
        10063,
        10066,
        this.ON,
        10067,
        10069,
        this.L,
        10070,
        10070,
        this.ON,
        10071,
        10071,
        this.L,
        10072,
        10078,
        this.ON,
        10079,
        10080,
        this.L,
        10081,
        10132,
        this.ON,
        10133,
        10135,
        this.L,
        10136,
        10159,
        this.ON,
        10160,
        10160,
        this.L,
        10161,
        10174,
        this.ON,
        10175,
        10191,
        this.L,
        10192,
        10219,
        this.ON,
        10220,
        10223,
        this.L,
        10224,
        11021,
        this.ON,
        11022,
        11903,
        this.L,
        11904,
        11929,
        this.ON,
        11930,
        11930,
        this.L,
        11931,
        12019,
        this.ON,
        12020,
        12031,
        this.L,
        12032,
        12245,
        this.ON,
        12246,
        12271,
        this.L,
        12272,
        12283,
        this.ON,
        12284,
        12287,
        this.L,
        12288,
        12288,
        this.WS,
        12289,
        12292,
        this.ON,
        12293,
        12295,
        this.L,
        12296,
        12320,
        this.ON,
        12321,
        12329,
        this.L,
        12330,
        12335,
        this.NSM,
        12336,
        12336,
        this.ON,
        12337,
        12341,
        this.L,
        12342,
        12343,
        this.ON,
        12344,
        12348,
        this.L,
        12349,
        12351,
        this.ON,
        12352,
        12440,
        this.L,
        12441,
        12442,
        this.NSM,
        12443,
        12444,
        this.ON,
        12445,
        12447,
        this.L,
        12448,
        12448,
        this.ON,
        12449,
        12538,
        this.L,
        12539,
        12539,
        this.ON,
        12540,
        12828,
        this.L,
        12829,
        12830,
        this.ON,
        12831,
        12879,
        this.L,
        12880,
        12895,
        this.ON,
        12896,
        12923,
        this.L,
        12924,
        12925,
        this.ON,
        12926,
        12976,
        this.L,
        12977,
        12991,
        this.ON,
        12992,
        13003,
        this.L,
        13004,
        13007,
        this.ON,
        13008,
        13174,
        this.L,
        13175,
        13178,
        this.ON,
        13179,
        13277,
        this.L,
        13278,
        13279,
        this.ON,
        13280,
        13310,
        this.L,
        13311,
        13311,
        this.ON,
        13312,
        19903,
        this.L,
        19904,
        19967,
        this.ON,
        19968,
        42127,
        this.L,
        42128,
        42182,
        this.ON,
        42183,
        64284,
        this.L,
        64285,
        64285,
        this.R,
        64286,
        64286,
        this.NSM,
        64287,
        64296,
        this.R,
        64297,
        64297,
        this.ET,
        64298,
        64310,
        this.R,
        64311,
        64311,
        this.L,
        64312,
        64316,
        this.R,
        64317,
        64317,
        this.L,
        64318,
        64318,
        this.R,
        64319,
        64319,
        this.L,
        64320,
        64321,
        this.R,
        64322,
        64322,
        this.L,
        64323,
        64324,
        this.R,
        64325,
        64325,
        this.L,
        64326,
        64335,
        this.R,
        64336,
        64433,
        this.AL,
        64434,
        64466,
        this.L,
        64467,
        64829,
        this.AL,
        64830,
        64831,
        this.ON,
        64832,
        64847,
        this.L,
        64848,
        64911,
        this.AL,
        64912,
        64913,
        this.L,
        64914,
        64967,
        this.AL,
        64968,
        65007,
        this.L,
        65008,
        65020,
        this.AL,
        65021,
        65021,
        this.ON,
        65022,
        65023,
        this.L,
        65024,
        65039,
        this.NSM,
        65040,
        65055,
        this.L,
        65056,
        65059,
        this.NSM,
        65060,
        65071,
        this.L,
        65072,
        65103,
        this.ON,
        65104,
        65104,
        this.CS,
        65105,
        65105,
        this.ON,
        65106,
        65106,
        this.CS,
        65107,
        65107,
        this.L,
        65108,
        65108,
        this.ON,
        65109,
        65109,
        this.CS,
        65110,
        65118,
        this.ON,
        65119,
        65119,
        this.ET,
        65120,
        65121,
        this.ON,
        65122,
        65123,
        this.ET,
        65124,
        65126,
        this.ON,
        65127,
        65127,
        this.L,
        65128,
        65128,
        this.ON,
        65129,
        65130,
        this.ET,
        65131,
        65131,
        this.ON,
        65132,
        65135,
        this.L,
        65136,
        65140,
        this.AL,
        65141,
        65141,
        this.L,
        65142,
        65276,
        this.AL,
        65277,
        65278,
        this.L,
        65279,
        65279,
        this.BN,
        65280,
        65280,
        this.L,
        65281,
        65282,
        this.ON,
        65283,
        65285,
        this.ET,
        65286,
        65290,
        this.ON,
        65291,
        65291,
        this.ET,
        65292,
        65292,
        this.CS,
        65293,
        65293,
        this.ET,
        65294,
        65294,
        this.CS,
        65295,
        65295,
        this.ES,
        65296,
        65305,
        this.EN,
        65306,
        65306,
        this.CS,
        65307,
        65312,
        this.ON,
        65313,
        65338,
        this.L,
        65339,
        65344,
        this.ON,
        65345,
        65370,
        this.L,
        65371,
        65381,
        this.ON,
        65382,
        65503,
        this.L,
        65504,
        65505,
        this.ET,
        65506,
        65508,
        this.ON,
        65509,
        65510,
        this.ET,
        65511,
        65511,
        this.L,
        65512,
        65518,
        this.ON,
        65519,
        65528,
        this.L,
        65529,
        65531,
        this.BN,
        65532,
        65533,
        this.ON,
        65534,
        65535,
        this.L
      ];
      for (var i = 0; i < this.charTypes.length; ++i) {
        var start = this.charTypes[i];
        var end = this.charTypes[++i];
        var b = this.charTypes[++i];
        while (start <= end) {
          this.rtlCharacterTypes[start++] = b;
        }
      }
    }
    RtlCharacters2.prototype.getVisualOrder = function(inputText, isRtl) {
      this.types = this.getCharacterCode(inputText);
      this.textOrder = isRtl ? this.LRE : this.L;
      this.doVisualOrder();
      var result = [];
      for (var i = 0; i < this.levels.length; i++) {
        result[i] = this.levels[i];
      }
      return result;
    };
    RtlCharacters2.prototype.getCharacterCode = function(text) {
      var characterCodes = [];
      for (var i = 0; i < text.length; i++) {
        characterCodes[i] = this.rtlCharacterTypes[text[i].charCodeAt(0)];
      }
      return characterCodes;
    };
    RtlCharacters2.prototype.setDefaultLevels = function() {
      for (var i = 0; i < this.length; i++) {
        this.levels[i] = this.textOrder;
      }
    };
    RtlCharacters2.prototype.setLevels = function() {
      this.setDefaultLevels();
      for (var n = 0; n < this.length; ++n) {
        var level = this.levels[n];
        if ((level & 128) !== 0) {
          level &= 127;
          this.result[n] = (level & 1) === 0 ? this.L : this.R;
        }
        this.levels[n] = level;
      }
    };
    RtlCharacters2.prototype.updateLevels = function(index, level, length) {
      if ((level & 1) === 0) {
        for (var i = index; i < length; ++i) {
          if (this.result[i] === this.R) {
            this.levels[i] += 1;
          } else if (this.result[i] !== this.L) {
            this.levels[i] += 2;
          }
        }
      } else {
        for (var i = index; i < length; ++i) {
          if (this.result[i] !== this.R) {
            this.levels[i] += 1;
          }
        }
      }
    };
    RtlCharacters2.prototype.doVisualOrder = function() {
      this.length = this.types.length;
      this.result = this.types;
      this.levels = [];
      this.setLevels();
      this.length = this.getEmbeddedCharactersLength();
      var preview = this.textOrder;
      var i = 0;
      while (i < this.length) {
        var level = this.levels[i];
        var preType = (Math.max(preview, level) & 1) === 0 ? this.L : this.R;
        var length_1 = i + 1;
        while (length_1 < this.length && this.levels[length_1] === level) {
          ++length_1;
        }
        var success = length_1 < this.length ? this.levels[length_1] : this.textOrder;
        var type = (Math.max(success, level) & 1) === 0 ? this.L : this.R;
        this.checkNSM(i, length_1, level, preType, type);
        this.updateLevels(i, level, length_1);
        preview = level;
        i = length_1;
      }
      this.checkEmbeddedCharacters(this.length);
    };
    RtlCharacters2.prototype.getEmbeddedCharactersLength = function() {
      var index = 0;
      for (var i = 0; i < this.length; ++i) {
        if (!(this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO || this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN)) {
          this.result[index] = this.result[i];
          this.levels[index] = this.levels[i];
          index++;
        }
      }
      return index;
    };
    RtlCharacters2.prototype.checkEmbeddedCharacters = function(length) {
      for (var i = this.types.length - 1; i >= 0; --i) {
        if (this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO || this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN) {
          this.result[i] = this.types[i];
          this.levels[i] = -1;
        } else {
          length -= 1;
          this.result[i] = this.result[length];
          this.levels[i] = this.levels[length];
        }
      }
      for (var i = 0; i < this.types.length; i++) {
        if (this.levels[i] === -1) {
          if (i === 0) {
            this.levels[i] = this.textOrder;
          } else {
            this.levels[i] = this.levels[i - 1];
          }
        }
      }
    };
    RtlCharacters2.prototype.checkNSM = function(index, length, level, startType, endType) {
      var charType = startType;
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.NSM) {
          this.result[i] = charType;
        } else {
          charType = this.result[i];
        }
      }
      this.checkEuropeanDigits(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkEuropeanDigits = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.EN) {
          for (var j = i - 1; j >= index; --j) {
            if (this.result[j] === this.L || this.result[j] === this.R || this.result[j] === this.AL) {
              if (this.result[j] === this.AL) {
                this.result[i] = this.AN;
              }
              break;
            }
          }
        }
      }
      this.checkArabicCharacters(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkArabicCharacters = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.AL) {
          this.result[i] = this.R;
        }
      }
      this.checkEuropeanNumberSeparator(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkEuropeanNumberSeparator = function(index, length, level, startType, endType) {
      for (var i = index + 1; i < length - 1; ++i) {
        if (this.result[i] === this.ES || this.result[i] === this.CS) {
          var preview = this.result[i - 1];
          var success = this.result[i + 1];
          if (preview === this.EN && success === this.EN) {
            this.result[i] = this.EN;
          } else if (this.result[i] === this.CS && preview === this.AN && success === this.AN) {
            this.result[i] = this.AN;
          }
        }
      }
      this.checkEuropeanNumberTerminator(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkEuropeanNumberTerminator = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.ET) {
          var s = i;
          var b = [];
          b.push(this.ET);
          var l = this.getLength(s, length, b);
          var data = s === index ? startType : this.result[s - 1];
          if (data !== this.EN) {
            data = l === length ? endType : this.result[l];
          }
          if (data === this.EN) {
            for (var j = s; j < l; ++j) {
              this.result[j] = this.EN;
            }
          }
          i = l;
        }
      }
      this.checkOtherNeutrals(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkOtherNeutrals = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.ES || this.result[i] === this.ET || this.result[i] === this.CS) {
          this.result[i] = this.ON;
        }
      }
      this.checkOtherCharacters(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkOtherCharacters = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.EN) {
          var pst = startType;
          for (var j = i - 1; j >= index; --j) {
            if (this.result[j] === this.L || this.result[j] === this.R) {
              pst = this.result[j];
              break;
            }
          }
          if (pst === this.L) {
            this.result[i] = this.L;
          }
        }
      }
      this.checkCommanCharacters(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.getLength = function(index, length, validSet) {
      --index;
      while (++index < length) {
        var t = this.result[index];
        for (var i = 0; i < validSet.length; ++i) {
          if (t === validSet[i]) {
            index = this.getLength(++index, length, validSet);
          }
        }
        return index;
      }
      return length;
    };
    RtlCharacters2.prototype.checkCommanCharacters = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.WS || this.result[i] === this.ON || this.result[i] === this.B || this.result[i] === this.S) {
          var s = i;
          var byte = [this.B, this.S, this.WS, this.ON];
          var l = this.getLength(s, length, byte);
          var lt = 0;
          var tt = 0;
          var rt = 0;
          if (s === index) {
            lt = startType;
          } else {
            lt = this.result[s - 1];
            if (lt === this.AN) {
              lt = this.R;
            } else if (lt === this.EN) {
              lt = this.R;
            }
          }
          if (l === length) {
            tt = endType;
          } else {
            tt = this.result[l];
            if (tt === this.AN) {
              tt = this.R;
            } else if (tt === this.EN) {
              tt = this.R;
            }
          }
          if (lt === tt) {
            rt = lt;
          } else {
            rt = (level & 1) === 0 ? this.L : this.R;
          }
          for (var j = s; j < l; ++j) {
            this.result[j] = rt;
          }
          i = l;
        }
      }
    };
    return RtlCharacters2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl-renderer.js
var RtlRenderer = (
  /** @class */
  function() {
    function RtlRenderer2() {
      this.openBracket = "(";
      this.closeBracket = ")";
    }
    RtlRenderer2.prototype.layout = function(line, font, rtl, wordSpace, format) {
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      var result = [];
      if (font.Unicode) {
        result = this.customLayout(line, rtl, format, font, wordSpace);
      } else {
        result = [];
        result[0] = line;
      }
      return result;
    };
    RtlRenderer2.prototype.splitLayout = function(line, font, rtl, wordSpace, format) {
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      var words = [];
      var system = false;
      if (!system || words == null) {
        words = this.customSplitLayout(line, font, rtl, wordSpace, format);
      }
      return words;
    };
    RtlRenderer2.prototype.getGlyphIndex = function(line, font, rtl, glyphs, custom) {
      var success = true;
      var fail = false;
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      glyphs = null;
      if (line.length === 0) {
        return { success: fail, glyphs };
      }
      var renderer = new ArabicShapeRenderer();
      var text = renderer.shape(line, 0);
      var internalFont = font.fontInternal;
      var ttfReader = internalFont.ttfReader;
      glyphs = new Uint16Array(text.length);
      var i = 0;
      for (var k = 0, len = text.length; k < len; k++) {
        var ch = text[k];
        var glyphInfo = ttfReader.getGlyph(ch);
        if (glyphInfo !== null && typeof glyphInfo !== "undefined") {
          glyphs[i++] = glyphInfo.index;
        }
      }
      return { success, glyphs };
    };
    RtlRenderer2.prototype.customLayout = function(line, rtl, format, font, wordSpace) {
      if (wordSpace === null || typeof wordSpace === "undefined") {
        if (line == null) {
          throw new Error("ArgumentNullException : line");
        }
        var result = null;
        if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
          var bidi = new Bidi();
          result = bidi.getLogicalToVisualString(line, rtl);
        }
        return result;
      } else {
        if (line == null) {
          throw new Error("ArgumentNullException : line");
        }
        if (font == null) {
          throw new Error("ArgumentNullException : font");
        }
        var layouted = null;
        if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
          var renderer = new ArabicShapeRenderer();
          var txt = renderer.shape(line, 0);
          layouted = this.customLayout(txt, rtl, format);
        }
        var result = [];
        if (wordSpace) {
          var words = layouted.split("");
          var count = words.length;
          for (var i = 0; i < count; i++) {
            words[i] = this.addChars(font, words[i]);
          }
          result = words;
        } else {
          result = [];
          result[0] = this.addChars(font, layouted);
        }
        return result;
      }
    };
    RtlRenderer2.prototype.addChars = function(font, glyphs) {
      var line = glyphs;
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      var text = line;
      var internalFont = font.fontInternal;
      var ttfReader = internalFont.ttfReader;
      font.setSymbols(text);
      text = ttfReader.convertString(text);
      var bytes = PdfString.toUnicodeArray(text, false);
      text = PdfString.byteToString(bytes);
      return text;
    };
    RtlRenderer2.prototype.customSplitLayout = function(line, font, rtl, wordSpace, format) {
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      var reversedLine = this.customLayout(line, rtl, format);
      var words = reversedLine.split("");
      return words;
    };
    return RtlRenderer2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/enum.js
var PdfLayoutType;
(function(PdfLayoutType2) {
  PdfLayoutType2[PdfLayoutType2["Paginate"] = 0] = "Paginate";
  PdfLayoutType2[PdfLayoutType2["OnePage"] = 1] = "OnePage";
})(PdfLayoutType || (PdfLayoutType = {}));
var PdfLayoutBreakType;
(function(PdfLayoutBreakType2) {
  PdfLayoutBreakType2[PdfLayoutBreakType2["FitPage"] = 0] = "FitPage";
  PdfLayoutBreakType2[PdfLayoutBreakType2["FitElement"] = 1] = "FitElement";
  PdfLayoutBreakType2[PdfLayoutBreakType2["FitColumnsToPage"] = 2] = "FitColumnsToPage";
})(PdfLayoutBreakType || (PdfLayoutBreakType = {}));
var PathPointType;
(function(PathPointType2) {
  PathPointType2[PathPointType2["Start"] = 0] = "Start";
  PathPointType2[PathPointType2["Line"] = 1] = "Line";
  PathPointType2[PathPointType2["Bezier3"] = 3] = "Bezier3";
  PathPointType2[PathPointType2["Bezier"] = 3] = "Bezier";
  PathPointType2[PathPointType2["PathTypeMask"] = 7] = "PathTypeMask";
  PathPointType2[PathPointType2["DashMode"] = 16] = "DashMode";
  PathPointType2[PathPointType2["PathMarker"] = 32] = "PathMarker";
  PathPointType2[PathPointType2["CloseSubpath"] = 128] = "CloseSubpath";
})(PathPointType || (PathPointType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-gradient-brush.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfGradientBrush = (
  /** @class */
  function(_super) {
    __extends7(PdfGradientBrush2, _super);
    function PdfGradientBrush2(shading) {
      var _this = _super.call(this) || this;
      _this.mbackground = new PdfColor(255, 255, 255);
      _this.mbStroking = false;
      _this.mfunction = null;
      _this.dictionaryProperties = new DictionaryProperties();
      _this.mpatternDictionary = new PdfDictionary();
      _this.mpatternDictionary.items.setValue(_this.dictionaryProperties.type, new PdfName(_this.dictionaryProperties.pattern));
      _this.mpatternDictionary.items.setValue(_this.dictionaryProperties.patternType, new PdfNumber(2));
      _this.shading = shading;
      _this.colorSpace = PdfColorSpace.Rgb;
      return _this;
    }
    Object.defineProperty(PdfGradientBrush2.prototype, "background", {
      //Properties
      /**
       * Gets or sets the background color of the brush.
       * @public
       */
      get: function() {
        return this.mbackground;
      },
      set: function(value) {
        this.mbackground = value;
        var sh = this.shading;
        if (value.isEmpty) {
          sh.remove(this.dictionaryProperties.background);
        } else {
          sh.items.setValue(this.dictionaryProperties.background, value.toArray(this.colorSpace));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "antiAlias", {
      /**
       * Gets or sets a value indicating whether use anti aliasing algorithm.
       * @public
       */
      get: function() {
        var sh = this.shading;
        var aa = sh.items.getValue(this.dictionaryProperties.antiAlias);
        return aa.value;
      },
      set: function(value) {
        var sh = this.shading;
        var aa = sh.items.getValue(this.dictionaryProperties.antiAlias);
        if (aa == null && typeof aa === "undefined") {
          aa = new PdfBoolean(value);
          sh.items.setValue(this.dictionaryProperties.antiAlias, aa);
        } else {
          aa.value = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "function", {
      /**
       * Gets or sets the function of the brush.
       * @protected
       */
      get: function() {
        return this.mfunction;
      },
      set: function(value) {
        this.mfunction = value;
        if (value != null && typeof value !== "undefined") {
          this.shading.items.setValue(this.dictionaryProperties.function, new PdfReferenceHolder(this.mfunction));
        } else {
          this.shading.remove(this.dictionaryProperties.function);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "bBox", {
      /**
       * Gets or sets the boundary box of the brush.
       * @protected
       */
      get: function() {
        var sh = this.shading;
        var box = sh.items.getValue(this.dictionaryProperties.bBox);
        return box;
      },
      set: function(value) {
        var sh = this.shading;
        if (value == null && typeof value === "undefined") {
          sh.remove(this.dictionaryProperties.bBox);
        } else {
          sh.items.setValue(this.dictionaryProperties.bBox, value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "colorSpace", {
      /**
       * Gets or sets the color space of the brush.
       * @public
       */
      get: function() {
        return this.mcolorSpace;
      },
      set: function(value) {
        var colorSpace = this.shading.items.getValue(this.dictionaryProperties.colorSpace);
        if (value !== this.mcolorSpace || colorSpace == null) {
          this.mcolorSpace = value;
          var csValue = this.colorSpaceToDeviceName(value);
          this.shading.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(csValue));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "stroking", {
      /**
       * Gets or sets a value indicating whether this PdfGradientBrush is stroking.
       * @public
       */
      get: function() {
        return this.mbStroking;
      },
      set: function(value) {
        this.mbStroking = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "patternDictionary", {
      /**
       * Gets the pattern dictionary.
       * @protected
       */
      get: function() {
        if (this.mpatternDictionary == null) {
          this.mpatternDictionary = new PdfDictionary();
        }
        return this.mpatternDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "shading", {
      /**
       * Gets or sets the shading dictionary.
       * @protected
       */
      get: function() {
        return this.mshading;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Shading");
        }
        if (value !== this.mshading) {
          this.mshading = value;
          this.patternDictionary.items.setValue(this.dictionaryProperties.shading, new PdfReferenceHolder(this.mshading));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "matrix", {
      /**
       * Gets or sets the transformation matrix.
       * @public
       */
      get: function() {
        return this.mmatrix;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Matrix");
        }
        if (value !== this.mmatrix) {
          this.mmatrix = value.clone();
          var m = new PdfArray(this.mmatrix.matrix.elements);
          this.mpatternDictionary.items.setValue(this.dictionaryProperties.matrix, m);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfGradientBrush2.prototype.monitorChanges = function(brush, streamWriter, getResources, saveChanges, currentColorSpace) {
      var diff = false;
      if (brush instanceof PdfGradientBrush2) {
        if (this.colorSpace !== currentColorSpace) {
          this.colorSpace = currentColorSpace;
          this.resetFunction();
        }
        streamWriter.setColorSpace("Pattern", this.mbStroking);
        var resources = getResources.getResources();
        var name_1 = resources.getName(this);
        streamWriter.setColourWithPattern(null, name_1, this.mbStroking);
        diff = true;
      }
      return diff;
    };
    PdfGradientBrush2.prototype.resetChanges = function(streamWriter) {
    };
    PdfGradientBrush2.prototype.colorSpaceToDeviceName = function(colorSpace) {
      var result;
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          result = "DeviceRGB";
          break;
      }
      return result;
    };
    PdfGradientBrush2.prototype.resetPatternDictionary = function(dictionary) {
      this.mpatternDictionary = dictionary;
    };
    PdfGradientBrush2.prototype.cloneAntiAliasingValue = function(brush) {
      if (brush == null) {
        throw new Error("ArgumentNullException : brush");
      }
      var sh = this.shading;
      var aa = sh.items.getValue(this.dictionaryProperties.antiAlias);
      if (aa != null) {
        brush.shading.items.setValue(this.dictionaryProperties.antiAlias, new PdfBoolean(aa.value));
      }
    };
    PdfGradientBrush2.prototype.cloneBackgroundValue = function(brush) {
      var background = this.background;
      if (!background.isEmpty) {
        brush.background = background;
      }
    };
    Object.defineProperty(PdfGradientBrush2.prototype, "element", {
      /* tslint:enable */
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.patternDictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGradientBrush2;
  }(PdfBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/pdf-template.js
var PdfTemplate = (
  /** @class */
  function() {
    function PdfTemplate2(arg1, arg2) {
      this.dictionaryProperties = new DictionaryProperties();
      this.writeTransformation = true;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof SizeF && typeof arg2 === "undefined") {
        this.content = new PdfStream();
        var tempSize = new SizeF(arg1.width, arg1.height);
        this.setSize(tempSize);
        this.initialize();
      } else {
        this.content = new PdfStream();
        this.setSize(new SizeF(arg1, arg2));
        this.initialize();
      }
    }
    Object.defineProperty(PdfTemplate2.prototype, "size", {
      //Properties
      /**
       * Gets the size of the 'PdfTemplate'.
       */
      get: function() {
        return this.templateSize;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplate2.prototype, "width", {
      /**
       * Gets the width of the 'PdfTemplate'.
       */
      get: function() {
        return this.size.width;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplate2.prototype, "height", {
      /**
       * Gets the height of the 'PdfTemplate'.
       */
      get: function() {
        return this.size.height;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplate2.prototype, "graphics", {
      /**
       * Gets the `graphics` of the 'PdfTemplate'.
       */
      get: function() {
        if (this.pdfGraphics == null || typeof this.pdfGraphics === "undefined") {
          var gr = new GetResourceEventHandler(this);
          var g = new PdfGraphics(this.size, gr, this.content);
          this.pdfGraphics = g;
          this.pdfGraphics.initializeCoordinates();
        }
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    PdfTemplate2.prototype.getResources = function() {
      if (this.resources == null) {
        this.resources = new PdfResources();
        this.content.items.setValue(this.dictionaryProperties.resources, this.resources);
      }
      return this.resources;
    };
    PdfTemplate2.prototype.initialize = function() {
      this.addType();
      this.addSubType();
    };
    PdfTemplate2.prototype.addType = function() {
      var value = new PdfName(this.dictionaryProperties.xObject);
      this.content.items.setValue(this.dictionaryProperties.type, value);
    };
    PdfTemplate2.prototype.addSubType = function() {
      var value = new PdfName(this.dictionaryProperties.form);
      this.content.items.setValue(this.dictionaryProperties.subtype, value);
    };
    PdfTemplate2.prototype.reset = function(size) {
      if (typeof size === "undefined") {
        if (this.resources != null) {
          this.resources = null;
          this.content.remove(this.dictionaryProperties.resources);
        }
        if (this.graphics != null) {
          this.graphics.reset(this.size);
        }
      } else {
        this.setSize(size);
        this.reset();
      }
    };
    PdfTemplate2.prototype.setSize = function(size) {
      var rect = new RectangleF(new PointF(0, 0), size);
      var val = PdfArray.fromRectangle(rect);
      this.content.items.setValue(this.dictionaryProperties.bBox, val);
      this.templateSize = size;
    };
    Object.defineProperty(PdfTemplate2.prototype, "element", {
      // /**
      //  * Returns the value of current graphics.
      //  * @private
      //  */
      // public GetGraphics(g : PdfGraphics) : PdfGraphics {
      //     if (this.graphics == null || typeof this.graphics === 'undefined') {
      //         this.graphics = g;
      //         this.graphics.Size = this.Size;
      //         this.graphics.StreamWriter = new PdfStreamWriter(this.content)
      //         this.graphics.Initialize();
      //         if(this.writeTransformation) {
      //             this.graphics.InitializeCoordinates();
      //         }
      //     }
      //     return this.graphics;
      // }
      // IPdfWrapper Members
      /**
       * Gets the `content stream` of 'PdfTemplate' class.
       * @private
       */
      get: function() {
        return this.content;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTemplate2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-resources.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfResources = (
  /** @class */
  function(_super) {
    __extends8(PdfResources2, _super);
    function PdfResources2(baseDictionary) {
      var _this = _super.call(this, baseDictionary) || this;
      _this.properties = new PdfDictionary();
      return _this;
    }
    Object.defineProperty(PdfResources2.prototype, "names", {
      //Properties
      /**
       * Gets the `font names`.
       * @private
       */
      get: function() {
        return this.getNames();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfResources2.prototype, "document", {
      /**
       * Get or set the `page document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      set: function(value) {
        this.pdfDocument = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfResources2.prototype.getName = function(obj) {
      var primitive = obj.element;
      var name = null;
      if (this.names.containsKey(primitive)) {
        name = this.names.getValue(primitive);
      }
      if (name == null) {
        var sName = this.generateName();
        name = new PdfName(sName);
        this.names.setValue(primitive, name);
        if (obj instanceof PdfFont) {
          this.add(obj, name);
        } else if (obj instanceof PdfTemplate) {
          this.add(obj, name);
        } else if (obj instanceof PdfGradientBrush || obj instanceof PdfTilingBrush) {
          this.add(obj, name);
        } else if (obj instanceof PdfTransparency) {
          this.add(obj, name);
        } else if (obj instanceof PdfImage || obj instanceof PdfBitmap) {
          this.add(obj, name);
        }
      }
      return name;
    };
    PdfResources2.prototype.getNames = function() {
      if (this.pdfNames == null) {
        this.pdfNames = new TemporaryDictionary();
      }
      var fonts = this.items.getValue(this.dictionaryProperties.font);
      if (fonts != null) {
        var reference = fonts;
        var dictionary = fonts;
        dictionary = PdfCrossTable.dereference(fonts);
      }
      return this.pdfNames;
    };
    PdfResources2.prototype.requireProcedureSet = function(procedureSetName) {
      if (procedureSetName == null) {
        throw new Error("ArgumentNullException:procedureSetName");
      }
      var procSets = this.items.getValue(this.dictionaryProperties.procset);
      if (procSets == null) {
        procSets = new PdfArray();
        this.items.setValue(this.dictionaryProperties.procset, procSets);
      }
      var name = new PdfName(procedureSetName);
      if (!procSets.contains(name)) {
        procSets.add(name);
      }
    };
    PdfResources2.prototype.removeFont = function(name) {
      var key = null;
      var keys = this.pdfNames.keys();
      for (var index = 0; index < this.pdfNames.size(); index++) {
        if (this.pdfNames.getValue(keys[index]) === new PdfName(name)) {
          key = keys[index];
          break;
        }
      }
      if (key != null) {
        this.pdfNames.remove(key);
      }
    };
    PdfResources2.prototype.generateName = function() {
      var name = Guid.getNewGuidString();
      return name;
    };
    PdfResources2.prototype.add = function(arg1, arg2) {
      if (arg1 instanceof PdfFont) {
        var dictionary = null;
        var fonts = this.items.getValue(this.dictionaryProperties.font);
        if (fonts != null) {
          var reference = fonts;
          dictionary = fonts;
          dictionary = fonts;
        } else {
          dictionary = new PdfDictionary();
          this.items.setValue(this.dictionaryProperties.font, dictionary);
        }
        dictionary.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));
      } else if (arg1 instanceof PdfTemplate) {
        var xobjects = void 0;
        xobjects = this.items.getValue(this.dictionaryProperties.xObject);
        if (xobjects == null) {
          xobjects = new PdfDictionary();
          this.items.setValue(this.dictionaryProperties.xObject, xobjects);
        }
        xobjects.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));
      } else if (arg1 instanceof PdfBrush) {
        if (arg1 instanceof PdfGradientBrush || arg1 instanceof PdfTilingBrush) {
          var savable = arg1.element;
          if (savable != null) {
            var pattern = this.items.getValue(this.dictionaryProperties.pattern);
            if (pattern == null) {
              pattern = new PdfDictionary();
              this.items.setValue(this.dictionaryProperties.pattern, pattern);
            }
            pattern.items.setValue(arg2.value, new PdfReferenceHolder(savable));
          }
        }
      } else if (arg1 instanceof PdfTransparency) {
        var savable = arg1.element;
        var transDic = null;
        transDic = this.items.getValue(this.dictionaryProperties.extGState);
        if (transDic == null) {
          transDic = new PdfDictionary();
          this.items.setValue(this.dictionaryProperties.extGState, transDic);
        }
        transDic.items.setValue(arg2.value, new PdfReferenceHolder(savable));
      } else {
        var xobjects = this.Dictionary.items.getValue(this.dictionaryProperties.xObject);
        var parentXObjects = void 0;
        if (typeof this.pdfDocument !== "undefined") {
          parentXObjects = this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.getValue(this.dictionaryProperties.xObject);
        }
        var values = this.Dictionary.items.values();
        var hasSameImageStream = false;
        var oldReference = void 0;
        if (typeof this.pdfDocument !== "undefined" && (typeof parentXObjects === void 0 || parentXObjects == null)) {
          parentXObjects = new PdfDictionary();
          this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.setValue(this.dictionaryProperties.xObject, parentXObjects);
        } else if (typeof this.pdfDocument !== "undefined") {
          var values_1 = parentXObjects.items.values();
          for (var i = 0; i < values_1.length; i++) {
            if (typeof values_1[i] !== "undefined" && typeof values_1[i].element !== "undefined") {
              if (values_1[i].element.data[0] === arg1.element.data[0]) {
                oldReference = values_1[i];
                hasSameImageStream = true;
              }
            }
          }
        }
        if (xobjects == null) {
          xobjects = new PdfDictionary();
          this.Dictionary.items.setValue(this.dictionaryProperties.xObject, xobjects);
        }
        if (hasSameImageStream && typeof oldReference !== "undefined") {
          xobjects.items.setValue(arg2.value, oldReference);
        } else {
          var reference = new PdfReferenceHolder(arg1.element);
          xobjects.items.setValue(arg2.value, reference);
          if (typeof this.pdfDocument !== "undefined") {
            parentXObjects.items.setValue(arg2.value, reference);
          }
        }
      }
    };
    return PdfResources2;
  }(PdfDictionary)
);
var Guid = (
  /** @class */
  function() {
    function Guid2() {
    }
    Guid2.getNewGuidString = function() {
      return "aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa".replace(/[ab]/g, function(c) {
        var random = Math.random() * 16 | 0;
        var result = c === "a" ? random : random & 3 | 8;
        return result.toString(16);
      });
    };
    return Guid2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-tiling-brush.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfTilingBrush = (
  /** @class */
  function(_super) {
    __extends9(PdfTilingBrush2, _super);
    function PdfTilingBrush2(arg1, arg2) {
      var _this = _super.call(this) || this;
      _this.mStroking = false;
      _this.mLocation = new PointF(0, 0);
      _this.mDictionaryProperties = new DictionaryProperties();
      var rect = null;
      if (arg1 instanceof Rectangle) {
        rect = arg1;
      } else if (arg1 instanceof SizeF) {
        rect = new Rectangle(0, 0, arg1.width, arg1.height);
      }
      if (arg2 !== null && arg2 instanceof PdfPage) {
        _this.mPage = arg2;
      }
      _this.brushStream = new PdfStream();
      _this.mResources = new PdfResources();
      _this.brushStream.items.setValue(_this.mDictionaryProperties.resources, _this.mResources);
      _this.setBox(rect);
      _this.setObligatoryFields();
      if (arg2 !== null && arg2 instanceof PdfPage) {
        _this.mPage = arg2;
        _this.graphics.colorSpace = arg2.document.colorSpace;
      }
      return _this;
    }
    PdfTilingBrush2.prototype.initialize = function(rectangle, page, location, matrix) {
      this.mPage = page;
      this.mLocation = location;
      this.mTransformationMatrix = matrix;
      this.tempBrushStream = this.brushStream;
      this.brushStream = new PdfStream();
      var tempResource = new PdfResources();
      this.brushStream.items.setValue(this.mDictionaryProperties.resources, tempResource);
      this.setBox(rectangle);
      this.setObligatoryFields();
      return this;
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "location", {
      //Properties
      /**
       * Location representing the start position of the tiles.
       * @public
       */
      get: function() {
        return this.mLocation;
      },
      set: function(value) {
        this.mLocation = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTilingBrush2.prototype.setObligatoryFields = function() {
      this.brushStream.items.setValue(this.mDictionaryProperties.patternType, new PdfNumber(1));
      this.brushStream.items.setValue(this.mDictionaryProperties.paintType, new PdfNumber(1));
      this.brushStream.items.setValue(this.mDictionaryProperties.tilingType, new PdfNumber(1));
      this.brushStream.items.setValue(this.mDictionaryProperties.xStep, new PdfNumber(this.mBox.right - this.mBox.left));
      this.brushStream.items.setValue(this.mDictionaryProperties.yStep, new PdfNumber(this.mBox.bottom - this.mBox.top));
      if (this.mPage != null && this.mLocation != null) {
        if (this.mTransformationMatrix == null && typeof this.mTransformationMatrix === "undefined") {
          var tileTransform = this.mPage.size.height % this.rectangle.size.height - this.mLocation.y;
          this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([1, 0, 0, 1, this.mLocation.x, tileTransform]));
        } else {
          var tileTransform = 0;
          var elements = this.mTransformationMatrix.matrix.elements;
          if (this.mPage.size.height > this.rectangle.size.height) {
            tileTransform = this.mTransformationMatrix.matrix.offsetY - this.mPage.size.height % this.rectangle.size.height;
          } else {
            tileTransform = this.mPage.size.height % this.rectangle.size.height + this.mTransformationMatrix.matrix.offsetY;
          }
          this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([
            elements[0],
            elements[1],
            elements[2],
            elements[3],
            elements[4],
            tileTransform
          ]));
        }
      }
    };
    PdfTilingBrush2.prototype.setBox = function(box) {
      this.mBox = box;
      var rect = new RectangleF(this.mBox.left, this.mBox.top, this.mBox.right, this.mBox.bottom);
      this.brushStream.items.setValue(this.mDictionaryProperties.bBox, PdfArray.fromRectangle(rect));
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "rectangle", {
      //Properties
      /**
       * Gets the boundary box of the smallest brush cell.
       * @public
       */
      get: function() {
        return this.mBox;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTilingBrush2.prototype, "size", {
      /**
       * Gets the size of the smallest brush cell.
       * @public
       */
      get: function() {
        return this.mBox.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTilingBrush2.prototype, "graphics", {
      /**
       * Gets Graphics context of the brush.
       */
      get: function() {
        if (this.mGraphics == null && typeof this.mGraphics === "undefined") {
          var gr = new GetResourceEventHandler(this);
          var g = new PdfGraphics(this.size, gr, this.brushStream);
          this.mGraphics = g;
          this.mResources = this.getResources();
          this.mGraphics.initializeCoordinates();
        }
        return this.mGraphics;
      },
      enumerable: true,
      configurable: true
    });
    PdfTilingBrush2.prototype.getResources = function() {
      return this.mResources;
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "stroking", {
      /**
       * Gets or sets a value indicating whether this PdfTilingBrush
       * is used for stroking operations.
       */
      get: function() {
        return this.mStroking;
      },
      set: function(value) {
        this.mStroking = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTilingBrush2.prototype.clone = function() {
      var brush = this.initialize(this.rectangle, this.mPage, this.location, this.mTransformationMatrix);
      if (this.mTransformationMatrix != null && this.mTransformationMatrix.matrix != null) {
        brush.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray(this.mTransformationMatrix.matrix.elements));
      }
      brush.brushStream.data = this.tempBrushStream.data;
      brush.mResources = new PdfResources(this.mResources);
      brush.brushStream.items.setValue(this.mDictionaryProperties.resources, brush.mResources);
      return brush;
    };
    PdfTilingBrush2.prototype.monitorChanges = function(brush, streamWriter, getResources, saveChanges, currentColorSpace) {
      var diff = false;
      if (brush !== this) {
        streamWriter.setColorSpace("Pattern", this.mStroking);
        var resources1 = getResources.getResources();
        var name1 = resources1.getName(this);
        streamWriter.setColourWithPattern(null, name1, this.mStroking);
        diff = true;
      } else if (brush instanceof PdfTilingBrush2) {
        streamWriter.setColorSpace("Pattern", this.mStroking);
        var resources = getResources.getResources();
        var name_1 = resources.getName(this);
        streamWriter.setColourWithPattern(null, name_1, this.mStroking);
        diff = true;
      }
      return diff;
    };
    PdfTilingBrush2.prototype.resetChanges = function(streamWriter) {
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "element", {
      /* tslint:enable */
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @public
       */
      get: function() {
        return this.brushStream;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTilingBrush2;
  }(PdfBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-graphics.js
var PdfGraphics = (
  /** @class */
  function() {
    function PdfGraphics2(arg1, arg2, arg3) {
      this.currentColorSpace = PdfColorSpace.Rgb;
      this.previousTextRenderingMode = TextRenderingMode.Fill;
      this.previousCharacterSpacing = 0;
      this.previousWordSpacing = 0;
      this.previousTextScaling = 100;
      this.procedureSets = new ProcedureSets();
      this.isNormalRender = true;
      this.isUseFontSize = false;
      this.isItalic = false;
      this.isEmfTextScaled = false;
      this.isEmf = false;
      this.isEmfPlus = false;
      this.isBaselineFormat = true;
      this.emfScalingFactor = new SizeF(0, 0);
      this.colorSpaceChanged = false;
      this.dictionaryProperties = new DictionaryProperties();
      this.isOverloadWithPosition = false;
      this.isPointOverload = false;
      this.currentColorSpaces = ["RGB", "CMYK", "GrayScale", "Indexed"];
      this.isImageOptimized = false;
      this.graphicsState = [];
      this.istransparencySet = false;
      this.internalAutomaticFields = null;
      this.startCutIndex = -1;
      this.getResources = arg2;
      this.canvasSize = arg1;
      if (arg3 instanceof PdfStreamWriter) {
        this.pdfStreamWriter = arg3;
      } else {
        this.pdfStreamWriter = new PdfStreamWriter(arg3);
      }
      this.initialize();
    }
    Object.defineProperty(PdfGraphics2.prototype, "stringLayoutResult", {
      //  Properties
      /**
       * Returns the `result` after drawing string.
       * @private
       */
      get: function() {
        return this.pdfStringLayoutResult;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "size", {
      /**
       * Gets the `size` of the canvas.
       * @private
       */
      get: function() {
        return this.canvasSize;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "mediaBoxUpperRightBound", {
      /**
       * Gets and Sets the value of `MediaBox upper right bound`.
       * @private
       */
      get: function() {
        if (typeof this.internalMediaBoxUpperRightBound === "undefined") {
          this.internalMediaBoxUpperRightBound = 0;
        }
        return this.internalMediaBoxUpperRightBound;
      },
      set: function(value) {
        this.internalMediaBoxUpperRightBound = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "clientSize", {
      /**
       * Gets the `size` of the canvas reduced by margins and page templates.
       * @private
       */
      get: function() {
        return new SizeF(this.clipBounds.width, this.clipBounds.height);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "colorSpace", {
      /**
       * Gets or sets the current `color space` of the document
       * @private
       */
      get: function() {
        return this.currentColorSpace;
      },
      set: function(value) {
        this.currentColorSpace = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "streamWriter", {
      /**
       * Gets the `stream writer`.
       * @private
       */
      get: function() {
        return this.pdfStreamWriter;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "matrix", {
      /**
       * Gets the `transformation matrix` reflecting current transformation.
       * @private
       */
      get: function() {
        if (this.transformationMatrix == null) {
          this.transformationMatrix = new PdfTransformationMatrix();
        }
        return this.transformationMatrix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "layer", {
      /**
       * Gets the `layer` for the graphics, if exists.
       * @private
       */
      get: function() {
        return this.pageLayer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "page", {
      /**
       * Gets the `page` for this graphics, if exists.
       * @private
       */
      get: function() {
        return this.pageLayer.page;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "automaticFields", {
      get: function() {
        if (this.internalAutomaticFields == null || typeof this.internalAutomaticFields === "undefined") {
          this.internalAutomaticFields = new PdfAutomaticFieldInfoCollection();
        }
        return this.internalAutomaticFields;
      },
      enumerable: true,
      configurable: true
    });
    PdfGraphics2.prototype.initialize = function() {
      this.bStateSaved = false;
      this.currentPen = null;
      this.currentBrush = null;
      this.currentFont = null;
      this.currentColorSpace = PdfColorSpace.Rgb;
      this.bCSInitialized = false;
      this.transformationMatrix = null;
      this.previousTextRenderingMode = -1;
      this.previousCharacterSpacing = -1;
      this.previousWordSpacing = -1;
      this.previousTextScaling = -100;
      this.currentStringFormat = null;
      this.clipBounds = new RectangleF(new PointF(0, 0), this.size);
      this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
    };
    PdfGraphics2.prototype.drawPdfTemplate = function(template, location, size) {
      if (typeof size === "undefined") {
        if (template == null) {
          throw Error("ArgumentNullException-template");
        }
        this.drawPdfTemplate(template, location, template.size);
      } else {
        if (template == null) {
          throw Error("ArgumentNullException-template");
        }
        var scaleX = template.width > 0 ? size.width / template.width : 1;
        var scaleY = template.height > 0 ? size.height / template.height : 1;
        var bNeedScale = !(scaleX === 1 && scaleY === 1);
        var state = this.save();
        var matrix = new PdfTransformationMatrix();
        if (this.pageLayer != null) {
          this.getTranslateTransform(location.x, location.y + size.height, matrix);
        }
        if (bNeedScale) {
          this.getScaleTransform(scaleX, scaleY, matrix);
        }
        this.pdfStreamWriter.modifyCtm(matrix);
        var resources = this.getResources.getResources();
        var name_1 = resources.getName(template);
        this.pdfStreamWriter.executeObject(name_1);
        this.restore(state);
        var g = template.graphics;
        if (g != null) {
          for (var index = 0; index < g.automaticFields.automaticFields.length; index++) {
            var fieldInfo = g.automaticFields.automaticFields[index];
            var newLocation = new PointF(fieldInfo.location.x + location.x, fieldInfo.location.y + location.y);
            var scalingX = template.size.width == 0 ? 0 : size.width / template.size.width;
            var scalingY = template.size.height == 0 ? 0 : size.height / template.size.height;
            this.automaticFields.add(new PdfAutomaticFieldInfo(fieldInfo.field, newLocation, scalingX, scalingY));
            this.page.dictionary.modify();
          }
        }
        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageB);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageC);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageI);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
      }
    };
    PdfGraphics2.prototype.drawString = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
      if (typeof arg1 === "string" && arg2 instanceof PdfFont && (arg3 instanceof PdfPen || arg3 === null) && (arg4 instanceof PdfBrush || arg4 === null) && typeof arg5 === "number" && typeof arg6 === "number" && (arg7 instanceof PdfStringFormat || arg7 === null) && typeof arg8 === "undefined") {
        this.isOverloadWithPosition = true;
        this.drawString(arg1, arg2, arg3, arg4, arg5, arg6, this.clientSize.width - arg5, 0, arg7);
      } else {
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        var temparg6 = arg6;
        var temparg7 = arg7;
        var temparg8 = arg8;
        var temparg9 = arg9;
        var layouter = new PdfStringLayouter();
        var result = layouter.layout(arg1, arg2, temparg9, new SizeF(temparg7, temparg8), this.isOverloadWithPosition, this.clientSize);
        if (!result.empty) {
          var rect = this.checkCorrectLayoutRectangle(result.actualSize, temparg5, temparg6, temparg9);
          if (temparg7 <= 0) {
            temparg5 = rect.x;
            temparg7 = rect.width;
          }
          if (temparg8 <= 0) {
            temparg6 = rect.y;
            temparg8 = rect.height;
          }
          this.drawStringLayoutResult(result, arg2, temparg3, temparg4, new RectangleF(temparg5, temparg6, temparg7, temparg8), temparg9);
          this.isEmfTextScaled = false;
          this.emfScalingFactor = new SizeF(0, 0);
        }
        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
        this.isNormalRender = true;
        this.pdfStringLayoutResult = result;
        this.isUseFontSize = false;
      }
    };
    PdfGraphics2.prototype.drawLine = function(arg1, arg2, arg3, arg4, arg5) {
      if (arg2 instanceof PointF) {
        var temparg2 = arg2;
        var temparg3 = arg3;
        this.drawLine(arg1, temparg2.x, temparg2.y, temparg3.x, temparg3.y);
      } else {
        var temparg2 = arg2;
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        this.stateControl(arg1, null, null);
        var sw = this.streamWriter;
        sw.beginPath(temparg2, temparg3);
        sw.appendLineSegment(temparg4, temparg5);
        sw.strokePath();
        this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
      }
    };
    PdfGraphics2.prototype.drawRectangle = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof PdfPen && typeof arg2 === "number") {
        var temparg3 = arg3;
        this.drawRectangle(arg1, null, arg2, temparg3, arg4, arg5);
      } else if (arg1 instanceof PdfBrush && typeof arg2 === "number") {
        var temparg3 = arg3;
        this.drawRectangle(null, arg1, arg2, temparg3, arg4, arg5);
      } else {
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        var temparg6 = arg6;
        if (arg2 instanceof PdfTilingBrush) {
          this.bCSInitialized = false;
          var xOffset = this.matrix.matrix.offsetX + temparg3;
          var yOffset = void 0;
          if (this.layer != null && this.layer.page != null) {
            yOffset = this.layer.page.size.height - this.matrix.matrix.offsetY + temparg4;
          } else {
            yOffset = this.clientSize.height - this.matrix.matrix.offsetY + temparg4;
          }
          arg2.location = new PointF(xOffset, yOffset);
          arg2.graphics.colorSpace = this.colorSpace;
        } else if (arg2 instanceof PdfGradientBrush) {
          arg2.colorSpace = this.colorSpace;
        }
        if (arg2 instanceof PdfSolidBrush && arg2.color.isEmpty) {
          arg2 = null;
        }
        var temparg1 = arg1;
        var temparg2 = arg2;
        this.stateControl(temparg1, temparg2, null);
        this.streamWriter.appendRectangle(temparg3, temparg4, temparg5, temparg6);
        this.drawPathHelper(temparg1, temparg2, false);
      }
    };
    PdfGraphics2.prototype.drawPathHelper = function(arg1, arg2, arg3, arg4) {
      if (typeof arg3 === "boolean") {
        var temparg3 = arg3;
        this.drawPathHelper(arg1, arg2, PdfFillMode.Winding, temparg3);
      } else {
        var temparg3 = arg3;
        var temparg4 = arg4;
        var isPen = arg1 != null;
        var isBrush = arg2 != null;
        var isEvenOdd = temparg3 === PdfFillMode.Alternate;
        if (isPen && isBrush) {
          this.streamWriter.fillStrokePath(isEvenOdd);
        } else if (!isPen && !isBrush) {
          this.streamWriter.endPath();
        } else if (isPen) {
          this.streamWriter.strokePath();
        } else {
          this.streamWriter.fillPath(isEvenOdd);
        }
      }
    };
    PdfGraphics2.prototype.drawImage = function(arg1, arg2, arg3, arg4, arg5) {
      if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        var size = arg1.physicalDimension;
        this.drawImage(arg1, arg2, arg3, size.width, size.height);
      } else {
        var temparg2 = arg2;
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        arg1.save();
        var matrix = new PdfTransformationMatrix();
        this.getTranslateTransform(temparg2, temparg3 + temparg5, matrix);
        this.getScaleTransform(arg4, arg5, matrix);
        this.pdfStreamWriter.write("q");
        this.pdfStreamWriter.modifyCtm(matrix);
        var resources = this.getResources.getResources();
        if (typeof this.pageLayer !== "undefined" && this.page != null) {
          resources.document = this.page.document;
        }
        var name_2 = resources.getName(arg1);
        if (typeof this.pageLayer !== "undefined") {
          this.page.setResources(resources);
        }
        this.pdfStreamWriter.executeObject(name_2);
        this.pdfStreamWriter.write(Operators.restoreState);
        this.pdfStreamWriter.write(Operators.newLine);
        var resource = this.getResources.getResources();
        resource.requireProcedureSet(this.procedureSets.imageB);
        resource.requireProcedureSet(this.procedureSets.imageC);
        resource.requireProcedureSet(this.procedureSets.imageI);
        resource.requireProcedureSet(this.procedureSets.text);
      }
    };
    PdfGraphics2.prototype.getLineBounds = function(lineIndex, result, font, layoutRectangle, format) {
      var bounds;
      if (!result.empty && lineIndex < result.lineCount && lineIndex >= 0) {
        var line = result.lines[lineIndex];
        var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
        var y = vShift + layoutRectangle.y + result.lineHeight * lineIndex;
        var lineWidth = line.width;
        var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
        var lineIndent = this.getLineIndent(line, format, layoutRectangle, lineIndex === 0);
        hShift += !this.rightToLeft(format) ? lineIndent : 0;
        var x = layoutRectangle.x + hShift;
        var width = !this.shouldJustify(line, layoutRectangle.width, format) ? lineWidth - lineIndent : layoutRectangle.width - lineIndent;
        var height = result.lineHeight;
        bounds = new RectangleF(x, y, width, height);
      } else {
        bounds = new RectangleF(0, 0, 0, 0);
      }
      return bounds;
    };
    PdfGraphics2.prototype.checkCorrectLayoutRectangle = function(textSize, x, y, format) {
      var layoutedRectangle = new RectangleF(x, y, textSize.width, textSize.width);
      if (format != null) {
        switch (format.alignment) {
          case PdfTextAlignment.Center:
            layoutedRectangle.x -= layoutedRectangle.width / 2;
            break;
          case PdfTextAlignment.Right:
            layoutedRectangle.x -= layoutedRectangle.width;
            break;
        }
        switch (format.lineAlignment) {
          case PdfVerticalAlignment.Middle:
            layoutedRectangle.y -= layoutedRectangle.height / 2;
            break;
          case PdfVerticalAlignment.Bottom:
            layoutedRectangle.y -= layoutedRectangle.height;
            break;
        }
      }
      return layoutedRectangle;
    };
    PdfGraphics2.prototype.setLayer = function(layer) {
      this.pageLayer = layer;
      var page = layer.page;
      if (page != null && typeof page !== "undefined") {
        page.beginSave = this.pageSave;
      }
    };
    PdfGraphics2.prototype.pageSave = function(page) {
      if (page.graphics.automaticFields != null) {
        for (var i = 0; i < page.graphics.automaticFields.automaticFields.length; i++) {
          var fieldInfo = page.graphics.automaticFields.automaticFields[i];
          fieldInfo.field.performDraw(page.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
        }
      }
    };
    PdfGraphics2.prototype.drawStringLayoutResult = function(result, font, pen, brush, layoutRectangle, format) {
      if (!result.empty) {
        this.applyStringSettings(font, pen, brush, format, layoutRectangle);
        var textScaling = format != null ? format.horizontalScalingFactor : 100;
        if (textScaling !== this.previousTextScaling && !this.isEmfTextScaled) {
          this.pdfStreamWriter.setTextScaling(textScaling);
          this.previousTextScaling = textScaling;
        }
        var height = format == null || format.lineSpacing === 0 ? font.height : format.lineSpacing + font.height;
        var subScript = format != null && format.subSuperScript === PdfSubSuperScript.SubScript;
        var shift = 0;
        shift = subScript ? height - (font.height + font.metrics.getDescent(format)) : height - font.metrics.getAscent(format);
        this.shift = shift;
        this.pdfStreamWriter.startNextLine(layoutRectangle.x, layoutRectangle.y - shift);
        this.pdfStreamWriter.setLeading(+height);
        var resultHeight = 0;
        var remainingString = "";
        for (var i = 0; i < result.lines.length; i++) {
          resultHeight += result.lineHeight;
          if (layoutRectangle.y + resultHeight > this.clientSize.height) {
            this.startCutIndex = i;
            break;
          }
        }
        for (var j = this.startCutIndex; j < result.lines.length && j >= 0; j++) {
          remainingString += result.lines[j].text;
        }
        var bounds = new RectangleF(layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height);
        this.drawLayoutResult(result, font, format, layoutRectangle);
        this.underlineStrikeoutText(pen, brush, result, font, bounds, format);
        this.isEmfPlus = false;
        this.isUseFontSize = false;
        if (this.startCutIndex !== -1) {
          var page = this.getNextPage();
          page.graphics.drawString(remainingString, font, pen, brush, layoutRectangle.x, 0, layoutRectangle.width, 0, format);
        }
      } else {
        throw new Error("ArgumentNullException:result");
      }
    };
    PdfGraphics2.prototype.getNextPage = function() {
      var section = this.currentPage.section;
      var nextPage = null;
      var index = section.indexOf(this.currentPage);
      if (index === section.count - 1) {
        nextPage = section.add();
      } else {
        nextPage = section.getPages()[index + 1];
      }
      return nextPage;
    };
    PdfGraphics2.prototype.setClip = function(rectangle, mode) {
      if (typeof mode === "undefined") {
        this.setClip(rectangle, PdfFillMode.Winding);
      } else {
        this.pdfStreamWriter.appendRectangle(rectangle);
        this.pdfStreamWriter.clipPath(mode === PdfFillMode.Alternate);
      }
    };
    PdfGraphics2.prototype.applyStringSettings = function(font, pen, brush, format, bounds) {
      if (brush instanceof PdfTilingBrush) {
        this.bCSInitialized = false;
        brush.graphics.colorSpace = this.colorSpace;
      } else if (brush instanceof PdfGradientBrush) {
        this.bCSInitialized = false;
        brush.colorSpace = this.colorSpace;
      }
      var setLineWidth = false;
      var tm = this.getTextRenderingMode(pen, brush, format);
      this.stateControl(pen, brush, font, format);
      this.pdfStreamWriter.beginText();
      if (tm !== this.previousTextRenderingMode) {
        this.pdfStreamWriter.setTextRenderingMode(tm);
        this.previousTextRenderingMode = tm;
      }
      var cs = format != null ? format.characterSpacing : 0;
      if (cs !== this.previousCharacterSpacing && !this.isEmfTextScaled) {
        this.pdfStreamWriter.setCharacterSpacing(cs);
        this.previousCharacterSpacing = cs;
      }
      var ws = format != null ? format.wordSpacing : 0;
      if (ws !== this.previousWordSpacing) {
        this.pdfStreamWriter.setWordSpacing(ws);
        this.previousWordSpacing = ws;
      }
    };
    PdfGraphics2.prototype.getTextVerticalAlignShift = function(textHeight, boundsHeight, format) {
      var shift = 0;
      if (boundsHeight >= 0 && format != null && format.lineAlignment !== PdfVerticalAlignment.Top) {
        switch (format.lineAlignment) {
          case PdfVerticalAlignment.Middle:
            shift = (boundsHeight - textHeight) / 2;
            break;
          case PdfVerticalAlignment.Bottom:
            shift = boundsHeight - textHeight;
            break;
        }
      }
      return shift;
    };
    PdfGraphics2.prototype.drawLayoutResult = function(result, font, format, layoutRectangle) {
      var vAlignShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
      if (vAlignShift !== 0) {
        this.pdfStreamWriter.startNextLine(0, vAlignShift);
      }
      var ttfFont = font;
      var unicode = ttfFont != null && ttfFont.isUnicode;
      var embed = ttfFont != null && ttfFont.isEmbedFont;
      var lines = result.lines;
      for (var i = 0, len = lines.length; i < len && i !== this.startCutIndex; i++) {
        var lineInfo = lines[i];
        var line = lineInfo.text;
        var lineWidth = lineInfo.width;
        var hAlignShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
        var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, i === 0);
        hAlignShift += !this.rightToLeft(format) ? lineIndent : 0;
        if (hAlignShift !== 0 && !this.isEmfTextScaled) {
          this.pdfStreamWriter.startNextLine(hAlignShift, 0);
        }
        if (unicode) {
          this.drawUnicodeLine(lineInfo, layoutRectangle, font, format);
        } else {
          this.drawAsciiLine(lineInfo, layoutRectangle, font, format);
        }
        if (hAlignShift !== 0 && !this.isEmfTextScaled) {
          this.pdfStreamWriter.startNextLine(-hAlignShift, 0);
        }
        if (this.isOverloadWithPosition && lines.length > 1) {
          this.pdfStreamWriter.startNextLine(-layoutRectangle.x, 0);
          layoutRectangle.x = 0;
          layoutRectangle.width = this.clientSize.width;
          this.isOverloadWithPosition = false;
          this.isPointOverload = true;
        }
      }
      this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
      if (vAlignShift !== 0) {
        this.pdfStreamWriter.startNextLine(0, -(vAlignShift - result.lineHeight));
      }
      this.pdfStreamWriter.endText();
    };
    PdfGraphics2.prototype.drawAsciiLine = function(lineInfo, layoutRectangle, font, format) {
      this.justifyLine(lineInfo, layoutRectangle.width, format);
      var value = "";
      if (lineInfo.text.indexOf("(") !== -1 || lineInfo.text.indexOf(")") !== -1) {
        for (var i = 0; i < lineInfo.text.length; i++) {
          if (lineInfo.text[i] === "(") {
            value += "\\(";
          } else if (lineInfo.text[i] === ")") {
            value += "\\)";
          } else {
            value += lineInfo.text[i];
          }
        }
      }
      if (value === "") {
        value = lineInfo.text;
      }
      var line = "(" + value + ")";
      this.pdfStreamWriter.showNextLineText(new PdfString(line));
    };
    PdfGraphics2.prototype.drawUnicodeLine = function(lineInfo, layoutRectangle, font, format) {
      var line = lineInfo.text;
      var lineWidth = lineInfo.width;
      var rtl = format !== null && typeof format !== "undefined" && format.rightToLeft;
      var useWordSpace = format !== null && typeof format !== "undefined" && (format.wordSpacing !== 0 || format.alignment === PdfTextAlignment.Justify);
      var ttfFont = font;
      var wordSpacing = this.justifyLine(lineInfo, layoutRectangle.width, format);
      var rtlRender = new RtlRenderer();
      if (rtl || format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
        var blocks = null;
        var rightAlign = format !== null && typeof format !== "undefined" && format.alignment === PdfTextAlignment.Right;
        if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
          blocks = rtlRender.layout(line, ttfFont, format.textDirection === PdfTextDirection.RightToLeft ? true : false, useWordSpace, format);
        } else {
          blocks = rtlRender.layout(line, ttfFont, rightAlign, useWordSpace, format);
        }
        var words = null;
        if (blocks.length > 1) {
          if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
            words = rtlRender.splitLayout(line, ttfFont, format.textDirection === PdfTextDirection.RightToLeft ? true : false, useWordSpace, format);
          } else {
            words = rtlRender.splitLayout(line, ttfFont, rightAlign, useWordSpace, format);
          }
        } else {
          words = [line];
        }
        this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
      } else {
        if (useWordSpace) {
          var result = this.breakUnicodeLine(line, ttfFont, null);
          var blocks = result.tokens;
          var words = result.words;
          this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
        } else {
          var token = this.convertToUnicode(line, ttfFont);
          var value = this.getUnicodeString(token);
          this.streamWriter.showNextLineText(value);
        }
      }
    };
    PdfGraphics2.prototype.drawUnicodeBlocks = function(blocks, words, font, format, wordSpacing) {
      if (blocks == null) {
        throw new Error("Argument Null Exception : blocks");
      }
      if (words == null) {
        throw new Error("Argument Null Exception : words");
      }
      if (font == null) {
        throw new Error("Argument Null Exception : font");
      }
      this.streamWriter.startNextLine();
      var x = 0;
      var xShift = 0;
      var firstLineIndent = 0;
      var paragraphIndent = 0;
      try {
        if (format !== null && typeof format !== "undefined") {
          firstLineIndent = format.firstLineIndent;
          paragraphIndent = format.paragraphIndent;
          format.firstLineIndent = 0;
          format.paragraphIndent = 0;
        }
        var spaceWidth = font.getCharWidth(StringTokenizer.whiteSpace, format) + wordSpacing;
        var characterSpacing = format != null ? format.characterSpacing : 0;
        var wordSpace = format !== null && typeof format !== "undefined" && wordSpacing === 0 ? format.wordSpacing : 0;
        spaceWidth += characterSpacing + wordSpace;
        for (var i = 0; i < blocks.length; i++) {
          var token = blocks[i];
          var word = words[i];
          var tokenWidth = 0;
          if (x !== 0) {
            this.streamWriter.startNextLine(x, 0);
          }
          if (word.length > 0) {
            tokenWidth += /*Utils.Round(*/
            font.measureString(word, format).width;
            tokenWidth += characterSpacing;
            var val = this.getUnicodeString(token);
            this.streamWriter.showText(val);
          }
          if (i !== blocks.length - 1) {
            x = tokenWidth + spaceWidth;
            xShift += x;
          }
        }
        if (xShift > 0) {
          this.streamWriter.startNextLine(-xShift, 0);
        }
      } finally {
        if (format !== null && typeof format !== "undefined") {
          format.firstLineIndent = firstLineIndent;
          format.paragraphIndent = paragraphIndent;
        }
      }
    };
    PdfGraphics2.prototype.breakUnicodeLine = function(line, ttfFont, words) {
      if (line === null) {
        throw new Error("Argument Null Exception : line");
      }
      words = line.split(null);
      var tokens = [];
      for (var i = 0; i < words.length; i++) {
        var word = words[i];
        var token = this.convertToUnicode(word, ttfFont);
        tokens[i] = token;
      }
      return { tokens, words };
    };
    PdfGraphics2.prototype.getUnicodeString = function(token) {
      if (token === null) {
        throw new Error("Argument Null Exception : token");
      }
      var val = new PdfString(token);
      val.converted = true;
      val.encode = InternalEnum.ForceEncoding.Ascii;
      return val;
    };
    PdfGraphics2.prototype.convertToUnicode = function(text, ttfFont) {
      var token = null;
      if (text == null) {
        throw new Error("Argument Null Exception : text");
      }
      if (ttfFont == null) {
        throw new Error("Argument Null Exception : ttfFont");
      }
      if (ttfFont.fontInternal instanceof UnicodeTrueTypeFont) {
        var ttfReader = ttfFont.fontInternal.ttfReader;
        ttfFont.setSymbols(text);
        token = ttfReader.convertString(text);
        var bytes = PdfString.toUnicodeArray(token, false);
        token = PdfString.byteToString(bytes);
      }
      return token;
    };
    PdfGraphics2.prototype.justifyLine = function(lineInfo, boundsWidth, format) {
      var line = lineInfo.text;
      var lineWidth = lineInfo.width;
      var shouldJustify = this.shouldJustify(lineInfo, boundsWidth, format);
      var hasWordSpacing = format != null && format.wordSpacing !== 0;
      var symbols = StringTokenizer.spaces;
      var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
      var wordSpace = 0;
      if (shouldJustify) {
        if (hasWordSpacing) {
          lineWidth -= whitespacesCount * format.wordSpacing;
        }
        var difference = boundsWidth - lineWidth;
        wordSpace = difference / whitespacesCount;
        this.pdfStreamWriter.setWordSpacing(wordSpace);
      } else {
        if (hasWordSpacing) {
          this.pdfStreamWriter.setWordSpacing(format.wordSpacing);
        } else {
          this.pdfStreamWriter.setWordSpacing(0);
        }
      }
      return wordSpace;
    };
    PdfGraphics2.prototype.reset = function(size) {
      this.canvasSize = size;
      this.streamWriter.clear();
      this.initialize();
      this.initializeCoordinates();
    };
    PdfGraphics2.prototype.shouldJustify = function(lineInfo, boundsWidth, format) {
      var line = lineInfo.text;
      var lineWidth = lineInfo.width;
      var justifyStyle = format != null && format.alignment === PdfTextAlignment.Justify;
      var goodWidth = boundsWidth >= 0 && lineWidth < boundsWidth;
      var symbols = StringTokenizer.spaces;
      var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
      var hasSpaces = whitespacesCount > 0 && line[0] !== StringTokenizer.whiteSpace;
      var goodLineBreakStyle = (lineInfo.lineType & LineType.LayoutBreak) > 0;
      var shouldJustify = justifyStyle && goodWidth && hasSpaces && (goodLineBreakStyle || format.alignment === PdfTextAlignment.Justify);
      return shouldJustify;
    };
    PdfGraphics2.prototype.underlineStrikeoutText = function(pen, brush, result, font, layoutRectangle, format) {
      if (font.underline || font.strikeout) {
        var linePen = this.createUnderlineStikeoutPen(pen, brush, font, format);
        if (linePen != null) {
          var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
          var underlineYOffset = 0;
          underlineYOffset = layoutRectangle.y + vShift + font.metrics.getAscent(format) + 1.5 * linePen.width;
          var strikeoutYOffset = layoutRectangle.y + vShift + font.metrics.getHeight(format) / 2 + 1.5 * linePen.width;
          var lines = result.lines;
          for (var i = 0, len = result.lineCount; i < len; i++) {
            var lineInfo = lines[i];
            var line = lineInfo.text;
            var lineWidth = lineInfo.width;
            var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
            var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, i === 0);
            hShift += !this.rightToLeft(format) ? lineIndent : 0;
            var x1 = layoutRectangle.x + hShift;
            var x2 = !this.shouldJustify(lineInfo, layoutRectangle.width, format) ? x1 + lineWidth - lineIndent : x1 + layoutRectangle.width - lineIndent;
            if (font.underline) {
              var y = underlineYOffset;
              this.drawLine(linePen, x1, y, x2, y);
              underlineYOffset += result.lineHeight;
            }
            if (font.strikeout) {
              var y = strikeoutYOffset;
              this.drawLine(linePen, x1, y, x2, y);
              strikeoutYOffset += result.lineHeight;
            }
            if (this.isPointOverload && lines.length > 1) {
              layoutRectangle.x = 0;
              layoutRectangle.width = this.clientSize.width;
            }
          }
          this.isPointOverload = false;
        }
      }
    };
    PdfGraphics2.prototype.createUnderlineStikeoutPen = function(pen, brush, font, format) {
      var lineWidth = font.metrics.getSize(format) / 20;
      var linePen = null;
      if (pen != null) {
        linePen = new PdfPen(pen.color, lineWidth);
      } else if (brush != null) {
        linePen = new PdfPen(brush, lineWidth);
      }
      return linePen;
    };
    PdfGraphics2.prototype.getTextRenderingMode = function(pen, brush, format) {
      var tm = TextRenderingMode.None;
      if (pen != null && brush != null) {
        tm = TextRenderingMode.FillStroke;
      } else if (pen != null) {
        tm = TextRenderingMode.Stroke;
      } else {
        tm = TextRenderingMode.Fill;
      }
      if (format != null && format.clipPath) {
        tm |= TextRenderingMode.ClipFlag;
      }
      return tm;
    };
    PdfGraphics2.prototype.getLineIndent = function(lineInfo, format, layoutBounds, firstLine) {
      var lineIndent = 0;
      var firstParagraphLine = (lineInfo.lineType & LineType.FirstParagraphLine) > 0;
      if (format != null && firstParagraphLine) {
        lineIndent = firstLine ? format.firstLineIndent : format.paragraphIndent;
        lineIndent = layoutBounds.width > 0 ? Math.min(layoutBounds.width, lineIndent) : lineIndent;
      }
      return lineIndent;
    };
    PdfGraphics2.prototype.getHorizontalAlignShift = function(lineWidth, boundsWidth, format) {
      var shift = 0;
      if (boundsWidth >= 0 && format != null && format.alignment !== PdfTextAlignment.Left) {
        switch (format.alignment) {
          case PdfTextAlignment.Center:
            shift = (boundsWidth - lineWidth) / 2;
            break;
          case PdfTextAlignment.Right:
            shift = boundsWidth - lineWidth;
            break;
        }
      }
      return shift;
    };
    PdfGraphics2.prototype.rightToLeft = function(format) {
      var rtl = format !== null && typeof format !== "undefined" && format.rightToLeft;
      if (format !== null && typeof format !== "undefined") {
        if (format.textDirection !== PdfTextDirection.None && typeof format.textDirection !== "undefined") {
          rtl = true;
        }
      }
      return rtl;
    };
    PdfGraphics2.prototype.stateControl = function(pen, brush, font, format) {
      if (typeof format === "undefined") {
        this.stateControl(pen, brush, font, null);
      } else {
        if (brush instanceof PdfGradientBrush) {
          this.bCSInitialized = false;
          brush.colorSpace = this.colorSpace;
        }
        if (brush instanceof PdfTilingBrush) {
          this.bCSInitialized = false;
          brush.graphics.colorSpace = this.colorSpace;
        }
        var saveState = false;
        if (brush !== null) {
          var solidBrush = brush;
          if (typeof this.pageLayer !== "undefined" && this.pageLayer != null) {
            if (this.colorSpaceChanged === false) {
              this.lastDocumentCS = this.pageLayer.page.document.colorSpace;
              this.lastGraphicsCS = this.pageLayer.page.graphics.colorSpace;
              this.colorSpace = this.pageLayer.page.document.colorSpace;
              this.currentColorSpace = this.pageLayer.page.document.colorSpace;
              this.colorSpaceChanged = true;
            }
          }
          this.initCurrentColorSpace(this.currentColorSpace);
        } else if (pen != null) {
          var pdfPen = pen;
          if (typeof this.pageLayer !== "undefined" && this.pageLayer != null) {
            this.colorSpace = this.pageLayer.page.document.colorSpace;
            this.currentColorSpace = this.pageLayer.page.document.colorSpace;
          }
          this.initCurrentColorSpace(this.currentColorSpace);
        }
        this.penControl(pen, saveState);
        this.brushControl(brush, saveState);
        this.fontControl(font, format, saveState);
      }
    };
    PdfGraphics2.prototype.initCurrentColorSpace = function(colorspace) {
      var re = this.getResources.getResources();
      if (!this.bCSInitialized) {
        if (this.currentColorSpace != PdfColorSpace.GrayScale) {
          this.pdfStreamWriter.setColorSpace("Device" + this.currentColorSpaces[this.currentColorSpace], true);
          this.pdfStreamWriter.setColorSpace("Device" + this.currentColorSpaces[this.currentColorSpace], false);
          this.bCSInitialized = true;
        } else {
          this.pdfStreamWriter.setColorSpace("DeviceGray", true);
          this.pdfStreamWriter.setColorSpace("DeviceGray", false);
          this.bCSInitialized = true;
        }
      }
    };
    PdfGraphics2.prototype.penControl = function(pen, saveState) {
      if (pen != null) {
        this.currentPen = pen;
        pen.monitorChanges(this.currentPen, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace, this.matrix.clone());
        this.currentPen = pen.clone();
      }
    };
    PdfGraphics2.prototype.brushControl = function(brush, saveState) {
      if (brush != null && typeof brush !== "undefined") {
        var b = brush.clone();
        var lgb = b;
        if (lgb !== null && typeof lgb !== "undefined" && !(brush instanceof PdfSolidBrush) && !(brush instanceof PdfTilingBrush)) {
          var m = lgb.matrix;
          var matrix = this.matrix.clone();
          if (m != null) {
            m.multiply(matrix);
            matrix = m;
          }
          lgb.matrix = matrix;
        }
        this.currentBrush = lgb;
        var br = brush;
        b.monitorChanges(this.currentBrush, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace);
        this.currentBrush = brush;
        brush = null;
      }
    };
    PdfGraphics2.prototype.fontControl = function(font, format, saveState) {
      if (font != null) {
        var curSubSuper = format != null ? format.subSuperScript : PdfSubSuperScript.None;
        var prevSubSuper = this.currentStringFormat != null ? this.currentStringFormat.subSuperScript : PdfSubSuperScript.None;
        if (saveState || font !== this.currentFont || curSubSuper !== prevSubSuper) {
          var resources = this.getResources.getResources();
          this.currentFont = font;
          this.currentStringFormat = format;
          var size = font.metrics.getSize(format);
          this.isEmfTextScaled = false;
          var fontName = resources.getName(font);
          this.pdfStreamWriter.setFont(font, fontName, size);
        }
      }
    };
    PdfGraphics2.prototype.setTransparency = function(arg1, arg2, arg3) {
      if (typeof arg2 === "undefined") {
        this.istransparencySet = true;
        this.setTransparency(arg1, arg1, PdfBlendMode.Normal);
      } else if (typeof arg2 === "number" && typeof arg3 === "undefined") {
        this.setTransparency(arg1, arg2, PdfBlendMode.Normal);
      } else {
        if (this.trasparencies == null) {
          this.trasparencies = new TemporaryDictionary();
        }
        var transp = null;
        var td = new TransparencyData(arg1, arg2, arg3);
        if (this.trasparencies.containsKey(td)) {
          transp = this.trasparencies.getValue(td);
        }
        if (transp == null) {
          transp = new PdfTransparency(arg1, arg2, arg3);
          this.trasparencies.setValue(td, transp);
        }
        var resources = this.getResources.getResources();
        var name_3 = resources.getName(transp);
        var sw = this.streamWriter;
        sw.setGraphicsState(name_3);
      }
    };
    PdfGraphics2.prototype.clipTranslateMargins = function(x, y, left, top, right, bottom) {
      if (x instanceof RectangleF && typeof y === "undefined") {
        this.clipBounds = x;
        this.pdfStreamWriter.writeComment("Clip margins.");
        this.pdfStreamWriter.appendRectangle(x);
        this.pdfStreamWriter.closePath();
        this.pdfStreamWriter.clipPath(false);
        this.pdfStreamWriter.writeComment("Translate co-ordinate system.");
        this.translateTransform(x.x, x.y);
      } else if (typeof x === "number") {
        var clipArea = new RectangleF(left, top, this.size.width - left - right, this.size.height - top - bottom);
        this.clipBounds = clipArea;
        this.pdfStreamWriter.writeComment("Clip margins.");
        this.pdfStreamWriter.appendRectangle(clipArea);
        this.pdfStreamWriter.closePath();
        this.pdfStreamWriter.clipPath(false);
        this.pdfStreamWriter.writeComment("Translate co-ordinate system.");
        this.translateTransform(x, y);
      }
    };
    PdfGraphics2.prototype.updateY = function(y) {
      return -y;
    };
    PdfGraphics2.prototype.translateTransform = function(offsetX, offsetY) {
      var matrix = new PdfTransformationMatrix();
      this.getTranslateTransform(offsetX, offsetY, matrix);
      this.pdfStreamWriter.modifyCtm(matrix);
      this.matrix.multiply(matrix);
    };
    PdfGraphics2.prototype.getTranslateTransform = function(x, y, input) {
      input.translate(x, this.updateY(y));
      return input;
    };
    PdfGraphics2.prototype.scaleTransform = function(scaleX, scaleY) {
      var matrix = new PdfTransformationMatrix();
      this.getScaleTransform(scaleX, scaleY, matrix);
      this.pdfStreamWriter.modifyCtm(matrix);
      this.matrix.multiply(matrix);
    };
    PdfGraphics2.prototype.getScaleTransform = function(x, y, input) {
      if (input == null) {
        input = new PdfTransformationMatrix();
      }
      input.scale(x, y);
      return input;
    };
    PdfGraphics2.prototype.rotateTransform = function(angle) {
      var matrix = new PdfTransformationMatrix();
      this.getRotateTransform(angle, matrix);
      this.pdfStreamWriter.modifyCtm(matrix);
      this.matrix.multiply(matrix);
    };
    PdfGraphics2.prototype.initializeCoordinates = function() {
      this.pdfStreamWriter.writeComment("Change co-ordinate system to left/top.");
      if (this.mediaBoxUpperRightBound !== -this.size.height) {
        if (this.cropBox == null) {
          if (this.mediaBoxUpperRightBound === this.size.height || this.mediaBoxUpperRightBound === 0) {
            this.translateTransform(0, this.updateY(this.size.height));
          } else {
            this.translateTransform(0, this.updateY(this.mediaBoxUpperRightBound));
          }
        }
      }
    };
    PdfGraphics2.prototype.getRotateTransform = function(angle, input) {
      if (input == null || typeof input === "undefined") {
        input = new PdfTransformationMatrix();
      }
      input.rotate(this.updateY(angle));
      return input;
    };
    PdfGraphics2.prototype.save = function() {
      var state = new PdfGraphicsState(this, this.matrix.clone());
      state.brush = this.currentBrush;
      state.pen = this.currentPen;
      state.font = this.currentFont;
      state.colorSpace = this.currentColorSpace;
      state.characterSpacing = this.previousCharacterSpacing;
      state.wordSpacing = this.previousWordSpacing;
      state.textScaling = this.previousTextScaling;
      state.textRenderingMode = this.previousTextRenderingMode;
      this.graphicsState.push(state);
      this.pdfStreamWriter.saveGraphicsState();
      return state;
    };
    PdfGraphics2.prototype.restore = function(state) {
      if (typeof state === "undefined") {
        if (this.graphicsState.length > 0) {
          this.doRestoreState();
        }
      } else {
        if (this.graphicsState.indexOf(state) !== -1) {
          for (; ; ) {
            if (this.graphicsState.length === 0) {
              break;
            }
            var popState = this.doRestoreState();
            if (popState === state) {
              break;
            }
          }
        }
      }
    };
    PdfGraphics2.prototype.doRestoreState = function() {
      var state = this.graphicsState.pop();
      this.transformationMatrix = state.matrix;
      this.currentBrush = state.brush;
      this.currentPen = state.pen;
      this.currentFont = state.font;
      this.currentColorSpace = state.colorSpace;
      this.previousCharacterSpacing = state.characterSpacing;
      this.previousWordSpacing = state.wordSpacing;
      this.previousTextScaling = state.textScaling;
      this.previousTextRenderingMode = state.textRenderingMode;
      this.pdfStreamWriter.restoreGraphicsState();
      return state;
    };
    PdfGraphics2.prototype.drawPath = function(pen, brush, path) {
      if (brush instanceof PdfTilingBrush) {
        this.bCSInitialized = false;
        brush.graphics.colorSpace = this.colorSpace;
      } else if (brush instanceof PdfGradientBrush) {
        this.bCSInitialized = false;
        brush.colorSpace = this.colorSpace;
      }
      this.stateControl(pen, brush, null);
      this.buildUpPath(path.pathPoints, path.pathTypes);
      this.drawPathHelper(pen, brush, path.fillMode, false);
    };
    PdfGraphics2.prototype.drawArc = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      if (arg2 instanceof RectangleF) {
        this.drawArc(arg1, arg2.x, arg2.y, arg2.width, arg2.height, arg3, arg4);
      } else {
        if (arg7 !== 0) {
          this.stateControl(arg1, null, null);
          this.constructArcPath(arg2, arg3, arg2 + arg4, arg3 + arg5, arg6, arg7);
          this.drawPathHelper(arg1, null, false);
        }
      }
    };
    PdfGraphics2.prototype.buildUpPath = function(arg1, arg2) {
      var cnt = arg1.length;
      for (var i = 0; i < cnt; ++i) {
        var typeValue = 0;
        var point = arg1[i];
        switch (arg2[i] & PdfGraphics2.pathTypesValuesMask) {
          case PathPointType.Start:
            this.pdfStreamWriter.beginPath(point.x, point.y);
            break;
          case PathPointType.Bezier3:
            var p2 = new PointF(0, 0);
            var p3 = new PointF(0, 0);
            var result1 = this.getBezierPoints(arg1, arg2, i, p2, p3);
            this.pdfStreamWriter.appendBezierSegment(point, result1.p2, result1.p3);
            i = result1.i;
            break;
          case PathPointType.Line:
            this.pdfStreamWriter.appendLineSegment(point);
            break;
          default:
            throw new Error("ArithmeticException - Incorrect path formation.");
        }
        typeValue = arg2[i];
        this.checkFlags(typeValue);
      }
    };
    PdfGraphics2.prototype.getBezierPoints = function(points, types, i, p2, p3) {
      var errorMsg = "Malforming path.";
      ++i;
      if ((types[i] & PdfGraphics2.pathTypesValuesMask) === PathPointType.Bezier3) {
        p2 = points[i];
        ++i;
        if ((types[i] & PdfGraphics2.pathTypesValuesMask) === PathPointType.Bezier3) {
          p3 = points[i];
        } else {
          throw new Error("ArgumentException : errorMsg");
        }
      } else {
        throw new Error("ArgumentException : errorMsg");
      }
      return { i, p2, p3 };
    };
    PdfGraphics2.prototype.checkFlags = function(type) {
      if ((type & PathPointType.CloseSubpath) === PathPointType.CloseSubpath) {
        this.pdfStreamWriter.closePath();
      }
    };
    PdfGraphics2.prototype.constructArcPath = function(x1, y1, x2, y2, startAng, sweepAngle) {
      var points = this.getBezierArc(x1, y1, x2, y2, startAng, sweepAngle);
      if (points.length === 0) {
        return;
      }
      var pt = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];
      this.pdfStreamWriter.beginPath(pt[0], pt[1]);
      var i = 0;
      for (i = 0; i < points.length; i = i + 8) {
        pt = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];
        this.pdfStreamWriter.appendBezierSegment(pt[2], pt[3], pt[4], pt[5], pt[6], pt[7]);
      }
    };
    PdfGraphics2.prototype.getBezierArc = function(numX1, numY1, numX2, numY2, s1, e1) {
      if (numX1 > numX2) {
        var tmp = void 0;
        tmp = numX1;
        numX1 = numX2;
        numX2 = tmp;
      }
      if (numY2 > numY1) {
        var tmp = void 0;
        tmp = numY1;
        numY1 = numY2;
        numY2 = tmp;
      }
      var fragAngle1;
      var numFragments;
      if (Math.abs(e1) <= 90) {
        fragAngle1 = e1;
        numFragments = 1;
      } else {
        numFragments = Math.ceil(Math.abs(e1) / 90);
        fragAngle1 = e1 / numFragments;
      }
      var xcen = (numX1 + numX2) / 2;
      var ycen = (numY1 + numY2) / 2;
      var rx = (numX2 - numX1) / 2;
      var ry = (numY2 - numY1) / 2;
      var halfAng = fragAngle1 * (Math.PI / 360);
      var kappa = Math.abs(4 / 3 * (1 - Math.cos(halfAng)) / Math.sin(halfAng));
      var pointsList = [];
      for (var i = 0; i < numFragments; i++) {
        var thetaValue0 = (s1 + i * fragAngle1) * (Math.PI / 180);
        var thetaValue1 = (s1 + (i + 1) * fragAngle1) * (Math.PI / 180);
        var cos0 = Math.cos(thetaValue0);
        var cos1 = Math.cos(thetaValue1);
        var sin0 = Math.sin(thetaValue0);
        var sin1 = Math.sin(thetaValue1);
        if (fragAngle1 > 0) {
          pointsList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        } else {
          pointsList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        }
      }
      return pointsList;
    };
    PdfGraphics2.pathTypesValuesMask = 15;
    PdfGraphics2.transparencyObject = false;
    return PdfGraphics2;
  }()
);
var GetResourceEventHandler = (
  /** @class */
  function() {
    function GetResourceEventHandler2(sender) {
      this.sender = sender;
    }
    GetResourceEventHandler2.prototype.getResources = function() {
      return this.sender.getResources();
    };
    return GetResourceEventHandler2;
  }()
);
var PdfGraphicsState = (
  /** @class */
  function() {
    function PdfGraphicsState2(graphics, matrix) {
      this.internalTextRenderingMode = TextRenderingMode.Fill;
      this.internalCharacterSpacing = 0;
      this.internalWordSpacing = 0;
      this.internalTextScaling = 100;
      this.pdfColorSpace = PdfColorSpace.Rgb;
      if (typeof graphics !== "undefined") {
        this.pdfGraphics = graphics;
        this.transformationMatrix = matrix;
      }
    }
    Object.defineProperty(PdfGraphicsState2.prototype, "graphics", {
      // Properties
      /**
       * Gets the parent `graphics object`.
       * @private
       */
      get: function() {
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "matrix", {
      /**
       * Gets the `current matrix`.
       * @private
       */
      get: function() {
        return this.transformationMatrix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "characterSpacing", {
      /**
       * Gets or sets the `current character spacing`.
       * @private
       */
      get: function() {
        return this.internalCharacterSpacing;
      },
      set: function(value) {
        this.internalCharacterSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "wordSpacing", {
      /**
       * Gets or sets the `word spacing` value.
       * @private
       */
      get: function() {
        return this.internalWordSpacing;
      },
      set: function(value) {
        this.internalWordSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "textScaling", {
      /**
       * Gets or sets the `text scaling` value.
       * @private
       */
      get: function() {
        return this.internalTextScaling;
      },
      set: function(value) {
        this.internalTextScaling = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "pen", {
      /**
       * Gets or sets the `current pen` object.
       * @private
       */
      get: function() {
        return this.pdfPen;
      },
      set: function(value) {
        this.pdfPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "brush", {
      /**
       * Gets or sets the `brush`.
       * @private
       */
      get: function() {
        return this.pdfBrush;
      },
      set: function(value) {
        this.pdfBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "font", {
      /**
       * Gets or sets the `current font` object.
       * @private
       */
      get: function() {
        return this.pdfFont;
      },
      set: function(value) {
        this.pdfFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "colorSpace", {
      /**
       * Gets or sets the `current color space` value.
       * @private
       */
      get: function() {
        return this.pdfColorSpace;
      },
      set: function(value) {
        this.pdfColorSpace = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "textRenderingMode", {
      /**
       * Gets or sets the `text rendering mode`.
       * @private
       */
      get: function() {
        return this.internalTextRenderingMode;
      },
      set: function(value) {
        this.internalTextRenderingMode = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGraphicsState2;
  }()
);
var TransparencyData = (
  /** @class */
  function() {
    function TransparencyData2(alphaPen, alphaBrush, blendMode) {
      this.alphaPen = alphaPen;
      this.alphaBrush = alphaBrush;
      this.blendMode = blendMode;
    }
    return TransparencyData2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-layer.js
var PdfPageLayer = (
  /** @class */
  function() {
    function PdfPageLayer2(page, streamClipPageTemplates) {
      this.pdfColorSpace = PdfColorSpace.Rgb;
      this.isVisible = true;
      this.sublayer = false;
      this.contentLength = 0;
      this.dictionaryProperties = new DictionaryProperties();
      if (page === null) {
        throw new Error("ArgumentNullException:page");
      }
      this.pdfPage = page;
      this.clipPageTemplates = true;
      if (typeof streamClipPageTemplates === "undefined") {
        this.content = new PdfStream();
      } else if (streamClipPageTemplates instanceof PdfStream || streamClipPageTemplates === null) {
        if (streamClipPageTemplates === null) {
          throw new Error("ArgumentNullException:stream");
        }
        this.content = streamClipPageTemplates;
      } else {
        this.content = new PdfStream();
        this.clipPageTemplates = streamClipPageTemplates;
      }
    }
    Object.defineProperty(PdfPageLayer2.prototype, "colorSpace", {
      // Properties
      /**
       * Get or set the `color space`.
       * @private
       */
      get: function() {
        return this.pdfColorSpace;
      },
      set: function(value) {
        this.pdfColorSpace = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "page", {
      /**
       * Gets parent `page` of the layer.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "layerId", {
      /**
       * Gets and Sets the `id of the layer`.
       * @private
       */
      get: function() {
        return this.layerid;
      },
      set: function(value) {
        this.layerid = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "name", {
      /**
       * Gets or sets the `name` of the layer.
       * @private
       */
      get: function() {
        return this.layerName;
      },
      set: function(value) {
        this.layerName = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "visible", {
      /**
       * Gets or sets the `visibility` of the layer.
       * @private
       */
      get: function() {
        return this.isVisible;
      },
      set: function(value) {
        this.isVisible = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "graphics", {
      /**
       * Gets `Graphics` context of the layer, used to draw various graphical content on layer.
       * @private
       */
      get: function() {
        if (this.pdfGraphics == null) {
          this.initializeGraphics(this.page);
        }
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "layers", {
      /**
       * Gets the collection of `PdfPageLayer`, this collection handle by the class 'PdfPageLayerCollection'.
       * @private
       */
      get: function() {
        if (this.layer == null) {
          this.layer = new PdfPageLayerCollection(this.page);
          this.layer.sublayer = true;
          return this.layer;
        } else {
          return this.layer;
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfPageLayer2.prototype.add = function() {
      var layer = new PdfPageLayer2(this.pdfPage);
      layer.name = "";
      return layer;
    };
    PdfPageLayer2.prototype.sign = function(number) {
      if (number === 0) {
        return 0;
      } else if (number > 0) {
        return 1;
      } else {
        return -1;
      }
    };
    PdfPageLayer2.prototype.initializeGraphics = function(page) {
      var oPage = page;
      var gr = new GetResourceEventHandler(this.page);
      var cropBox = null;
      this.pdfGraphics = new PdfGraphics(page.size, gr, this.content);
      this.pdfGraphics.mediaBoxUpperRightBound = 0;
      if (oPage != null) {
        var sc = oPage.section.parent;
        if (sc != null) {
          this.pdfGraphics.colorSpace = sc.document.colorSpace;
          this.colorSpace = sc.document.colorSpace;
        }
      }
      var isSame = this.sign(page.origin.y) === this.sign(page.origin.x);
      if (page.origin.x >= 0 && page.origin.y >= 0 || !isSame) {
        this.pdfGraphics.initializeCoordinates();
      } else {
      }
      var clipRect = oPage.section.getActualBounds(oPage, true);
      var margins = oPage.section.pageSettings.margins;
      if (this.clipPageTemplates) {
        if (page.origin.x >= 0 && page.origin.y >= 0) {
          this.pdfGraphics.clipTranslateMargins(clipRect);
        }
      } else {
        this.graphics.clipTranslateMargins(clipRect.x, clipRect.y, margins.left, margins.top, margins.right, margins.bottom);
      }
      this.pdfGraphics.setLayer(this);
    };
    Object.defineProperty(PdfPageLayer2.prototype, "element", {
      // IPdfWrapper Members
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.content;
      },
      enumerable: true,
      configurable: true
    });
    return PdfPageLayer2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/pdf-collection.js
var PdfCollection = (
  /** @class */
  function() {
    function PdfCollection2() {
    }
    Object.defineProperty(PdfCollection2.prototype, "count", {
      // Properties
      /**
       * Gets the `Count` of stored objects.
       * @private
       */
      get: function() {
        if (typeof this.collection === "undefined") {
          this.collection = [];
        }
        return this.collection.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCollection2.prototype, "list", {
      /**
       * Gets the `list` of stored objects.
       * @private
       */
      get: function() {
        if (typeof this.collection === "undefined") {
          this.collection = [];
        }
        return this.collection;
      },
      enumerable: true,
      configurable: true
    });
    return PdfCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-layer-collection.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfPageLayerCollection = (
  /** @class */
  function(_super) {
    __extends10(PdfPageLayerCollection2, _super);
    function PdfPageLayerCollection2(page) {
      var _this = _super.call(this) || this;
      _this.parentLayerCount = 0;
      _this.sublayer = false;
      _this.optionalContent = new PdfDictionary();
      if (page instanceof PdfPageBase) {
        _this.page = page;
        var lPage = page;
        _this.parseLayers(lPage);
      }
      return _this;
    }
    PdfPageLayerCollection2.prototype.items = function(index, value) {
      if (typeof index === "number" && typeof value === "undefined") {
        var obj = this.list[index];
        return obj;
      } else {
        if (value == null) {
          throw new Error("ArgumentNullException: layer");
        }
        if (value.page !== this.page) {
          throw new Error("ArgumentException: The layer belongs to another page");
        }
      }
    };
    PdfPageLayerCollection2.prototype.add = function(firstArgument, secondArgument) {
      if (typeof firstArgument === "undefined") {
        var layer = new PdfPageLayer(this.page);
        layer.name = "";
        this.add(layer);
        return layer;
      } else if (firstArgument instanceof PdfPageLayer) {
        var index = this.list.push(firstArgument);
        this.addLayer(index, firstArgument);
        return index;
      } else {
        return 0;
      }
    };
    PdfPageLayerCollection2.prototype.addLayer = function(index, layer) {
      var reference = new PdfReferenceHolder(layer);
      this.page.contents.add(reference);
    };
    PdfPageLayerCollection2.prototype.insert = function(index, layer) {
      var list = [];
      var length = this.list.length;
      for (var i = index; i < length; i++) {
        list.push(this.list.pop());
      }
      this.list.push(layer);
      for (var i = 0; i < list.length; i++) {
        this.list.push(list[i]);
      }
      this.insertLayer(index, layer);
    };
    PdfPageLayerCollection2.prototype.insertLayer = function(index, layer) {
      if (layer == null) {
        throw new Error("ArgumentNullException:layer");
      }
      var reference = new PdfReferenceHolder(layer);
      this.page.contents.insert(index, reference);
    };
    PdfPageLayerCollection2.prototype.parseLayers = function(loadedPage) {
      var contents = this.page.contents;
      var resource = this.page.getResources();
      var crossTable = null;
      var ocproperties = null;
      var propertie = null;
      var isLayerAdded = false;
      crossTable = loadedPage.crossTable;
      var saveStream = new PdfStream();
      var restoreStream = new PdfStream();
      var saveState = "q";
      var newLine = "\n";
      var restoreState = "Q";
      var saveData = [];
      saveData.push(saveState);
      saveStream.data = saveData;
      contents.insert(0, new PdfReferenceHolder(saveStream));
      saveData = [];
      saveData.push(restoreState);
      restoreStream.data = saveData;
      contents.insert(contents.count, new PdfReferenceHolder(restoreStream));
    };
    PdfPageLayerCollection2.prototype.indexOf = function(layer) {
      if (layer == null) {
        throw new Error("ArgumentNullException: layer");
      }
      var index = this.list.indexOf(layer);
      return index;
    };
    return PdfPageLayerCollection2;
  }(PdfCollection)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-base.js
var PdfPageBase = (
  /** @class */
  function() {
    function PdfPageBase2(dictionary) {
      this.defLayerIndex = -1;
      this.modified = false;
      this.dictionaryProperties = new DictionaryProperties();
      this.pageDictionary = dictionary;
    }
    Object.defineProperty(PdfPageBase2.prototype, "section", {
      //Properties
      /**
       * Gets the `section` of a page.
       * @private
       */
      get: function() {
        return this.pdfSection;
      },
      set: function(value) {
        this.pdfSection = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "dictionary", {
      /**
       * Gets the page `dictionary`.
       * @private
       */
      get: function() {
        return this.pageDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "element", {
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.pageDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "defaultLayer", {
      /**
       * Gets the `default layer` of the page (Read only).
       * @private
       */
      get: function() {
        var layer = this.layers;
        var index = this.defaultLayerIndex;
        var returnlayer = layer.items(index);
        return returnlayer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "defaultLayerIndex", {
      /**
       * Gets or sets `index of the default layer`.
       * @private
       */
      get: function() {
        if (this.layerCollection.count === 0 || this.defLayerIndex === -1) {
          var layer = this.layerCollection.add();
          this.defLayerIndex = this.layerCollection.indexOf(layer);
        }
        return this.defLayerIndex;
      },
      /**
       * Gets or sets` index of the default layer`.
       * @private
       */
      set: function(value) {
        if (value < 0 || value > this.layers.count - 1) {
          throw new Error("ArgumentOutOfRangeException : value, Index can not be less 0 and greater Layers.Count - 1");
        } else {
          this.defLayerIndex = value;
          this.modified = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "layers", {
      /**
       * Gets the collection of the page's `layers` (Read only).
       * @private
       */
      get: function() {
        if (this.layerCollection == null || typeof this.layerCollection === "undefined") {
          this.layerCollection = new PdfPageLayerCollection(this);
        }
        return this.layerCollection;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageBase2.prototype.getResources = function() {
      if (this.resources == null) {
        this.resources = new PdfResources();
        this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);
      }
      return this.resources;
    };
    Object.defineProperty(PdfPageBase2.prototype, "contents", {
      /**
       * Gets `array of page's content`.
       * @private
       */
      get: function() {
        var obj = this.pageDictionary.items.getValue(this.dictionaryProperties.contents);
        var contents = obj;
        var rh = obj;
        if (contents == null) {
          contents = new PdfArray();
          this.pageDictionary.items.setValue(this.dictionaryProperties.contents, contents);
        }
        return contents;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageBase2.prototype.setResources = function(res) {
      this.resources = res;
      this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);
      this.modified = true;
    };
    return PdfPageBase2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/annotation-collection.js
var PdfAnnotationCollection = (
  /** @class */
  function() {
    function PdfAnnotationCollection2(page) {
      this.alreadyExistsAnnotationError = "This annotatation had been already added to page";
      this.missingAnnotationException = "Annotation is not contained in collection.";
      this.dictionaryProperties = new DictionaryProperties();
      this.internalAnnotations = new PdfArray();
      this.lists = [];
      if (typeof page !== "undefined") {
        this.page = page;
      }
    }
    Object.defineProperty(PdfAnnotationCollection2.prototype, "annotations", {
      /**
       * Gets the `PdfAnnotation` object at the specified index. Read-Only.
       * @private
       */
      get: function() {
        return this.internalAnnotations;
      },
      set: function(value) {
        this.internalAnnotations = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfAnnotationCollection2.prototype.add = function(annotation) {
      this.doAdd(annotation);
    };
    PdfAnnotationCollection2.prototype.doAdd = function(annotation) {
      if (typeof annotation.destination !== "undefined") {
        var layout = new PdfStringLayouter();
        var layoutResult = layout.layout(annotation.text, annotation.font, annotation.stringFormat, new SizeF(annotation.bounds.width, 0), false, new SizeF(0, 0));
        var lastPosition = annotation.bounds.y;
        if (layoutResult.lines.length === 1) {
          var size = annotation.font.measureString(layoutResult.lines[0].text);
          annotation.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);
          annotation.text = layoutResult.lines[0].text;
          this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, annotation.bounds.y, annotation.bounds.width, annotation.bounds.height, null);
          annotation.setPage(this.page);
          this.setColor(annotation);
          this.internalAnnotations.add(new PdfReferenceHolder(annotation));
          this.lists.push(annotation);
        } else {
          for (var i = 0; i < layoutResult.lines.length; i++) {
            var size = annotation.font.measureString(layoutResult.lines[i].text);
            if (i === 0) {
              annotation.bounds = new RectangleF(annotation.bounds.x, lastPosition, size.width, size.height);
              annotation.text = layoutResult.lines[i].text;
              this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, lastPosition, size.width, size.height, null);
              annotation.setPage(this.page);
              this.setColor(annotation);
              this.internalAnnotations.add(new PdfReferenceHolder(annotation));
              this.lists.push(annotation);
              lastPosition += annotation.bounds.height;
            } else {
              var annot = annotation.clone();
              annot.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);
              annot.text = layoutResult.lines[i].text;
              this.page.graphics.drawString(annot.text, annot.font, null, annot.brush, annot.bounds.x, annot.bounds.y, annot.bounds.width, annot.bounds.height, null);
              annot.setPage(this.page);
              this.setColor(annot);
              this.internalAnnotations.add(new PdfReferenceHolder(annot));
              this.lists.push(annot);
              lastPosition += annot.bounds.height;
            }
          }
        }
      } else {
        annotation.setPage(this.page);
        this.internalAnnotations.add(new PdfReferenceHolder(annotation));
        return this.lists.push(annotation);
      }
    };
    PdfAnnotationCollection2.prototype.setColor = function(annotation) {
      var cs = PdfColorSpace.Rgb;
      var colours = annotation.color.toArray(cs);
      annotation.dictionary.items.setValue(this.dictionaryProperties.c, colours);
    };
    Object.defineProperty(PdfAnnotationCollection2.prototype, "element", {
      // IPdfWrapper Members
      /**
       * Gets the `Element` representing this object.
       * @private
       */
      get: function() {
        return this.internalAnnotations;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAnnotationCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfPage = (
  /** @class */
  function(_super) {
    __extends11(PdfPage2, _super);
    function PdfPage2() {
      var _this = _super.call(this, new PdfDictionary()) || this;
      _this.annotationCollection = null;
      _this.beginSave = null;
      _this.initialize();
      return _this;
    }
    Object.defineProperty(PdfPage2.prototype, "document", {
      //Properties
      /**
       * Gets current `document`.
       * @private
       */
      get: function() {
        if (this.section !== null && this.section.parent !== null) {
          return this.section.parent.document;
        } else {
          return null;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "graphics", {
      /**
       * Get the current `graphics`.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a new page to the document
       * let page1 : PdfPage = document.pages.add();
       * //
       * // get graphics
       * let graphics : PdfGraphics = page1.graphics;
       * //
       * // set the font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // create black brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * // draw the text
       * graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        var result = this.defaultLayer.graphics;
        result.currentPage = this;
        return result;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "crossTable", {
      /**
       * Gets the `cross table`.
       * @private
       */
      get: function() {
        if (this.section === null) {
          throw new Error("PdfDocumentException : Page is not created");
        }
        return this.section.parent === null ? this.section.parentDocument.crossTable : this.section.parent.document.crossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "size", {
      /**
       * Gets the size of the PDF page- Read only.
       * @public
       */
      get: function() {
        return this.section.pageSettings.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "origin", {
      /**
       * Gets the `origin` of the page.
       * @private
       */
      get: function() {
        return this.section.pageSettings.origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "annotations", {
      /**
       * Gets a collection of the `annotations` of the page- Read only.
       * @private
       */
      get: function() {
        if (this.annotationCollection == null) {
          this.annotationCollection = new PdfAnnotationCollection(this);
          this.dictionary.items.setValue(this.dictionaryProperties.annots, this.annotationCollection.element);
          this.annotationCollection.annotations = this.dictionary.items.getValue(this.dictionaryProperties.annots);
        }
        return this.annotationCollection;
      },
      enumerable: true,
      configurable: true
    });
    PdfPage2.prototype.initialize = function() {
      this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName("Page"));
      this.dictionary.pageBeginDrawTemplate = new SaveTemplateEventHandler(this);
    };
    PdfPage2.prototype.setSection = function(section) {
      this.section = section;
      this.dictionary.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(section));
    };
    PdfPage2.prototype.resetProgress = function() {
      this.isProgressOn = false;
    };
    PdfPage2.prototype.getClientSize = function() {
      var returnValue = this.section.getActualBounds(this, true);
      return new SizeF(returnValue.width, returnValue.height);
    };
    PdfPage2.prototype.pageBeginSave = function() {
      var doc = this.document;
      if (typeof doc !== void 0 && doc != null) {
        this.drawPageTemplates(doc);
      }
      if (this.beginSave != null && typeof this.beginSave !== "undefined") {
        this.beginSave(this);
      }
    };
    PdfPage2.prototype.drawPageTemplates = function(document2) {
      var hasBackTemplates = this.section.containsTemplates(document2, this, false);
      if (hasBackTemplates) {
        var backLayer = new PdfPageLayer(this, false);
        this.layers.insert(0, backLayer);
        this.section.drawTemplates(this, backLayer, document2, false);
        if (backLayer.graphics !== null && typeof backLayer.graphics !== "undefined") {
          for (var i = 0; i < backLayer.graphics.automaticFields.automaticFields.length; i++) {
            var fieldInfo = backLayer.graphics.automaticFields.automaticFields[i];
            fieldInfo.field.performDraw(backLayer.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
          }
        }
      }
      var hasFrontTemplates = this.section.containsTemplates(document2, this, true);
      if (hasFrontTemplates) {
        var frontLayer = new PdfPageLayer(this, false);
        this.layers.add(frontLayer);
        this.section.drawTemplates(this, frontLayer, document2, true);
      }
    };
    return PdfPage2;
  }(PdfPageBase)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/page-added-event-arguments.js
var PageAddedEventArgs = (
  /** @class */
  function() {
    function PageAddedEventArgs2(page) {
      if (typeof page !== "undefined") {
        this.pdfPage = page;
      } else {
        this.pdfPage = null;
      }
    }
    Object.defineProperty(PageAddedEventArgs2.prototype, "page", {
      /**
       * Gets the `newly added page`.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    return PageAddedEventArgs2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section-page-collection.js
var PdfSectionPageCollection = (
  /** @class */
  function() {
    function PdfSectionPageCollection2(section) {
      this.pdfSection = null;
      if (section == null) {
        throw Error('ArgumentNullException("section")');
      }
      this.section = section;
    }
    Object.defineProperty(PdfSectionPageCollection2.prototype, "section", {
      // Properties
      /**
       * Gets the `PdfPage` at the specified index.
       * @private
       */
      get: function() {
        return this.pdfSection;
      },
      set: function(value) {
        this.pdfSection = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfSectionPageCollection2.prototype.contains = function(page) {
      return this.section.contains(page);
    };
    PdfSectionPageCollection2.prototype.remove = function(page) {
      this.section.remove(page);
    };
    PdfSectionPageCollection2.prototype.add = function() {
      return this.section.add();
    };
    return PdfSectionPageCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-document-template.js
var PdfDocumentTemplate = (
  /** @class */
  function() {
    function PdfDocumentTemplate2() {
    }
    Object.defineProperty(PdfDocumentTemplate2.prototype, "left", {
      // private m_stamps : PdfStampCollection;
      // Properties
      /**
       * `Left` page template object.
       * @public
       */
      get: function() {
        return this.leftTemplate;
      },
      set: function(value) {
        this.leftTemplate = this.checkElement(value, TemplateType.Left);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "top", {
      /**
       * `Top` page template object.
       * @public
       */
      get: function() {
        return this.topTemplate;
      },
      set: function(value) {
        this.topTemplate = this.checkElement(value, TemplateType.Top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "right", {
      /**
       * `Right` page template object.
       * @public
       */
      get: function() {
        return this.rightTemplate;
      },
      set: function(value) {
        this.rightTemplate = this.checkElement(value, TemplateType.Right);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "bottom", {
      /**
       * `Bottom` page template object.
       * @public
       */
      get: function() {
        return this.bottomTemplate;
      },
      set: function(value) {
        this.bottomTemplate = this.checkElement(value, TemplateType.Bottom);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenLeft", {
      /**
       * `EvenLeft` page template object.
       * @public
       */
      get: function() {
        return this.evenLeft;
      },
      set: function(value) {
        this.evenLeft = this.checkElement(value, TemplateType.Left);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenTop", {
      /**
       * `EvenTop` page template object.
       * @public
       */
      get: function() {
        return this.evenTop;
      },
      set: function(value) {
        this.evenTop = this.checkElement(value, TemplateType.Top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenRight", {
      /**
       * `EvenRight` page template object.
       * @public
       */
      get: function() {
        return this.evenRight;
      },
      set: function(value) {
        this.evenRight = this.checkElement(value, TemplateType.Right);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenBottom", {
      /**
       * `EvenBottom` page template object.
       * @public
       */
      get: function() {
        return this.evenBottom;
      },
      set: function(value) {
        this.evenBottom = this.checkElement(value, TemplateType.Bottom);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddLeft", {
      /**
       * `OddLeft` page template object.
       * @public
       */
      get: function() {
        return this.oddLeft;
      },
      set: function(value) {
        this.oddLeft = this.checkElement(value, TemplateType.Left);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddTop", {
      /**
       * `OddTop` page template object.
       * @public
       */
      get: function() {
        return this.oddTop;
      },
      set: function(value) {
        this.oddTop = this.checkElement(value, TemplateType.Top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddRight", {
      /**
       * `OddRight` page template object.
       * @public
       */
      get: function() {
        return this.oddRight;
      },
      set: function(value) {
        this.oddRight = this.checkElement(value, TemplateType.Right);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddBottom", {
      /**
       * `OddBottom` page template object.
       * @public
       */
      get: function() {
        return this.oddBottom;
      },
      set: function(value) {
        this.oddBottom = this.checkElement(value, TemplateType.Bottom);
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentTemplate2.prototype.getLeft = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenLeft != null ? this.EvenLeft : this.left;
      } else {
        template = this.OddLeft != null ? this.OddLeft : this.left;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.getTop = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenTop != null ? this.EvenTop : this.top;
      } else {
        template = this.OddTop != null ? this.OddTop : this.top;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.getRight = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenRight != null ? this.EvenRight : this.right;
      } else {
        template = this.OddRight != null ? this.OddRight : this.right;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.getBottom = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenBottom != null ? this.EvenBottom : this.bottom;
      } else {
        template = this.OddBottom != null ? this.OddBottom : this.bottom;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.isEven = function(page) {
      var pages = page.section.document.pages;
      var index = 0;
      if (pages.pageCollectionIndex.containsKey(page)) {
        index = pages.pageCollectionIndex.getValue(page) + 1;
      } else {
        index = pages.indexOf(page) + 1;
      }
      var even = index % 2 === 0;
      return even;
    };
    PdfDocumentTemplate2.prototype.checkElement = function(templateElement, type) {
      if (templateElement != null) {
        if (typeof templateElement.type !== "undefined" && templateElement.type !== TemplateType.None) {
          throw new Error("NotSupportedException:Can not reassign the template element. Please, create new one.");
        }
        templateElement.type = type;
      }
      return templateElement;
    };
    return PdfDocumentTemplate2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section-templates.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfSectionTemplate = (
  /** @class */
  function(_super) {
    __extends12(PdfSectionTemplate2, _super);
    function PdfSectionTemplate2() {
      var _this = _super.call(this) || this;
      _this.leftValue = _this.topValue = _this.rightValue = _this.bottomValue = _this.stampValue = true;
      return _this;
    }
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentLeftTemplate", {
      // Properties
      /**
       * Gets or sets value indicating whether parent `Left page template should be used or not`.
       * @private
       */
      get: function() {
        return this.leftValue;
      },
      set: function(value) {
        this.leftValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentTopTemplate", {
      /**
       * Gets or sets value indicating whether parent `Top page template should be used or not`.
       * @private
       */
      get: function() {
        return this.topValue;
      },
      set: function(value) {
        this.topValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentRightTemplate", {
      /**
       * Gets or sets value indicating whether parent `Right page template should be used or not`.
       * @private
       */
      get: function() {
        return this.rightValue;
      },
      set: function(value) {
        this.rightValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentBottomTemplate", {
      /**
       * Gets or sets value indicating whether parent `Bottom page template should be used or not`.
       * @private
       */
      get: function() {
        return this.bottomValue;
      },
      set: function(value) {
        this.bottomValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentStamps", {
      /**
       * Gets or sets value indicating whether the `stamp value` is true or not.
       * @private
       */
      get: function() {
        return this.stampValue;
      },
      set: function(value) {
        this.stampValue = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfSectionTemplate2;
  }(PdfDocumentTemplate)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section.js
var PdfSection = (
  /** @class */
  function() {
    function PdfSection2(document2, pageSettings) {
      this.pageAdded = new PageAddedEventArgs();
      this.pdfPages = [];
      this.dictionaryProperties = new DictionaryProperties();
      this.pdfDocument = document2;
      if (typeof pageSettings === "undefined") {
        this.settings = document2.pageSettings.clone();
        this.initialSettings = this.settings.clone();
      } else {
        this.settings = pageSettings.clone();
        this.initialSettings = this.settings.clone();
      }
      this.initialize();
    }
    Object.defineProperty(PdfSection2.prototype, "parent", {
      //Property
      /**
       * Gets or sets the `parent`.
       * @private
       */
      get: function() {
        return this.sectionCollection;
      },
      set: function(value) {
        this.sectionCollection = value;
        this.section.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(value));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "parentDocument", {
      /**
       * Gets the `parent document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "pageSettings", {
      /**
       * Gets or sets the `page settings` of the section.
       * @private
       */
      get: function() {
        return this.settings;
      },
      set: function(value) {
        if (value != null) {
          this.settings = value;
        } else {
          throw Error("Value can not be null.");
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "element", {
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.section;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "count", {
      /**
       * Gets the `count` of the pages in the section.
       * @private
       */
      get: function() {
        return this.pagesReferences.count;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "template", {
      /**
       * Gets or sets a `template` for the pages in the section.
       * @private
       */
      get: function() {
        if (this.pageTemplate == null) {
          this.pageTemplate = new PdfSectionTemplate();
        }
        return this.pageTemplate;
      },
      set: function(value) {
        this.pageTemplate = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "document", {
      /**
       * Gets the `document`.
       * @private
       */
      get: function() {
        return this.sectionCollection.document;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "pages", {
      /**
       * Gets the collection of `pages` in a section (Read only)
       * @private
       */
      get: function() {
        if (this.pagesCollection == null || typeof this.pagesCollection === "undefined") {
          this.pagesCollection = new PdfSectionPageCollection(this);
        }
        return this.pagesCollection;
      },
      enumerable: true,
      configurable: true
    });
    PdfSection2.prototype.getPages = function() {
      return this.pdfPages;
    };
    PdfSection2.prototype.pointToNativePdf = function(page, point) {
      var bounds = this.getActualBounds(page, true);
      point.x += bounds.x;
      point.y = this.pageSettings.height - point.y;
      return point;
    };
    PdfSection2.prototype.setPageSettings = function(settings) {
      this.settings = settings;
      this.state.orientation = settings.orientation;
      this.state.rotate = settings.rotate;
      this.state.size = settings.size;
      this.state.origin = settings.origin;
    };
    PdfSection2.prototype.initialize = function() {
      this.pagesReferences = new PdfArray();
      this.section = new PdfDictionary();
      this.state = new PageSettingsState(this.pdfDocument);
      this.section.sectionBeginSave = new SaveSectionEventHandler(this, this.state);
      this.pageCount = new PdfNumber(0);
      this.section.items.setValue(this.dictionaryProperties.count, this.pageCount);
      this.section.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.pages));
      this.section.items.setValue(this.dictionaryProperties.kids, this.pagesReferences);
    };
    PdfSection2.prototype.containsTemplates = function(document2, page, foreground) {
      var documentHeaders = this.getDocumentTemplates(document2, page, foreground);
      var sectionTemplates = this.getSectionTemplates(page, foreground);
      return documentHeaders.length > 0 || sectionTemplates.length > 0;
    };
    PdfSection2.prototype.getDocumentTemplates = function(document2, page, foreground) {
      var templates = [];
      if (this.template.applyDocumentTopTemplate && document2.template.getTop(page) != null) {
        if (!(document2.template.getTop(page).foreground || foreground) || document2.template.getTop(page).foreground && foreground) {
          templates.push(document2.template.getTop(page));
        }
      }
      if (this.template.applyDocumentBottomTemplate && document2.template.getBottom(page) != null) {
        if (!(document2.template.getBottom(page).foreground || foreground) || document2.template.getBottom(page).foreground && foreground) {
          templates.push(document2.template.getBottom(page));
        }
      }
      if (this.template.applyDocumentLeftTemplate && document2.template.getLeft(page) != null) {
        if (!(document2.template.getLeft(page).foreground || foreground) || document2.template.getLeft(page).foreground && foreground) {
          templates.push(document2.template.getLeft(page));
        }
      }
      if (this.template.applyDocumentRightTemplate && document2.template.getRight(page) != null) {
        if (!(document2.template.getRight(page).foreground || foreground) || document2.template.getRight(page).foreground && foreground) {
          templates.push(document2.template.getRight(page));
        }
      }
      return templates;
    };
    PdfSection2.prototype.getSectionTemplates = function(page, foreground) {
      var templates = [];
      if (this.template.getTop(page) != null) {
        var pageTemplate = this.template.getTop(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      if (this.template.getBottom(page) != null) {
        var pageTemplate = this.template.getBottom(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      if (this.template.getLeft(page) != null) {
        var pageTemplate = this.template.getLeft(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      if (this.template.getRight(page) != null) {
        var pageTemplate = this.template.getRight(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      return templates;
    };
    PdfSection2.prototype.add = function(page) {
      if (typeof page === "undefined") {
        var page_1 = new PdfPage();
        this.add(page_1);
        return page_1;
      } else {
        var r = this.checkPresence(page);
        this.pdfPages.push(page);
        this.pagesReferences.add(r);
        page.setSection(this);
        page.resetProgress();
        this.pageAddedMethod(page);
      }
    };
    PdfSection2.prototype.checkPresence = function(page) {
      var rh = new PdfReferenceHolder(page);
      var contains = false;
      var sc = this.parent;
      for (var index = 0; index < sc.section.length; index++) {
        var section = sc.section[index];
        contains = contains || section.contains(page);
      }
      return rh;
    };
    PdfSection2.prototype.contains = function(page) {
      var index = this.indexOf(page);
      return 0 <= index;
    };
    PdfSection2.prototype.indexOf = function(page) {
      for (var index = 0; index < this.pdfPages.length; index++) {
        if (this.pdfPages[index] === page) {
          return this.pdfPages.indexOf(page);
        }
      }
      var r = new PdfReferenceHolder(page);
      return this.pagesReferences.indexOf(r);
    };
    PdfSection2.prototype.pageAddedMethod = function(page) {
      var args = new PageAddedEventArgs(page);
      this.onPageAdded(args);
      var parent = this.parent;
      parent.document.pages.onPageAdded(args);
      this.pageCount.intValue = this.count;
    };
    PdfSection2.prototype.onPageAdded = function(args) {
    };
    PdfSection2.prototype.getActualBounds = function(arg1, arg2, arg3) {
      if (arg1 instanceof PdfPage && typeof arg2 === "boolean") {
        var result = void 0;
        var document_1 = this.parent.document;
        result = this.getActualBounds(document_1, arg1, arg2);
        return result;
      } else {
        arg1 = arg1;
        arg2 = arg2;
        arg3 = arg3;
        var bounds = new RectangleF(0, 0, 0, 0);
        bounds.height = arg3 ? this.pageSettings.size.height : this.pageSettings.getActualSize().height;
        bounds.width = arg3 ? this.pageSettings.size.width : this.pageSettings.getActualSize().width;
        var left = this.getLeftIndentWidth(arg1, arg2, arg3);
        var top_1 = this.getTopIndentHeight(arg1, arg2, arg3);
        var right = this.getRightIndentWidth(arg1, arg2, arg3);
        var bottom = this.getBottomIndentHeight(arg1, arg2, arg3);
        bounds.x += left;
        bounds.y += top_1;
        bounds.width -= left + right;
        bounds.height -= top_1 + bottom;
        return bounds;
      }
    };
    PdfSection2.prototype.getLeftIndentWidth = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.left : 0;
      var templateWidth = this.template.getLeft(page) != null ? this.template.getLeft(page).width : 0;
      var docTemplateWidth = document2.template.getLeft(page) != null ? document2.template.getLeft(page).width : 0;
      value += this.template.applyDocumentLeftTemplate ? Math.max(templateWidth, docTemplateWidth) : templateWidth;
      return value;
    };
    PdfSection2.prototype.getTopIndentHeight = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.top : 0;
      var templateHeight = this.template.getTop(page) != null ? this.template.getTop(page).height : 0;
      var docTemplateHeight = document2.template.getTop(page) != null ? document2.template.getTop(page).height : 0;
      value += this.template.applyDocumentTopTemplate ? Math.max(templateHeight, docTemplateHeight) : templateHeight;
      return value;
    };
    PdfSection2.prototype.getRightIndentWidth = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.right : 0;
      var templateWidth = this.template.getRight(page) != null ? this.template.getRight(page).width : 0;
      var docTemplateWidth = document2.template.getRight(page) != null ? document2.template.getRight(page).width : 0;
      value += this.template.applyDocumentRightTemplate ? Math.max(templateWidth, docTemplateWidth) : templateWidth;
      return value;
    };
    PdfSection2.prototype.getBottomIndentHeight = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.bottom : 0;
      var templateHeight = this.template.getBottom(page) != null ? this.template.getBottom(page).height : 0;
      var docTemplateHeight = document2.template.getBottom(page) != null ? document2.template.getBottom(page).height : 0;
      value += this.template.applyDocumentBottomTemplate ? Math.max(templateHeight, docTemplateHeight) : templateHeight;
      return value;
    };
    PdfSection2.prototype.remove = function(page) {
      if (page == null) {
        throw Error('ArgumentNullException("page")');
      }
      var index = this.pdfPages.indexOf(page);
      this.pagesReferences.removeAt(index);
      var temproaryPages = [];
      for (var j = 0; j < index; j++) {
        temproaryPages.push(this.pdfPages[j]);
      }
      for (var j = index + 1; j < this.pdfPages.length; j++) {
        temproaryPages.push(this.pdfPages[j]);
      }
      this.pdfPages = temproaryPages;
    };
    PdfSection2.prototype.applyPageSettings = function(container, parentSettings, state) {
      var bounds = new RectangleF(state.origin, state.size);
      container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));
      var rotate = 0;
      rotate = PdfSectionCollection.rotateFactor * state.rotate;
      var angle = new PdfNumber(rotate);
      container.items.setValue(this.dictionaryProperties.rotate, angle);
    };
    PdfSection2.prototype.beginSave = function(state, writer) {
      var doc = writer.document;
      this.applyPageSettings(this.section, doc.pageSettings, state);
    };
    PdfSection2.prototype.drawTemplates = function(page, layer, document2, foreground) {
      var documentHeaders = this.getDocumentTemplates(document2, page, foreground);
      var sectionHeaders = this.getSectionTemplates(page, foreground);
      this.drawTemplatesHelper(layer, document2, documentHeaders);
      this.drawTemplatesHelper(layer, document2, sectionHeaders);
    };
    PdfSection2.prototype.drawTemplatesHelper = function(layer, document2, templates) {
      if (templates != null && templates.length > 0) {
        var len = templates.length;
        for (var i = 0; i < len; i++) {
          var template = templates[i];
          template.draw(layer, document2);
        }
      }
    };
    return PdfSection2;
  }()
);
var PageSettingsState = (
  /** @class */
  function() {
    function PageSettingsState2(document2) {
      this.pageOrientation = document2.pageSettings.orientation;
      this.pageRotate = document2.pageSettings.rotate;
      this.pageSize = document2.pageSettings.size;
      this.pageOrigin = document2.pageSettings.origin;
    }
    Object.defineProperty(PageSettingsState2.prototype, "orientation", {
      //public Properties
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageOrientation;
      },
      set: function(value) {
        this.pageOrientation = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PageSettingsState2.prototype, "rotate", {
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageRotate;
      },
      set: function(value) {
        this.pageRotate = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PageSettingsState2.prototype, "size", {
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageSize;
      },
      set: function(value) {
        this.pageSize = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PageSettingsState2.prototype, "origin", {
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageOrigin;
      },
      set: function(value) {
        this.pageOrigin = value;
      },
      enumerable: true,
      configurable: true
    });
    return PageSettingsState2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section-collection.js
var PdfSectionCollection = (
  /** @class */
  function() {
    function PdfSectionCollection2(document2) {
      this.sections = [];
      this.dictionaryProperties = new DictionaryProperties();
      this.pdfDocument = document2.clone();
      this.initialize();
    }
    Object.defineProperty(PdfSectionCollection2.prototype, "section", {
      //Properties
      /**
       * Gets the `Section` collection.
       */
      get: function() {
        return this.sections;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionCollection2.prototype, "document", {
      /**
       * Gets a parent `document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionCollection2.prototype, "count", {
      /**
       * Gets the `number of sections` in a document.
       * @private
       */
      get: function() {
        return this.sections.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionCollection2.prototype, "element", {
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.pages;
      },
      enumerable: true,
      configurable: true
    });
    PdfSectionCollection2.prototype.initialize = function() {
      this.sectionCount = new PdfNumber(0);
      this.sectionCollection = new PdfArray();
      this.pages = new PdfDictionary();
      this.pages.beginSave = new SaveSectionCollectionEventHandler(this);
      this.pages.items.setValue(this.dictionaryProperties.type, new PdfName("Pages"));
      this.pages.items.setValue(this.dictionaryProperties.kids, this.sectionCollection);
      this.pages.items.setValue(this.dictionaryProperties.count, this.sectionCount);
      this.pages.items.setValue(this.dictionaryProperties.resources, new PdfDictionary());
      this.setPageSettings(this.pages, this.pdfDocument.pageSettings);
    };
    PdfSectionCollection2.prototype.pdfSectionCollection = function(index) {
      if (index < 0 || index >= this.count) {
        throw new Error("IndexOutOfRangeException()");
      }
      return this.sections[index];
    };
    PdfSectionCollection2.prototype.setPageSettings = function(container, pageSettings) {
      var bounds = new RectangleF(new PointF(), pageSettings.size);
      container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));
    };
    PdfSectionCollection2.prototype.add = function(section) {
      if (typeof section === "undefined") {
        var section_1 = new PdfSection(this.pdfDocument);
        this.add(section_1);
        return section_1;
      } else {
        var r = this.checkSection(section);
        this.sections.push(section);
        section.parent = this;
        this.sectionCollection.add(r);
        return this.sections.indexOf(section);
      }
    };
    PdfSectionCollection2.prototype.checkSection = function(section) {
      var r = new PdfReferenceHolder(section);
      var contains = this.sectionCollection.contains(r);
      return r;
    };
    PdfSectionCollection2.prototype.countPages = function() {
      var count = 0;
      this.sections.forEach(function(n) {
        return count += n.count;
      });
      return count;
    };
    PdfSectionCollection2.prototype.beginSave = function() {
      this.sectionCount.intValue = this.countPages();
    };
    PdfSectionCollection2.rotateFactor = 90;
    return PdfSectionCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-document-page-collection.js
var PdfDocumentPageCollection = (
  /** @class */
  function() {
    function PdfDocumentPageCollection2(document2) {
      this.pdfPageCollectionIndex = new Dictionary();
      this.document = document2;
    }
    Object.defineProperty(PdfDocumentPageCollection2.prototype, "count", {
      //Property
      /**
       * Gets the total `number of the pages`.
       * @private
       */
      get: function() {
        return this.countPages();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentPageCollection2.prototype, "pageCollectionIndex", {
      /**
       * Gets a `page index` from the document.
       * @private
       */
      get: function() {
        return this.pdfPageCollectionIndex;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentPageCollection2.prototype.add = function(page) {
      if (typeof page === "undefined") {
        var page_1 = new PdfPage();
        this.add(page_1);
        return page_1;
      } else {
        var section = this.getLastSection();
        section.add(page);
      }
    };
    PdfDocumentPageCollection2.prototype.getLastSection = function() {
      var sc = this.document.sections;
      if (sc.section.length === 0) {
        sc.add();
      }
      var section = sc.section[sc.section.length - 1];
      return section;
    };
    PdfDocumentPageCollection2.prototype.onPageAdded = function(args) {
    };
    PdfDocumentPageCollection2.prototype.countPages = function() {
      var sc = this.document.sections;
      var count = 0;
      for (var index = 0; index < sc.section.length; index++) {
        count += sc.section[index].count;
      }
      return count;
    };
    PdfDocumentPageCollection2.prototype.getPageByIndex = function(index) {
      return this.getPage(index);
    };
    PdfDocumentPageCollection2.prototype.getPage = function(index) {
      if (index < 0 || index >= this.count) {
        throw Error('ArgumentOutOfRangeException("index", "Value can not be less 0")');
      }
      var page = null;
      var sectionStartIndex = 0;
      var sectionCount = 0;
      var pageIndex = 0;
      var length = this.document.sections.count;
      for (var i = 0; i < length; i++) {
        var section = this.document.sections.section[i];
        sectionCount = section.count;
        pageIndex = index - sectionStartIndex;
        if (index >= sectionStartIndex && pageIndex < sectionCount) {
          page = section.getPages()[pageIndex];
          break;
        }
        sectionStartIndex += sectionCount;
      }
      return page;
    };
    PdfDocumentPageCollection2.prototype.indexOf = function(page) {
      var index = -1;
      if (page == null) {
        throw new Error("ArgumentNullException: page");
      } else {
        var numPages = 0;
        for (var i = 0, len = this.document.sections.count; i < len; i++) {
          var section = this.document.sections.pdfSectionCollection(i);
          index = section.indexOf(page);
          if (index >= 0) {
            index += numPages;
            break;
          } else {
            index = -1;
          }
          numPages += section.count;
        }
      }
      return index;
    };
    PdfDocumentPageCollection2.prototype.remove = function(page) {
      if (page == null) {
        throw Error('ArgumentNullException("page")');
      }
      var section = null;
      var len;
      for (var i = 0, len_1 = this.document.sections.count; i < len_1; i++) {
        section = this.document.sections.pdfSectionCollection(i);
        if (section.pages.contains(page)) {
          section.pages.remove(page);
          break;
        }
      }
      return section;
    };
    return PdfDocumentPageCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/pdf-cache-collection.js
var PdfCacheCollection = (
  /** @class */
  function() {
    function PdfCacheCollection2() {
      this.referenceObjects = [];
      this.pdfFontCollection = new Dictionary();
    }
    PdfCacheCollection2.prototype.search = function(obj) {
      var result = null;
      var group = this.getGroup(obj);
      if (group == null) {
        group = this.createNewGroup();
      } else if (group.length > 0) {
        result = group[0];
      }
      group.push(obj);
      return result;
    };
    PdfCacheCollection2.prototype.createNewGroup = function() {
      var group = [];
      this.referenceObjects.push(group);
      return group;
    };
    PdfCacheCollection2.prototype.getGroup = function(result) {
      var group = null;
      if (result !== null) {
        var len = this.referenceObjects.length;
        for (var i = 0; i < len; i++) {
          if (this.referenceObjects.length > 0) {
            var tGroup = this.referenceObjects[i];
            if (tGroup.length > 0) {
              var representative = tGroup[0];
              if (result.equalsTo(representative)) {
                group = tGroup;
                break;
              }
            } else {
              this.removeGroup(tGroup);
            }
          }
          len = this.referenceObjects.length;
        }
      }
      return group;
    };
    PdfCacheCollection2.prototype.removeGroup = function(group) {
      if (group !== null) {
        var index = this.referenceObjects.indexOf(group);
        this.referenceObjects.slice(index, index + 1);
      }
    };
    PdfCacheCollection2.prototype.destroy = function() {
      this.pdfFontCollection = void 0;
      this.referenceObjects = void 0;
    };
    return PdfCacheCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-standard-font-metrics-factory.js
var PdfStandardFontMetricsFactory = (
  /** @class */
  function() {
    function PdfStandardFontMetricsFactory2() {
    }
    PdfStandardFontMetricsFactory2.getMetrics = function(fontFamily, fontStyle, size) {
      var metrics = null;
      switch (fontFamily) {
        case PdfFontFamily.Helvetica:
          metrics = this.getHelveticaMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.Courier:
          metrics = this.getCourierMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.TimesRoman:
          metrics = this.getTimesMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.Symbol:
          metrics = this.getSymbolMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.ZapfDingbats:
          metrics = this.getZapfDingbatsMetrics(fontFamily, fontStyle, size);
          break;
        default:
          metrics = this.getHelveticaMetrics(PdfFontFamily.Helvetica, fontStyle, size);
          break;
      }
      metrics.name = fontFamily.toString();
      metrics.subScriptSizeFactor = this.subSuperScriptFactor;
      metrics.superscriptSizeFactor = this.subSuperScriptFactor;
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getHelveticaMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.helveticaBoldItalicAscent;
        metrics.descent = this.helveticaBoldItalicDescent;
        metrics.postScriptName = this.helveticaBoldItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {
        metrics.ascent = this.helveticaBoldAscent;
        metrics.descent = this.helveticaBoldDescent;
        metrics.postScriptName = this.helveticaBoldName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.helveticaItalicAscent;
        metrics.descent = this.helveticaItalicDescent;
        metrics.postScriptName = this.helveticaItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else {
        metrics.ascent = this.helveticaAscent;
        metrics.descent = this.helveticaDescent;
        metrics.postScriptName = this.helveticaName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialWidth);
        metrics.height = metrics.ascent - metrics.descent;
      }
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getCourierMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.courierBoldItalicAscent;
        metrics.descent = this.courierBoldItalicDescent;
        metrics.postScriptName = this.courierBoldItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {
        metrics.ascent = this.courierBoldAscent;
        metrics.descent = this.courierBoldDescent;
        metrics.postScriptName = this.courierBoldName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.courierItalicAscent;
        metrics.descent = this.courierItalicDescent;
        metrics.postScriptName = this.courierItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else {
        metrics.ascent = this.courierAscent;
        metrics.descent = this.courierDescent;
        metrics.postScriptName = this.courierName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      }
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getTimesMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.timesBoldItalicAscent;
        metrics.descent = this.timesBoldItalicDescent;
        metrics.postScriptName = this.timesBoldItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanBoldItalicWidths);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {
        metrics.ascent = this.timesBoldAscent;
        metrics.descent = this.timesBoldDescent;
        metrics.postScriptName = this.timesBoldName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanBoldWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.timesItalicAscent;
        metrics.descent = this.timesItalicDescent;
        metrics.postScriptName = this.timesItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanItalicWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else {
        metrics.ascent = this.timesAscent;
        metrics.descent = this.timesDescent;
        metrics.postScriptName = this.timesName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanWidth);
        metrics.height = metrics.ascent - metrics.descent;
      }
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getSymbolMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      metrics.ascent = this.symbolAscent;
      metrics.descent = this.symbolDescent;
      metrics.postScriptName = this.symbolName;
      metrics.size = size;
      metrics.widthTable = new StandardWidthTable(this.symbolWidth);
      metrics.height = metrics.ascent - metrics.descent;
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getZapfDingbatsMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      metrics.ascent = this.zapfDingbatsAscent;
      metrics.descent = this.zapfDingbatsDescent;
      metrics.postScriptName = this.zapfDingbatsName;
      metrics.size = size;
      metrics.widthTable = new StandardWidthTable(this.zapfDingbatsWidth);
      metrics.height = metrics.ascent - metrics.descent;
      return metrics;
    };
    PdfStandardFontMetricsFactory2.subSuperScriptFactor = 1.52;
    PdfStandardFontMetricsFactory2.helveticaAscent = 931;
    PdfStandardFontMetricsFactory2.helveticaDescent = -225;
    PdfStandardFontMetricsFactory2.helveticaName = "Helvetica";
    PdfStandardFontMetricsFactory2.helveticaBoldAscent = 962;
    PdfStandardFontMetricsFactory2.helveticaBoldDescent = -228;
    PdfStandardFontMetricsFactory2.helveticaBoldName = "Helvetica-Bold";
    PdfStandardFontMetricsFactory2.helveticaItalicAscent = 931;
    PdfStandardFontMetricsFactory2.helveticaItalicDescent = -225;
    PdfStandardFontMetricsFactory2.helveticaItalicName = "Helvetica-Oblique";
    PdfStandardFontMetricsFactory2.helveticaBoldItalicAscent = 962;
    PdfStandardFontMetricsFactory2.helveticaBoldItalicDescent = -228;
    PdfStandardFontMetricsFactory2.helveticaBoldItalicName = "Helvetica-BoldOblique";
    PdfStandardFontMetricsFactory2.courierAscent = 805;
    PdfStandardFontMetricsFactory2.courierDescent = -250;
    PdfStandardFontMetricsFactory2.courierName = "Courier";
    PdfStandardFontMetricsFactory2.courierBoldAscent = 801;
    PdfStandardFontMetricsFactory2.courierBoldDescent = -250;
    PdfStandardFontMetricsFactory2.courierBoldName = "Courier-Bold";
    PdfStandardFontMetricsFactory2.courierItalicAscent = 805;
    PdfStandardFontMetricsFactory2.courierItalicDescent = -250;
    PdfStandardFontMetricsFactory2.courierItalicName = "Courier-Oblique";
    PdfStandardFontMetricsFactory2.courierBoldItalicAscent = 801;
    PdfStandardFontMetricsFactory2.courierBoldItalicDescent = -250;
    PdfStandardFontMetricsFactory2.courierBoldItalicName = "Courier-BoldOblique";
    PdfStandardFontMetricsFactory2.timesAscent = 898;
    PdfStandardFontMetricsFactory2.timesDescent = -218;
    PdfStandardFontMetricsFactory2.timesName = "Times-Roman";
    PdfStandardFontMetricsFactory2.timesBoldAscent = 935;
    PdfStandardFontMetricsFactory2.timesBoldDescent = -218;
    PdfStandardFontMetricsFactory2.timesBoldName = "Times-Bold";
    PdfStandardFontMetricsFactory2.timesItalicAscent = 883;
    PdfStandardFontMetricsFactory2.timesItalicDescent = -217;
    PdfStandardFontMetricsFactory2.timesItalicName = "Times-Italic";
    PdfStandardFontMetricsFactory2.timesBoldItalicAscent = 921;
    PdfStandardFontMetricsFactory2.timesBoldItalicDescent = -218;
    PdfStandardFontMetricsFactory2.timesBoldItalicName = "Times-BoldItalic";
    PdfStandardFontMetricsFactory2.symbolAscent = 1010;
    PdfStandardFontMetricsFactory2.symbolDescent = -293;
    PdfStandardFontMetricsFactory2.symbolName = "Symbol";
    PdfStandardFontMetricsFactory2.zapfDingbatsAscent = 820;
    PdfStandardFontMetricsFactory2.zapfDingbatsDescent = -143;
    PdfStandardFontMetricsFactory2.zapfDingbatsName = "ZapfDingbats";
    PdfStandardFontMetricsFactory2.arialWidth = [
      278,
      278,
      355,
      556,
      556,
      889,
      667,
      191,
      333,
      333,
      389,
      584,
      278,
      333,
      278,
      278,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      278,
      278,
      584,
      584,
      584,
      556,
      1015,
      667,
      667,
      722,
      722,
      667,
      611,
      778,
      722,
      278,
      500,
      667,
      556,
      833,
      722,
      778,
      667,
      778,
      722,
      667,
      611,
      722,
      667,
      944,
      667,
      667,
      611,
      278,
      278,
      278,
      469,
      556,
      333,
      556,
      556,
      500,
      556,
      556,
      278,
      556,
      556,
      222,
      222,
      500,
      222,
      833,
      556,
      556,
      556,
      556,
      333,
      500,
      278,
      556,
      500,
      722,
      500,
      500,
      500,
      334,
      260,
      334,
      584,
      0,
      556,
      0,
      222,
      556,
      333,
      1e3,
      556,
      556,
      333,
      1e3,
      667,
      333,
      1e3,
      0,
      611,
      0,
      0,
      222,
      222,
      333,
      333,
      350,
      556,
      1e3,
      333,
      1e3,
      500,
      333,
      944,
      0,
      500,
      667,
      0,
      333,
      556,
      556,
      556,
      556,
      260,
      556,
      333,
      737,
      370,
      556,
      584,
      0,
      737,
      333,
      400,
      584,
      333,
      333,
      333,
      556,
      537,
      278,
      333,
      333,
      365,
      556,
      834,
      834,
      834,
      611,
      667,
      667,
      667,
      667,
      667,
      667,
      1e3,
      722,
      667,
      667,
      667,
      667,
      278,
      278,
      278,
      278,
      722,
      722,
      778,
      778,
      778,
      778,
      778,
      584,
      778,
      722,
      722,
      722,
      722,
      667,
      667,
      611,
      556,
      556,
      556,
      556,
      556,
      556,
      889,
      500,
      556,
      556,
      556,
      556,
      278,
      278,
      278,
      278,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      584,
      611,
      556,
      556,
      556,
      556,
      500,
      556,
      500
    ];
    PdfStandardFontMetricsFactory2.arialBoldWidth = [
      278,
      333,
      474,
      556,
      556,
      889,
      722,
      238,
      333,
      333,
      389,
      584,
      278,
      333,
      278,
      278,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      333,
      333,
      584,
      584,
      584,
      611,
      975,
      722,
      722,
      722,
      722,
      667,
      611,
      778,
      722,
      278,
      556,
      722,
      611,
      833,
      722,
      778,
      667,
      778,
      722,
      667,
      611,
      722,
      667,
      944,
      667,
      667,
      611,
      333,
      278,
      333,
      584,
      556,
      333,
      556,
      611,
      556,
      611,
      556,
      333,
      611,
      611,
      278,
      278,
      556,
      278,
      889,
      611,
      611,
      611,
      611,
      389,
      556,
      333,
      611,
      556,
      778,
      556,
      556,
      500,
      389,
      280,
      389,
      584,
      0,
      556,
      0,
      278,
      556,
      500,
      1e3,
      556,
      556,
      333,
      1e3,
      667,
      333,
      1e3,
      0,
      611,
      0,
      0,
      278,
      278,
      500,
      500,
      350,
      556,
      1e3,
      333,
      1e3,
      556,
      333,
      944,
      0,
      500,
      667,
      0,
      333,
      556,
      556,
      556,
      556,
      280,
      556,
      333,
      737,
      370,
      556,
      584,
      0,
      737,
      333,
      400,
      584,
      333,
      333,
      333,
      611,
      556,
      278,
      333,
      333,
      365,
      556,
      834,
      834,
      834,
      611,
      722,
      722,
      722,
      722,
      722,
      722,
      1e3,
      722,
      667,
      667,
      667,
      667,
      278,
      278,
      278,
      278,
      722,
      722,
      778,
      778,
      778,
      778,
      778,
      584,
      778,
      722,
      722,
      722,
      722,
      667,
      667,
      611,
      556,
      556,
      556,
      556,
      556,
      556,
      889,
      556,
      556,
      556,
      556,
      556,
      278,
      278,
      278,
      278,
      611,
      611,
      611,
      611,
      611,
      611,
      611,
      584,
      611,
      611,
      611,
      611,
      611,
      556,
      611,
      556
    ];
    PdfStandardFontMetricsFactory2.fixedWidth = [
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600
    ];
    PdfStandardFontMetricsFactory2.timesRomanWidth = [
      250,
      333,
      408,
      500,
      500,
      833,
      778,
      180,
      333,
      333,
      500,
      564,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      278,
      278,
      564,
      564,
      564,
      444,
      921,
      722,
      667,
      667,
      722,
      611,
      556,
      722,
      722,
      333,
      389,
      722,
      611,
      889,
      722,
      722,
      556,
      722,
      667,
      556,
      611,
      722,
      722,
      944,
      722,
      722,
      611,
      333,
      278,
      333,
      469,
      500,
      333,
      444,
      500,
      444,
      500,
      444,
      333,
      500,
      500,
      278,
      278,
      500,
      278,
      778,
      500,
      500,
      500,
      500,
      333,
      389,
      278,
      500,
      500,
      722,
      500,
      500,
      444,
      480,
      200,
      480,
      541,
      0,
      500,
      0,
      333,
      500,
      444,
      1e3,
      500,
      500,
      333,
      1e3,
      556,
      333,
      889,
      0,
      611,
      0,
      0,
      333,
      333,
      444,
      444,
      350,
      500,
      1e3,
      333,
      980,
      389,
      333,
      722,
      0,
      444,
      722,
      0,
      333,
      500,
      500,
      500,
      500,
      200,
      500,
      333,
      760,
      276,
      500,
      564,
      0,
      760,
      333,
      400,
      564,
      300,
      300,
      333,
      500,
      453,
      250,
      333,
      300,
      310,
      500,
      750,
      750,
      750,
      444,
      722,
      722,
      722,
      722,
      722,
      722,
      889,
      667,
      611,
      611,
      611,
      611,
      333,
      333,
      333,
      333,
      722,
      722,
      722,
      722,
      722,
      722,
      722,
      564,
      722,
      722,
      722,
      722,
      722,
      722,
      556,
      500,
      444,
      444,
      444,
      444,
      444,
      444,
      667,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      564,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500
    ];
    PdfStandardFontMetricsFactory2.timesRomanBoldWidth = [
      250,
      333,
      555,
      500,
      500,
      1e3,
      833,
      278,
      333,
      333,
      500,
      570,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      333,
      333,
      570,
      570,
      570,
      500,
      930,
      722,
      667,
      722,
      722,
      667,
      611,
      778,
      778,
      389,
      500,
      778,
      667,
      944,
      722,
      778,
      611,
      778,
      722,
      556,
      667,
      722,
      722,
      1e3,
      722,
      722,
      667,
      333,
      278,
      333,
      581,
      500,
      333,
      500,
      556,
      444,
      556,
      444,
      333,
      500,
      556,
      278,
      333,
      556,
      278,
      833,
      556,
      500,
      556,
      556,
      444,
      389,
      333,
      556,
      500,
      722,
      500,
      500,
      444,
      394,
      220,
      394,
      520,
      0,
      500,
      0,
      333,
      500,
      500,
      1e3,
      500,
      500,
      333,
      1e3,
      556,
      333,
      1e3,
      0,
      667,
      0,
      0,
      333,
      333,
      500,
      500,
      350,
      500,
      1e3,
      333,
      1e3,
      389,
      333,
      722,
      0,
      444,
      722,
      0,
      333,
      500,
      500,
      500,
      500,
      220,
      500,
      333,
      747,
      300,
      500,
      570,
      0,
      747,
      333,
      400,
      570,
      300,
      300,
      333,
      556,
      540,
      250,
      333,
      300,
      330,
      500,
      750,
      750,
      750,
      500,
      722,
      722,
      722,
      722,
      722,
      722,
      1e3,
      722,
      667,
      667,
      667,
      667,
      389,
      389,
      389,
      389,
      722,
      722,
      778,
      778,
      778,
      778,
      778,
      570,
      778,
      722,
      722,
      722,
      722,
      722,
      611,
      556,
      500,
      500,
      500,
      500,
      500,
      500,
      722,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      556,
      500,
      500,
      500,
      500,
      500,
      570,
      500,
      556,
      556,
      556,
      556,
      500,
      556,
      500
    ];
    PdfStandardFontMetricsFactory2.timesRomanItalicWidth = [
      250,
      333,
      420,
      500,
      500,
      833,
      778,
      214,
      333,
      333,
      500,
      675,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      333,
      333,
      675,
      675,
      675,
      500,
      920,
      611,
      611,
      667,
      722,
      611,
      611,
      722,
      722,
      333,
      444,
      667,
      556,
      833,
      667,
      722,
      611,
      722,
      611,
      500,
      556,
      722,
      611,
      833,
      611,
      556,
      556,
      389,
      278,
      389,
      422,
      500,
      333,
      500,
      500,
      444,
      500,
      444,
      278,
      500,
      500,
      278,
      278,
      444,
      278,
      722,
      500,
      500,
      500,
      500,
      389,
      389,
      278,
      500,
      444,
      667,
      444,
      444,
      389,
      400,
      275,
      400,
      541,
      0,
      500,
      0,
      333,
      500,
      556,
      889,
      500,
      500,
      333,
      1e3,
      500,
      333,
      944,
      0,
      556,
      0,
      0,
      333,
      333,
      556,
      556,
      350,
      500,
      889,
      333,
      980,
      389,
      333,
      667,
      0,
      389,
      556,
      0,
      389,
      500,
      500,
      500,
      500,
      275,
      500,
      333,
      760,
      276,
      500,
      675,
      0,
      760,
      333,
      400,
      675,
      300,
      300,
      333,
      500,
      523,
      250,
      333,
      300,
      310,
      500,
      750,
      750,
      750,
      500,
      611,
      611,
      611,
      611,
      611,
      611,
      889,
      667,
      611,
      611,
      611,
      611,
      333,
      333,
      333,
      333,
      722,
      667,
      722,
      722,
      722,
      722,
      722,
      675,
      722,
      722,
      722,
      722,
      722,
      556,
      611,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      667,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      675,
      500,
      500,
      500,
      500,
      500,
      444,
      500,
      444
    ];
    PdfStandardFontMetricsFactory2.timesRomanBoldItalicWidths = [
      250,
      389,
      555,
      500,
      500,
      833,
      778,
      278,
      333,
      333,
      500,
      570,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      333,
      333,
      570,
      570,
      570,
      500,
      832,
      667,
      667,
      667,
      722,
      667,
      667,
      722,
      778,
      389,
      500,
      667,
      611,
      889,
      722,
      722,
      611,
      722,
      667,
      556,
      611,
      722,
      667,
      889,
      667,
      611,
      611,
      333,
      278,
      333,
      570,
      500,
      333,
      500,
      500,
      444,
      500,
      444,
      333,
      500,
      556,
      278,
      278,
      500,
      278,
      778,
      556,
      500,
      500,
      500,
      389,
      389,
      278,
      556,
      444,
      667,
      500,
      444,
      389,
      348,
      220,
      348,
      570,
      0,
      500,
      0,
      333,
      500,
      500,
      1e3,
      500,
      500,
      333,
      1e3,
      556,
      333,
      944,
      0,
      611,
      0,
      0,
      333,
      333,
      500,
      500,
      350,
      500,
      1e3,
      333,
      1e3,
      389,
      333,
      722,
      0,
      389,
      611,
      0,
      389,
      500,
      500,
      500,
      500,
      220,
      500,
      333,
      747,
      266,
      500,
      606,
      0,
      747,
      333,
      400,
      570,
      300,
      300,
      333,
      576,
      500,
      250,
      333,
      300,
      300,
      500,
      750,
      750,
      750,
      500,
      667,
      667,
      667,
      667,
      667,
      667,
      944,
      667,
      667,
      667,
      667,
      667,
      389,
      389,
      389,
      389,
      722,
      722,
      722,
      722,
      722,
      722,
      722,
      570,
      722,
      722,
      722,
      722,
      722,
      611,
      611,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      722,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      556,
      500,
      500,
      500,
      500,
      500,
      570,
      500,
      556,
      556,
      556,
      556,
      444,
      500,
      444
    ];
    PdfStandardFontMetricsFactory2.symbolWidth = [
      250,
      333,
      713,
      500,
      549,
      833,
      778,
      439,
      333,
      333,
      500,
      549,
      250,
      549,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      278,
      278,
      549,
      549,
      549,
      444,
      549,
      722,
      667,
      722,
      612,
      611,
      763,
      603,
      722,
      333,
      631,
      722,
      686,
      889,
      722,
      722,
      768,
      741,
      556,
      592,
      611,
      690,
      439,
      768,
      645,
      795,
      611,
      333,
      863,
      333,
      658,
      500,
      500,
      631,
      549,
      549,
      494,
      439,
      521,
      411,
      603,
      329,
      603,
      549,
      549,
      576,
      521,
      549,
      549,
      521,
      549,
      603,
      439,
      576,
      713,
      686,
      493,
      686,
      494,
      480,
      200,
      480,
      549,
      750,
      620,
      247,
      549,
      167,
      713,
      500,
      753,
      753,
      753,
      753,
      1042,
      987,
      603,
      987,
      603,
      400,
      549,
      411,
      549,
      549,
      713,
      494,
      460,
      549,
      549,
      549,
      549,
      1e3,
      603,
      1e3,
      658,
      823,
      686,
      795,
      987,
      768,
      768,
      823,
      768,
      768,
      713,
      713,
      713,
      713,
      713,
      713,
      713,
      768,
      713,
      790,
      790,
      890,
      823,
      549,
      250,
      713,
      603,
      603,
      1042,
      987,
      603,
      987,
      603,
      494,
      329,
      790,
      790,
      786,
      713,
      384,
      384,
      384,
      384,
      384,
      384,
      494,
      494,
      494,
      494,
      329,
      274,
      686,
      686,
      686,
      384,
      384,
      384,
      384,
      384,
      384,
      494,
      494,
      494,
      -1
    ];
    PdfStandardFontMetricsFactory2.zapfDingbatsWidth = [
      278,
      974,
      961,
      974,
      980,
      719,
      789,
      790,
      791,
      690,
      960,
      939,
      549,
      855,
      911,
      933,
      911,
      945,
      974,
      755,
      846,
      762,
      761,
      571,
      677,
      763,
      760,
      759,
      754,
      494,
      552,
      537,
      577,
      692,
      786,
      788,
      788,
      790,
      793,
      794,
      816,
      823,
      789,
      841,
      823,
      833,
      816,
      831,
      923,
      744,
      723,
      749,
      790,
      792,
      695,
      776,
      768,
      792,
      759,
      707,
      708,
      682,
      701,
      826,
      815,
      789,
      789,
      707,
      687,
      696,
      689,
      786,
      787,
      713,
      791,
      785,
      791,
      873,
      761,
      762,
      762,
      759,
      759,
      892,
      892,
      788,
      784,
      438,
      138,
      277,
      415,
      392,
      392,
      668,
      668,
      390,
      390,
      317,
      317,
      276,
      276,
      509,
      509,
      410,
      410,
      234,
      234,
      334,
      334,
      732,
      544,
      544,
      910,
      667,
      760,
      760,
      776,
      595,
      694,
      626,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      894,
      838,
      1016,
      458,
      748,
      924,
      748,
      918,
      927,
      928,
      928,
      834,
      873,
      828,
      924,
      924,
      917,
      930,
      931,
      463,
      883,
      836,
      836,
      867,
      867,
      696,
      696,
      874,
      874,
      760,
      946,
      771,
      865,
      771,
      888,
      967,
      888,
      831,
      873,
      927,
      970,
      918
    ];
    return PdfStandardFontMetricsFactory2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-standard-font.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfStandardFont = (
  /** @class */
  function(_super) {
    __extends13(PdfStandardFont2, _super);
    function PdfStandardFont2(fontFamilyPrototype, size, style) {
      var _this = _super.call(this, size, typeof style === "undefined" ? fontFamilyPrototype instanceof PdfStandardFont2 ? fontFamilyPrototype.style : PdfFontStyle.Regular : style) || this;
      _this.dictionaryProperties = new DictionaryProperties();
      _this.encodings = [
        "Unknown",
        "StandardEncoding",
        "MacRomanEncoding",
        "MacExpertEncoding",
        "WinAnsiEncoding",
        "PDFDocEncoding",
        "IdentityH"
      ];
      if (typeof fontFamilyPrototype === "undefined") {
        _this.pdfFontFamily = PdfFontFamily.Helvetica;
      } else if (fontFamilyPrototype instanceof PdfStandardFont2) {
        _this.pdfFontFamily = fontFamilyPrototype.fontFamily;
      } else {
        _this.pdfFontFamily = fontFamilyPrototype;
      }
      _this.checkStyle();
      _this.initializeInternals();
      return _this;
    }
    Object.defineProperty(PdfStandardFont2.prototype, "fontFamily", {
      /* tslint:enable */
      //Properties
      /**
       * Gets the `FontFamily`.
       * @private
       */
      get: function() {
        return this.pdfFontFamily;
      },
      enumerable: true,
      configurable: true
    });
    PdfStandardFont2.prototype.checkStyle = function() {
      if (this.fontFamily === PdfFontFamily.Symbol || this.fontFamily === PdfFontFamily.ZapfDingbats) {
        var style = this.style;
        style &= ~(PdfFontStyle.Bold | PdfFontStyle.Italic);
        this.setStyle(style);
      }
    };
    PdfStandardFont2.prototype.getLineWidth = function(line, format) {
      if (line == null) {
        throw new Error("ArgumentNullException:line");
      }
      var width = 0;
      var name = this.name;
      line = PdfStandardFont2.convert(line);
      for (var i = 0, len = line.length; i < len; i++) {
        var ch = line[i];
        var charWidth = this.getCharWidthInternal(ch, format);
        width += charWidth;
      }
      var size = this.metrics.getSize(format);
      width *= PdfFont.charSizeMultiplier * size;
      width = this.applyFormatSettings(line, format, width);
      return width;
    };
    PdfStandardFont2.prototype.equalsToFont = function(font) {
      var equal = false;
      var stFont = font;
      if (stFont != null) {
        var fontFamilyEqual = this.fontFamily === stFont.fontFamily;
        var lineReducer = ~(PdfFontStyle.Underline | PdfFontStyle.Strikeout);
        var styleEqual = (this.style & lineReducer) === (stFont.style & lineReducer);
        equal = fontFamilyEqual && styleEqual;
      }
      return equal;
    };
    PdfStandardFont2.prototype.initializeInternals = function() {
      var equalFont = null;
      equalFont = PdfDocument.cache.search(this);
      var internals = null;
      var metrics = PdfStandardFontMetricsFactory.getMetrics(this.pdfFontFamily, this.style, this.size);
      this.metrics = metrics;
      internals = this.createInternals();
      this.setInternals(internals);
    };
    PdfStandardFont2.prototype.createInternals = function() {
      var dictionary = new PdfDictionary();
      dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
      dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type1));
      dictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.metrics.postScriptName));
      if (this.fontFamily !== PdfFontFamily.Symbol && this.fontFamily !== PdfFontFamily.ZapfDingbats) {
        var encoding = this.encodings[FontEncoding.WinAnsiEncoding];
        dictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(encoding));
      }
      return dictionary;
    };
    PdfStandardFont2.prototype.getCharWidthInternal = function(charCode, format) {
      var width = 0;
      var code = 0;
      code = charCode.charCodeAt(0);
      if (this.name === "0" || this.name === "1" || this.name === "2" || this.name === "3" || this.name === "4") {
        code = code - PdfStandardFont2.charOffset;
      }
      code = code >= 0 && code !== 128 ? code : 0;
      var metrics = this.metrics;
      var widthTable = metrics.widthTable;
      width = widthTable.items(code);
      return width;
    };
    PdfStandardFont2.convert = function(text) {
      return text;
    };
    PdfStandardFont2.charOffset = 32;
    return PdfStandardFont2;
  }(PdfFont)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-document.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfDocument = (
  /** @class */
  function(_super) {
    __extends14(PdfDocument2, _super);
    function PdfDocument2(isMerging) {
      var _this = _super.call(this) || this;
      _this.defaultMargin = 40;
      _this.streamWriter = null;
      _this.document = _this;
      var isMerge = false;
      if (typeof isMerging === "undefined") {
        PdfDocument2.cacheCollection = new PdfCacheCollection();
        isMerge = false;
      } else {
        isMerge = isMerging;
      }
      var objects = new PdfMainObjectCollection();
      _this.setMainObjectCollection(objects);
      var crossTable = new PdfCrossTable();
      crossTable.isMerging = isMerge;
      crossTable.document = _this;
      _this.setCrossTable(crossTable);
      var catalog = new PdfCatalog();
      _this.setCatalog(catalog);
      objects.add(catalog);
      catalog.position = -1;
      _this.sectionCollection = new PdfSectionCollection(_this);
      _this.documentPageCollection = new PdfDocumentPageCollection(_this);
      catalog.pages = _this.sectionCollection;
      return _this;
    }
    Object.defineProperty(PdfDocument2, "defaultFont", {
      //Properties
      /**
       * Gets the `default font`. It is used for complex objects when font is not explicitly defined.
       * @private
       */
      get: function() {
        if (this.defaultStandardFont == null) {
          this.defaultStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 8);
        }
        return this.defaultStandardFont;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "sections", {
      /**
       * Gets the collection of the `sections` in the document.
       * @private
       */
      get: function() {
        return this.sectionCollection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "pageSettings", {
      /**
       * Gets the document's page setting.
       * @public
       */
      get: function() {
        if (this.settings == null) {
          this.settings = new PdfPageSettings(this.defaultMargin);
        }
        return this.settings;
      },
      /**
       * Sets the document's page setting.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       *
       * // sets the right margin of the page
       * document.pageSettings.margins.right = 0;
       * // set the page size.
       * document.pageSettings.size = new SizeF(500, 500);
       * // change the page orientation to landscape
       * document.pageSettings.orientation = PdfPageOrientation.Landscape;
       * // apply 90 degree rotation on the page
       * document.pageSettings.rotate = PdfPageRotateAngle.RotateAngle90;
       *
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * // set the specified Point
       * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, point);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this.settings = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "pages", {
      /**
       * Represents the collection of pages in the PDF document.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * //
       * // get the collection of pages in the document
       * let pageCollection : PdfDocumentPageCollection  = document.pages;
       * //
       * // add pages
       * let page1 : PdfPage = pageCollection.add();
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.documentPageCollection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2, "cache", {
      /**
       * Gets collection of the `cached objects`.
       * @private
       */
      get: function() {
        if (typeof PdfDocument2.cacheCollection === "undefined" || PdfDocument2.cacheCollection == null) {
          return new PdfCacheCollection();
        }
        return PdfDocument2.cacheCollection;
      },
      /**
       * Sets collection of the `cached objects`.
       * @private
       */
      set: function(value) {
        this.cacheCollection = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2, "enableCache", {
      /**
       * Gets the value of enable cache.
       * @private
       */
      get: function() {
        return this.isCacheEnabled;
      },
      /**
       * Sets thie value of enable cache.
       * @private
       */
      set: function(value) {
        this.isCacheEnabled = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "colorSpace", {
      /* tslint:disable */
      /**
       * Gets or sets the `color space` of the document. This property can be used to create PDF document in RGB, Gray scale or CMYK color spaces.
       * @private
       */
      get: function() {
        if (this.pdfColorSpace === PdfColorSpace.Rgb || (this.pdfColorSpace === PdfColorSpace.Cmyk || this.pdfColorSpace === PdfColorSpace.GrayScale)) {
          return this.pdfColorSpace;
        } else {
          return PdfColorSpace.Rgb;
        }
      },
      set: function(value) {
        if (value === PdfColorSpace.Rgb || (value === PdfColorSpace.Cmyk || value === PdfColorSpace.GrayScale)) {
          this.pdfColorSpace = value;
        } else {
          this.pdfColorSpace = PdfColorSpace.Rgb;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "template", {
      /* tslint:enable */
      /**
       * Gets or sets a `template` to all pages in the document.
       * @private
       */
      get: function() {
        if (this.pageTemplate == null) {
          this.pageTemplate = new PdfDocumentTemplate();
        }
        return this.pageTemplate;
      },
      set: function(value) {
        this.pageTemplate = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocument2.prototype.docSave = function(stream, arg2, arg3) {
      this.checkPagesPresence();
      if (stream === null) {
        throw new Error("ArgumentNullException : stream");
      }
      this.streamWriter = stream;
      var writer = new PdfWriter(stream);
      writer.document = this;
      if (typeof arg2 === "boolean" && typeof arg3 === "undefined") {
        return this.crossTable.save(writer);
      } else {
        this.crossTable.save(writer, arg2);
      }
    };
    PdfDocument2.prototype.checkPagesPresence = function() {
      if (this.pages.count === 0) {
        this.pages.add();
      }
    };
    PdfDocument2.prototype.destroy = function() {
      this.catalog = void 0;
      this.colorSpace = void 0;
      this.currentSavingObj = void 0;
      this.documentPageCollection = void 0;
      this.isStreamCopied = void 0;
      this.pageSettings = void 0;
      this.pageTemplate = void 0;
      this.pdfColorSpace = void 0;
      this.sectionCollection = void 0;
      PdfDocument2.cache.destroy();
      this.crossTable.pdfObjects.destroy();
      PdfDocument2.cache = void 0;
      this.streamWriter.destroy();
    };
    PdfDocument2.defaultStandardFont = null;
    PdfDocument2.isCacheEnabled = true;
    return PdfDocument2;
  }(PdfDocumentBase)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/styles/pdf-borders.js
var PdfBorders = (
  /** @class */
  function() {
    function PdfBorders2() {
      var defaultBorderPenLeft = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenLeft.dashStyle = PdfDashStyle.Solid;
      var defaultBorderPenRight = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenRight.dashStyle = PdfDashStyle.Solid;
      var defaultBorderPenTop = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenTop.dashStyle = PdfDashStyle.Solid;
      var defaultBorderPenBottom = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenBottom.dashStyle = PdfDashStyle.Solid;
      this.leftPen = defaultBorderPenLeft;
      this.rightPen = defaultBorderPenRight;
      this.topPen = defaultBorderPenTop;
      this.bottomPen = defaultBorderPenBottom;
    }
    Object.defineProperty(PdfBorders2.prototype, "left", {
      // Properties
      /**
       * Gets or sets the `Left`.
       * @private
       */
      get: function() {
        return this.leftPen;
      },
      set: function(value) {
        this.leftPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "right", {
      /**
       * Gets or sets the `Right`.
       * @private
       */
      get: function() {
        return this.rightPen;
      },
      set: function(value) {
        this.rightPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "top", {
      /**
       * Gets or sets the `Top`.
       * @private
       */
      get: function() {
        return this.topPen;
      },
      set: function(value) {
        this.topPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "bottom", {
      /**
       * Gets or sets the `Bottom`.
       * @private
       */
      get: function() {
        return this.bottomPen;
      },
      set: function(value) {
        this.bottomPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "all", {
      /**
       * sets the `All`.
       * @private
       */
      set: function(value) {
        this.leftPen = this.rightPen = this.topPen = this.bottomPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "isAll", {
      /**
       * Gets a value indicating whether this instance `is all`.
       * @private
       */
      get: function() {
        return this.leftPen === this.rightPen && this.leftPen === this.topPen && this.leftPen === this.bottomPen;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2, "default", {
      /**
       * Gets the `default`.
       * @private
       */
      get: function() {
        return new PdfBorders2();
      },
      enumerable: true,
      configurable: true
    });
    return PdfBorders2;
  }()
);
var PdfPaddings = (
  /** @class */
  function() {
    function PdfPaddings2(left, right, top, bottom) {
      this.hasLeftPad = false;
      this.hasRightPad = false;
      this.hasTopPad = false;
      this.hasBottomPad = false;
      if (typeof left === "undefined") {
        this.leftPad = this.rightPad = 5.76;
        this.bottomPad = this.topPad = 0.5;
      } else {
        this.leftPad = left;
        this.rightPad = right;
        this.topPad = top;
        this.bottomPad = bottom;
        this.hasLeftPad = true;
        this.hasRightPad = true;
        this.hasTopPad = true;
        this.hasBottomPad = true;
      }
    }
    Object.defineProperty(PdfPaddings2.prototype, "left", {
      // Properties
      /**
       * Gets or sets the `left` value of the edge
       * @private
       */
      get: function() {
        return this.leftPad;
      },
      set: function(value) {
        this.leftPad = value;
        this.hasLeftPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "right", {
      /**
       * Gets or sets the `right` value of the edge.
       * @private
       */
      get: function() {
        return this.rightPad;
      },
      set: function(value) {
        this.rightPad = value;
        this.hasRightPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "top", {
      /**
       * Gets or sets the `top` value of the edge
       * @private
       */
      get: function() {
        return this.topPad;
      },
      set: function(value) {
        this.topPad = value;
        this.hasTopPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "bottom", {
      /**
       * Gets or sets the `bottom` value of the edge.
       * @private
       */
      get: function() {
        return this.bottomPad;
      },
      set: function(value) {
        this.bottomPad = value;
        this.hasBottomPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "all", {
      /**
       * Sets value to all sides `left,right,top and bottom`.s
       * @private
       */
      set: function(value) {
        this.leftPad = this.rightPad = this.topPad = this.bottomPad = value;
        this.hasLeftPad = true;
        this.hasRightPad = true;
        this.hasTopPad = true;
        this.hasBottomPad = true;
      },
      enumerable: true,
      configurable: true
    });
    return PdfPaddings2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/element-layouter.js
var ElementLayouter = (
  /** @class */
  function() {
    function ElementLayouter2(element) {
      this.layoutElement = element;
    }
    Object.defineProperty(ElementLayouter2.prototype, "elements", {
      // Properties
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.layoutElement;
      },
      enumerable: true,
      configurable: true
    });
    ElementLayouter2.prototype.getElement = function() {
      return this.layoutElement;
    };
    ElementLayouter2.prototype.layout = function(param) {
      return this.layoutInternal(param);
    };
    ElementLayouter2.prototype.Layouter = function(param) {
      return this.layoutInternal(param);
    };
    ElementLayouter2.prototype.getNextPage = function(currentPage) {
      var section = currentPage.section;
      var nextPage = section.add();
      return nextPage;
    };
    ElementLayouter2.prototype.getPaginateBounds = function(param) {
      if (param == null) {
        throw new Error("ArgumentNullException : param");
      }
      var result = param.format.usePaginateBounds ? param.format.paginateBounds : new RectangleF(param.bounds.x, 0, param.bounds.width, param.bounds.height);
      return result;
    };
    return ElementLayouter2;
  }()
);
var PdfLayoutFormat = (
  /** @class */
  function() {
    function PdfLayoutFormat2(baseFormat) {
      if (typeof baseFormat === "undefined") {
      } else {
        this.break = baseFormat.break;
        this.layout = baseFormat.layout;
        this.paginateBounds = baseFormat.paginateBounds;
        this.boundsSet = baseFormat.usePaginateBounds;
      }
    }
    Object.defineProperty(PdfLayoutFormat2.prototype, "layout", {
      // Properties
      /**
       * Gets or sets `layout` type of the element.
       * @private
       */
      get: function() {
        return this.layoutType;
      },
      set: function(value) {
        this.layoutType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutFormat2.prototype, "break", {
      /**
       * Gets or sets `break` type of the element.
       * @private
       */
      get: function() {
        return this.breakType;
      },
      set: function(value) {
        this.breakType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutFormat2.prototype, "paginateBounds", {
      /**
       * Gets or sets the `bounds` on the next page.
       * @private
       */
      get: function() {
        if (typeof this.layoutPaginateBounds === "undefined" && this.layoutPaginateBounds == null) {
          this.layoutPaginateBounds = new RectangleF(0, 0, 0, 0);
        }
        return this.layoutPaginateBounds;
      },
      set: function(value) {
        this.layoutPaginateBounds = value;
        this.boundsSet = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutFormat2.prototype, "usePaginateBounds", {
      /**
       * Gets a value indicating whether [`use paginate bounds`].
       * @private
       */
      get: function() {
        return this.boundsSet;
      },
      enumerable: true,
      configurable: true
    });
    return PdfLayoutFormat2;
  }()
);
var PdfLayoutParams = (
  /** @class */
  function() {
    function PdfLayoutParams2() {
    }
    Object.defineProperty(PdfLayoutParams2.prototype, "page", {
      // Properties
      /**
       * Gets or sets the layout `page` for the element.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      set: function(value) {
        this.pdfPage = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutParams2.prototype, "bounds", {
      /**
       * Gets or sets layout `bounds` for the element.
       * @private
       */
      get: function() {
        return new RectangleF(this.layoutBounds.x, this.layoutBounds.y, this.layoutBounds.width, this.layoutBounds.height);
      },
      set: function(value) {
        this.layoutBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutParams2.prototype, "format", {
      /**
       * Gets or sets `layout settings` for the element.
       * @private
       */
      get: function() {
        return this.layoutFormat;
      },
      set: function(value) {
        this.layoutFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfLayoutParams2;
  }()
);
var PdfLayoutResult = (
  /** @class */
  function() {
    function PdfLayoutResult2(page, bounds) {
      this.pdfPage = page;
      this.layoutBounds = bounds;
    }
    Object.defineProperty(PdfLayoutResult2.prototype, "page", {
      // Properties
      /**
       * Gets the last `page` where the element was drawn.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutResult2.prototype, "bounds", {
      /**
       * Gets the `bounds` of the element on the last page where it was drawn.
       * @private
       */
      get: function() {
        return this.layoutBounds;
      },
      enumerable: true,
      configurable: true
    });
    return PdfLayoutResult2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/layout-element.js
var PdfLayoutElement = (
  /** @class */
  function() {
    function PdfLayoutElement2() {
    }
    Object.defineProperty(PdfLayoutElement2.prototype, "raiseBeginPageLayout", {
      // Property
      /**
       * Gets a value indicating whether the `start page layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.beginPageLayout !== "undefined";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutElement2.prototype, "raiseEndPageLayout", {
      /**
       * Gets a value indicating whether the `ending page layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.endPageLayout !== "undefined";
      },
      enumerable: true,
      configurable: true
    });
    PdfLayoutElement2.prototype.onBeginPageLayout = function(args) {
      if (this.beginPageLayout) {
        this.beginPageLayout(this, args);
      }
    };
    PdfLayoutElement2.prototype.onEndPageLayout = function(args) {
      if (this.endPageLayout) {
        this.endPageLayout(this, args);
      }
    };
    PdfLayoutElement2.prototype.drawHelper = function(arg2, arg3, arg4, arg5) {
      if (arg3 instanceof PointF && typeof arg3.width === "undefined" && typeof arg4 === "undefined") {
        return this.drawHelper(arg2, arg3.x, arg3.y);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && typeof arg5 === "undefined") {
        return this.drawHelper(arg2, arg3, arg4, null);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "undefined") {
        return this.drawHelper(arg2, arg3, null);
      } else if (arg3 instanceof PointF && typeof arg3.width === "undefined" && arg4 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg2, arg3.x, arg3.y, arg4);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && (arg5 instanceof PdfLayoutFormat || arg5 == null)) {
        var width = arg2.graphics.clientSize.width - arg3;
        var layoutRectangle = new RectangleF(arg3, arg4, width, 0);
        return this.drawHelper(arg2, layoutRectangle, arg5);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "boolean") {
        this.bEmbedFonts = arg4;
        return this.drawHelper(arg2, arg3, null);
      } else {
        var param = new PdfLayoutParams();
        var temparg3 = arg3;
        var temparg4 = arg4;
        param.page = arg2;
        param.bounds = temparg3;
        if (param != null) {
          var x = param.bounds.x;
          var y = param.bounds.y;
          if (param.bounds.x === 0) {
            x = PdfBorders.default.right.width / 2;
          }
          if (param.bounds.y === 0) {
            y = PdfBorders.default.top.width / 2;
          }
          var newBound = new RectangleF(x, y, param.bounds.width, param.bounds.height);
          param.bounds = newBound;
        }
        param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();
        var result = this.layout(param);
        return result;
      }
    };
    return PdfLayoutElement2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/text-layouter.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TextLayouter = (
  /** @class */
  function(_super) {
    __extends15(TextLayouter2, _super);
    function TextLayouter2(element) {
      return _super.call(this, element) || this;
    }
    Object.defineProperty(TextLayouter2.prototype, "element", {
      /**
       * Gets the layout `element`.
       * @private
       */
      get: function() {
        return _super.prototype.getElement.call(this);
      },
      enumerable: true,
      configurable: true
    });
    TextLayouter2.prototype.layoutInternal = function(param) {
      this.format = this.element.stringFormat !== null && typeof this.element.stringFormat !== "undefined" ? this.element.stringFormat : null;
      var currentPage = param.page;
      var currentBounds = param.bounds;
      var text = this.element.value;
      var result = null;
      var pageResult = new TextPageLayoutResult();
      pageResult.page = currentPage;
      pageResult.remainder = text;
      for (; ; ) {
        pageResult = this.layoutOnPage(text, currentPage, currentBounds, param);
        result = this.getLayoutResult(pageResult);
        break;
      }
      return result;
    };
    TextLayouter2.prototype.getLayoutResult = function(pageResult) {
      var result = new PdfTextLayoutResult(pageResult.page, pageResult.bounds, pageResult.remainder, pageResult.lastLineBounds);
      return result;
    };
    TextLayouter2.prototype.layoutOnPage = function(text, currentPage, currentBounds, param) {
      var result = new TextPageLayoutResult();
      result.remainder = text;
      result.page = currentPage;
      currentBounds = this.checkCorrectBounds(currentPage, currentBounds);
      var layouter = new PdfStringLayouter();
      var stringResult = layouter.layout(text, this.element.font, this.format, currentBounds, currentPage.getClientSize().height, false, new SizeF(0, 0));
      var textFinished = stringResult.remainder == null;
      var doesntFit = param.format.break === PdfLayoutBreakType.FitElement;
      var canDraw = !(doesntFit || stringResult.empty);
      var graphics = currentPage.graphics;
      var brush = this.element.getBrush();
      if (this.element instanceof PdfTextWebLink) {
        brush.color = new PdfColor(0, 0, 255);
      }
      graphics.drawStringLayoutResult(stringResult, this.element.font, this.element.pen, brush, currentBounds, this.format);
      var lineInfo = stringResult.lines[stringResult.lineCount - 1];
      result.lastLineBounds = graphics.getLineBounds(stringResult.lineCount - 1, stringResult, this.element.font, currentBounds, this.format);
      result.bounds = this.getTextPageBounds(currentPage, currentBounds, stringResult);
      result.remainder = stringResult.remainder;
      result.end = textFinished;
      return result;
    };
    TextLayouter2.prototype.checkCorrectBounds = function(currentPage, currentBounds) {
      var pageSize = currentPage.graphics.clientSize;
      currentBounds.height = currentBounds.height > 0 ? currentBounds.height : pageSize.height - currentBounds.y;
      return currentBounds;
    };
    TextLayouter2.prototype.getTextPageBounds = function(currentPage, currentBounds, stringResult) {
      var textSize = stringResult.actualSize;
      var x = currentBounds.x;
      var y = currentBounds.y;
      var width = currentBounds.width > 0 ? currentBounds.width : textSize.width;
      var height = textSize.height;
      var shiftedRect = currentPage.graphics.checkCorrectLayoutRectangle(textSize, currentBounds.x, currentBounds.y, this.format);
      x = shiftedRect.x;
      var verticalShift = currentPage.graphics.getTextVerticalAlignShift(textSize.height, currentBounds.height, this.format);
      y += verticalShift;
      var bounds = new RectangleF(x, y, width, height);
      return bounds;
    };
    return TextLayouter2;
  }(ElementLayouter)
);
var TextPageLayoutResult = (
  /** @class */
  function() {
    function TextPageLayoutResult2() {
    }
    return TextPageLayoutResult2;
  }()
);
var PdfTextLayoutResult = (
  /** @class */
  function(_super) {
    __extends15(PdfTextLayoutResult2, _super);
    function PdfTextLayoutResult2(page, bounds, remainder, lastLineBounds) {
      var _this = _super.call(this, page, bounds) || this;
      _this.remainderText = remainder;
      _this.lastLineTextBounds = lastLineBounds;
      return _this;
    }
    Object.defineProperty(PdfTextLayoutResult2.prototype, "remainder", {
      // Properties
      /**
       * Gets a value that contains the `text` that was not printed.
       * @private
       */
      get: function() {
        return this.remainderText;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextLayoutResult2.prototype, "lastLineBounds", {
      /**
       * Gets a value that indicates the `bounds` of the last line that was printed on the page.
       * @private
       */
      get: function() {
        return this.lastLineTextBounds;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTextLayoutResult2;
  }(PdfLayoutResult)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/text-element.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfTextElement = (
  /** @class */
  function(_super) {
    __extends16(PdfTextElement2, _super);
    function PdfTextElement2(arg1, arg2, arg3, arg4, arg5) {
      var _this = _super.call(this) || this;
      _this.content = "";
      _this.elementValue = "";
      _this.hasPointOverload = false;
      _this.isPdfTextElement = false;
      if (typeof arg1 === "undefined") {
      } else if (typeof arg1 === "string" && typeof arg2 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
      } else if (typeof arg1 === "string" && arg2 instanceof PdfFont && typeof arg3 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
      } else if (typeof arg1 === "string" && arg2 instanceof PdfFont && arg3 instanceof PdfPen && typeof arg4 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
        _this.pdfPen = arg3;
      } else if (typeof arg1 === "string" && arg2 instanceof PdfFont && arg3 instanceof PdfBrush && typeof arg4 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
        _this.pdfBrush = arg3;
      } else {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
        _this.pdfPen = arg3;
        _this.pdfBrush = arg4;
        _this.format = arg5;
      }
      return _this;
    }
    Object.defineProperty(PdfTextElement2.prototype, "text", {
      // Properties
      /**
       * Gets or sets a value indicating the `text` that should be printed.
       * ```typescript
       * // create a new PDF document.
       * let document : PdfDocument = new PdfDocument();
       * // add a page to the document.
       * let page1 : PdfPage = document.pages.add();
       * // create the font
       * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
       * // create the Text Web Link
       * let textLink : PdfTextWebLink = new PdfTextWebLink();
       * // set the hyperlink
       * textLink.url = 'http://www.google.com';
       * //
       * // set the link text
       * textLink.text = 'Google';
       * //
       * // set the font
       * textLink.font = font;
       * // draw the hyperlink in PDF page
       * textLink.draw(page1, new PointF(10, 40));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.elementValue = value;
        this.content = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "value", {
      //get value
      /**
       * Gets or sets a `value` indicating the text that should be printed.
       * @private
       */
      get: function() {
        return this.elementValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "pen", {
      //get pen
      /**
       * Gets or sets a `PdfPen` that determines the color, width, and style of the text
       * @private
       */
      get: function() {
        return this.pdfPen;
      },
      //Set pen value
      set: function(value) {
        this.pdfPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "brush", {
      //get brush
      /**
       * Gets or sets the `PdfBrush` that will be used to draw the text with color and texture.
       * @private
       */
      get: function() {
        return this.pdfBrush;
      },
      //Set brush value
      set: function(value) {
        this.pdfBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "font", {
      //get font
      /**
       * Gets or sets a `PdfFont` that defines the text format.
       * ```typescript
       * // create a new PDF document.
       * let document : PdfDocument = new PdfDocument();
       * // add a page to the document.
       * let page1 : PdfPage = document.pages.add();
       * // create the font
       * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
       * // create the Text Web Link
       * let textLink : PdfTextWebLink = new PdfTextWebLink();
       * // set the hyperlink
       * textLink.url = 'http://www.google.com';
       * // set the link text
       * textLink.text = 'Google';
       * //
       * // set the font
       * textLink.font = font;
       * //
       * // draw the hyperlink in PDF page
       * textLink.draw(page1, new PointF(10, 40));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.pdfFont;
      },
      set: function(value) {
        this.pdfFont = value;
        if (this.pdfFont instanceof PdfStandardFont && this.content != null) {
          this.elementValue = PdfStandardFont.convert(this.content);
        } else {
          this.elementValue = this.content;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "stringFormat", {
      /**
       * Gets or sets the `PdfStringFormat` that will be used to set the string format
       * @private
       */
      get: function() {
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTextElement2.prototype.getBrush = function() {
      return this.pdfBrush == null || typeof this.pdfBrush === "undefined" ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.pdfBrush;
    };
    PdfTextElement2.prototype.layout = function(param) {
      var layouter = new TextLayouter(this);
      var result = layouter.layout(param);
      return result;
    };
    PdfTextElement2.prototype.drawText = function(arg2, arg3, arg4, arg5) {
      if (arg3 instanceof PointF && typeof arg3.width === "undefined" && typeof arg4 === "undefined") {
        this.hasPointOverload = true;
        return this.drawText(arg2, arg3.x, arg3.y);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && typeof arg5 === "undefined") {
        this.hasPointOverload = true;
        return this.drawText(arg2, arg3, arg4, null);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "undefined") {
        return this.drawText(arg2, arg3, null);
      } else if (arg3 instanceof PointF && typeof arg3.width === "undefined" && arg4 instanceof PdfLayoutFormat) {
        this.hasPointOverload = true;
        return this.drawText(arg2, arg3.x, arg3.y, arg4);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && (arg5 instanceof PdfLayoutFormat || arg5 == null)) {
        this.hasPointOverload = true;
        var width = arg2.graphics.clientSize.width - arg3;
        var layoutRectangle = new RectangleF(arg3, arg4, width, 0);
        return this.drawText(arg2, layoutRectangle, arg5);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "boolean") {
        return this.drawText(arg2, arg3, null);
      } else {
        var layout = new PdfStringLayouter();
        if (this.hasPointOverload) {
          var stringLayoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg2.graphics.clientSize.width - arg3.x, 0), true, arg2.graphics.clientSize);
          var layoutResult = void 0;
          var param = new PdfLayoutParams();
          var temparg3 = arg3;
          var temparg4 = arg4;
          param.page = arg2;
          var previousPage = arg2;
          param.bounds = temparg3;
          param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();
          if (stringLayoutResult.lines.length > 1) {
            this.text = stringLayoutResult.layoutLines[0].text;
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              var previousPosition = new PointF(param.bounds.x, param.bounds.y);
              layoutResult = this.layout(param);
              var bounds = new RectangleF(0, layoutResult.bounds.y + stringLayoutResult.lineHeight, arg2.graphics.clientSize.width, stringLayoutResult.lineHeight);
              var isPaginate = false;
              for (var i = 1; i < stringLayoutResult.lines.length; i++) {
                param.page = layoutResult.page;
                param.bounds = new RectangleF(new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));
                this.text = stringLayoutResult.layoutLines[i].text;
                if (bounds.y + stringLayoutResult.lineHeight > layoutResult.page.graphics.clientSize.height) {
                  isPaginate = true;
                  param.page = param.page.graphics.getNextPage();
                  if (previousPosition.y > layoutResult.page.graphics.clientSize.height - layoutResult.bounds.height) {
                    bounds = new RectangleF(0, layoutResult.bounds.height, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);
                  } else {
                    bounds = new RectangleF(0, 0, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);
                  }
                  param.bounds = bounds;
                }
                layoutResult = this.layout(param);
                if (i !== stringLayoutResult.lines.length - 1) {
                  bounds = new RectangleF(0, layoutResult.bounds.y + stringLayoutResult.lineHeight, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);
                } else {
                  var lineWidth = this.font.measureString(this.text, this.format).width;
                  layoutResult = this.calculateResultBounds(layoutResult, lineWidth, layoutResult.page.graphics.clientSize.width, 0);
                }
              }
            }
            return layoutResult;
          } else {
            var lineSize = this.font.measureString(this.text, this.format);
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              layoutResult = this.layout(param);
              layoutResult = this.calculateResultBounds(layoutResult, lineSize.width, layoutResult.page.graphics.clientSize.width, 0);
            }
            return layoutResult;
          }
        } else {
          var layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg3.width, 0), false, arg2.graphics.clientSize);
          var result = void 0;
          var param = new PdfLayoutParams();
          var temparg3 = arg3;
          var temparg4 = arg4;
          param.page = arg2;
          param.bounds = temparg3;
          param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();
          if (layoutResult.lines.length > 1) {
            this.text = layoutResult.layoutLines[0].text;
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              var previousPosition = new PointF(param.bounds.x, param.bounds.y);
              result = this.layout(param);
              var bounds = new RectangleF(temparg3.x, result.bounds.y + layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);
              var isPaginate = false;
              for (var i = 1; i < layoutResult.lines.length; i++) {
                param.page = result.page;
                param.bounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);
                this.text = layoutResult.layoutLines[i].text;
                if (bounds.y + layoutResult.lineHeight > result.page.graphics.clientSize.height) {
                  isPaginate = true;
                  param.page = param.page.graphics.getNextPage();
                  if (previousPosition.y > result.page.graphics.clientSize.height - result.bounds.height) {
                    bounds = new RectangleF(temparg3.x, layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);
                  } else {
                    bounds = new RectangleF(temparg3.x, 0, temparg3.width, layoutResult.lineHeight);
                  }
                  param.bounds = bounds;
                }
                result = this.layout(param);
                if (i !== layoutResult.lines.length - 1) {
                  bounds = new RectangleF(temparg3.x, result.bounds.y + layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);
                } else {
                  var lineWidth = this.font.measureString(this.text, this.format).width;
                  result = this.calculateResultBounds(result, lineWidth, temparg3.width, temparg3.x);
                }
              }
            }
            return result;
          } else {
            var lineSize = this.font.measureString(this.text, this.format);
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              result = this.layout(param);
              result = this.calculateResultBounds(result, lineSize.width, temparg3.width, temparg3.x);
            }
            return result;
          }
        }
      }
    };
    PdfTextElement2.prototype.calculateResultBounds = function(result, lineWidth, maximumWidth, startPosition) {
      var shift = 0;
      if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Center) {
        result.bounds.x = startPosition + (maximumWidth - lineWidth) / 2;
        result.bounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Right) {
        result.bounds.x = startPosition + (maximumWidth - lineWidth);
        result.bounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Justify) {
        result.bounds.x = startPosition;
        result.bounds.width = maximumWidth;
      } else {
        result.bounds.width = startPosition;
        result.bounds.width = lineWidth;
      }
      return result;
    };
    return PdfTextElement2;
  }(PdfLayoutElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/annotation.js
var PdfAnnotation = (
  /** @class */
  function() {
    function PdfAnnotation2(arg1) {
      this.dictionaryProperties = new DictionaryProperties();
      this.pdfColor = new PdfColor(255, 255, 255);
      this.rectangle = new RectangleF(0, 0, 0, 0);
      this.pdfPage = null;
      this.textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
      this.textFont = new PdfStandardFont(PdfFontFamily.TimesRoman, 10);
      this.format = new PdfStringFormat(PdfTextAlignment.Left);
      this.content = "";
      this.pdfDictionary = new PdfDictionary();
      this.internalColor = new PdfColor();
      this.darkness = 1;
      if (typeof arg1 === "undefined") {
        this.initialize();
      } else {
        this.initialize();
        this.bounds = arg1;
      }
    }
    Object.defineProperty(PdfAnnotation2.prototype, "color", {
      // Properties
      /**
       * `Color` of the annotation
       * @private
       */
      get: function() {
        return this.pdfColor;
      },
      set: function(value) {
        this.pdfColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "innerColor", {
      /**
       * To specifying the `Inner color` with which to fill the annotation
       * @private
       */
      get: function() {
        return this.internalColor;
      },
      set: function(value) {
        this.internalColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "bounds", {
      /**
       * `bounds` of the annotation.
       * @private
       */
      get: function() {
        return this.rectangle;
      },
      set: function(value) {
        this.rectangle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "page", {
      /**
       * Parent `page` of the annotation.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "font", {
      /**
       * To specifying the `Font of the text` in the annotation.
       * @private
       */
      get: function() {
        return this.textFont;
      },
      set: function(value) {
        this.textFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "stringFormat", {
      /**
       * To specifying the `StringFormat of the text` in the annotation.
       * @private
       */
      get: function() {
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "brush", {
      /**
       * To specifying the `Brush of the text` in the annotation.
       * @private
       */
      get: function() {
        return this.textBrush;
      },
      set: function(value) {
        this.textBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "text", {
      /**
       * `Text` of the annotation.
       * @private
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.content = value;
        this.dictionary.items.setValue(this.dictionaryProperties.contents, new PdfString(this.content));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "dictionary", {
      /**
       * Internal variable to store `dictionary`.
       * @hidden
       */
      get: function() {
        return this.pdfDictionary;
      },
      set: function(value) {
        this.pdfDictionary = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfAnnotation2.prototype.initialize = function() {
      this.pdfDictionary.annotationBeginSave = new SaveAnnotationEventHandler(this);
      this.pdfDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.annot));
    };
    PdfAnnotation2.prototype.setPage = function(page) {
      this.pdfPage = page;
      this.pdfDictionary.items.setValue(this.dictionaryProperties.p, new PdfReferenceHolder(this.pdfPage));
    };
    PdfAnnotation2.prototype.beginSave = function() {
      this.save();
    };
    PdfAnnotation2.prototype.save = function() {
      var nativeRectangle = new RectangleF(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);
      var section = this.pdfPage.section;
      var initialHeight = nativeRectangle.height;
      var tempLoacation = section.pointToNativePdf(this.page, new PointF(nativeRectangle.x, nativeRectangle.y));
      nativeRectangle.x = tempLoacation.x;
      nativeRectangle.width = tempLoacation.x + nativeRectangle.width;
      nativeRectangle.y = tempLoacation.y - this.page.document.pageSettings.margins.top;
      nativeRectangle.height = nativeRectangle.y - initialHeight;
      this.pdfDictionary.items.setValue(this.dictionaryProperties.rect, PdfArray.fromRectangle(nativeRectangle));
      this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(this.darkness));
    };
    Object.defineProperty(PdfAnnotation2.prototype, "element", {
      /* tslint:enable */
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.pdfDictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAnnotation2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/link-annotation.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfLinkAnnotation = (
  /** @class */
  function(_super) {
    __extends17(PdfLinkAnnotation2, _super);
    function PdfLinkAnnotation2(rectangle) {
      return _super.call(this, rectangle) || this;
    }
    PdfLinkAnnotation2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      this.dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.link));
    };
    return PdfLinkAnnotation2;
  }(PdfAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/action-link-annotation.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfActionLinkAnnotation = (
  /** @class */
  function(_super) {
    __extends18(PdfActionLinkAnnotation2, _super);
    function PdfActionLinkAnnotation2(rectangle) {
      var _this = _super.call(this, rectangle) || this;
      _this.pdfAction = null;
      return _this;
    }
    PdfActionLinkAnnotation2.prototype.getSetAction = function(value) {
      if (typeof value === "undefined") {
        return this.pdfAction;
      } else {
        this.pdfAction = value;
      }
    };
    return PdfActionLinkAnnotation2;
  }(PdfLinkAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/actions/action.js
var PdfAction = (
  /** @class */
  function() {
    function PdfAction2() {
      this.action = null;
      this.dictionaryProperties = new DictionaryProperties();
      this.initialize();
    }
    Object.defineProperty(PdfAction2.prototype, "next", {
      // Properties
      /**
       * Gets and Sets the `Next` action to perform.
       * @private
       */
      get: function() {
        return this.action;
      },
      set: function(value) {
        this.action = value;
        this.dictionary.items.setValue(this.dictionaryProperties.next, new PdfReferenceHolder(this.action));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAction2.prototype, "dictionary", {
      /**
       * Gets and Sets the instance of PdfDictionary class for `Dictionary`.
       * @private
       */
      get: function() {
        if (typeof this.pdfDictionary === "undefined") {
          this.pdfDictionary = new PdfDictionary();
        }
        return this.pdfDictionary;
      },
      enumerable: true,
      configurable: true
    });
    PdfAction2.prototype.initialize = function() {
      this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.action));
    };
    Object.defineProperty(PdfAction2.prototype, "element", {
      // IPdfWrapper Members
      /**
       * Gets the `Element` as IPdfPrimitive class.
       * @private
       */
      get: function() {
        return this.dictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAction2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/actions/uri-action.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfUriAction = (
  /** @class */
  function(_super) {
    __extends19(PdfUriAction2, _super);
    function PdfUriAction2(uri) {
      var _this = _super.call(this) || this;
      _this.uniformResourceIdentifier = "";
      return _this;
    }
    Object.defineProperty(PdfUriAction2.prototype, "uri", {
      // Properties
      /**
       * Gets and Sets the value of `Uri`.
       * @private
       */
      get: function() {
        return this.uniformResourceIdentifier;
      },
      set: function(value) {
        this.uniformResourceIdentifier = value;
        this.dictionary.items.setValue(this.dictionaryProperties.uri, new PdfString(this.uniformResourceIdentifier));
      },
      enumerable: true,
      configurable: true
    });
    PdfUriAction2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      this.dictionary.items.setValue(this.dictionaryProperties.s, new PdfName(this.dictionaryProperties.uri));
    };
    return PdfUriAction2;
  }(PdfAction)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/uri-annotation.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfUriAnnotation = (
  /** @class */
  function(_super) {
    __extends20(PdfUriAnnotation2, _super);
    function PdfUriAnnotation2(rectangle, uri) {
      var _this = _super.call(this, rectangle) || this;
      if (typeof uri !== "undefined") {
        _this.uri = uri;
      }
      return _this;
    }
    Object.defineProperty(PdfUriAnnotation2.prototype, "uriAction", {
      /**
       * Get `action` of the annotation.
       * @private
       */
      get: function() {
        if (typeof this.pdfUriAction === "undefined") {
          this.pdfUriAction = new PdfUriAction();
        }
        return this.pdfUriAction;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfUriAnnotation2.prototype, "uri", {
      // Properties
      /**
       * Gets or sets the `Uri` address.
       * @private
       */
      get: function() {
        return this.uriAction.uri;
      },
      set: function(value) {
        if (this.uriAction.uri !== value) {
          this.uriAction.uri = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfUriAnnotation2.prototype, "action", {
      /**
       * Gets or sets the `action`.
       * @private
       */
      get: function() {
        return this.getSetAction();
      },
      set: function(value) {
        this.getSetAction(value);
        this.uriAction.next = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfUriAnnotation2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      this.dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.link));
      var tempPrimitive = this.uriAction.element;
      this.dictionary.items.setValue(this.dictionaryProperties.a, this.uriAction.element);
    };
    return PdfUriAnnotation2;
  }(PdfActionLinkAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/pdf-text-web-link.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfTextWebLink = (
  /** @class */
  function(_super) {
    __extends21(PdfTextWebLink2, _super);
    function PdfTextWebLink2() {
      var _this = _super.call(this) || this;
      _this.uniformResourceLocator = "";
      _this.uriAnnotation = null;
      _this.recalculateBounds = false;
      _this.defaultBorder = new PdfArray();
      for (var i = 0; i < 3; i++) {
        _this.defaultBorder.add(new PdfNumber(0));
      }
      return _this;
    }
    Object.defineProperty(PdfTextWebLink2.prototype, "url", {
      // Properties
      /**
       * Gets or sets the `Uri address`.
       * ```typescript
       * // create a new PDF document.
       * let document : PdfDocument = new PdfDocument();
       * // add a page to the document.
       * let page1 : PdfPage = document.pages.add();
       * // create the font
       * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
       * // create the Text Web Link
       * let textLink : PdfTextWebLink = new PdfTextWebLink();
       * //
       * // set the hyperlink
       * textLink.url = 'http://www.google.com';
       * //
       * // set the link text
       * textLink.text = 'Google';
       * // set the font
       * textLink.font = font;
       * // draw the hyperlink in PDF page
       * textLink.draw(page1, new PointF(10, 40));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.uniformResourceLocator;
      },
      set: function(value) {
        if (value.length === 0) {
          throw new Error("ArgumentException : Url - string can not be empty");
        }
        this.uniformResourceLocator = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTextWebLink2.prototype.draw = function(arg1, arg2) {
      if (arg1 instanceof PdfPage) {
        var layout = new PdfStringLayouter();
        var previousFontStyle = this.font.style;
        if (arg2 instanceof PointF) {
          this.recalculateBounds = true;
          this.font.style = PdfFontStyle.Underline;
          var layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg1.graphics.clientSize.width - arg2.x, 0), true, arg1.graphics.clientSize);
          if (layoutResult.lines.length === 1) {
            var textSize = this.font.measureString(this.value);
            var rect = new RectangleF(arg2, textSize);
            rect = this.calculateBounds(rect, textSize.width, arg1.graphics.clientSize.width, arg2.x);
            this.uriAnnotation = new PdfUriAnnotation(rect, this.url);
            this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
            arg1.annotations.add(this.uriAnnotation);
            var result = this.drawText(arg1, arg2);
            this.font.style = previousFontStyle;
            return result;
          } else {
            var result = this.drawMultipleLineWithPoint(layoutResult, arg1, arg2);
            this.font.style = previousFontStyle;
            return result;
          }
        } else {
          var layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg2.width, 0), false, new SizeF(0, 0));
          this.font.style = PdfFontStyle.Underline;
          if (layoutResult.lines.length === 1) {
            var textSize = this.font.measureString(this.value);
            var rect = new RectangleF(new PointF(arg2.x, arg2.y), textSize);
            rect = this.calculateBounds(rect, textSize.width, arg2.width, arg2.x);
            this.uriAnnotation = new PdfUriAnnotation(rect, this.url);
            this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
            arg1.annotations.add(this.uriAnnotation);
            var returnValue = this.drawText(arg1, arg2);
            this.font.style = previousFontStyle;
            return returnValue;
          } else {
            var returnValue = this.drawMultipleLineWithBounds(layoutResult, arg1, arg2);
            this.font.style = previousFontStyle;
            return returnValue;
          }
        }
      } else {
        var page = new PdfPage();
        page = arg1.page;
        return this.draw(page, arg2);
      }
    };
    PdfTextWebLink2.prototype.drawMultipleLineWithPoint = function(result, page, location) {
      var layoutResult;
      for (var i = 0; i < result.layoutLines.length; i++) {
        var size = this.font.measureString(result.lines[i].text);
        var bounds = new RectangleF(location, size);
        if (i !== 0) {
          bounds.x = 0;
        }
        this.text = result.lines[i].text;
        if (bounds.y + size.height > page.graphics.clientSize.height) {
          if (i !== 0) {
            page = page.graphics.getNextPage();
            bounds = new RectangleF(0, 0, page.graphics.clientSize.width, size.height);
            location.y = 0;
          } else {
            break;
          }
        }
        bounds = this.calculateBounds(bounds, size.width, page.graphics.clientSize.width, bounds.x);
        this.uriAnnotation = new PdfUriAnnotation(bounds, this.url);
        this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
        page.annotations.add(this.uriAnnotation);
        if (i !== 0) {
          layoutResult = this.drawText(page, new PointF(0, bounds.y));
        } else {
          layoutResult = this.drawText(page, bounds.x, bounds.y);
        }
        location.y += size.height;
      }
      return layoutResult;
    };
    PdfTextWebLink2.prototype.drawMultipleLineWithBounds = function(result, page, bounds) {
      var layoutResult;
      for (var i = 0; i < result.layoutLines.length; i++) {
        var size = this.font.measureString(result.lines[i].text);
        var internalBounds = new RectangleF(new PointF(bounds.x, bounds.y), size);
        internalBounds = this.calculateBounds(internalBounds, size.width, bounds.width, bounds.x);
        this.text = result.lines[i].text;
        if (bounds.y + size.height > page.graphics.clientSize.height) {
          if (i !== 0) {
            page = page.graphics.getNextPage();
            bounds = new RectangleF(bounds.x, 0, bounds.width, size.height);
            internalBounds.y = 0;
          } else {
            break;
          }
        }
        this.uriAnnotation = new PdfUriAnnotation(internalBounds, this.url);
        this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
        page.annotations.add(this.uriAnnotation);
        layoutResult = this.drawText(page, bounds);
        bounds.y += size.height;
      }
      return layoutResult;
    };
    PdfTextWebLink2.prototype.calculateBounds = function(currentBounds, lineWidth, maximumWidth, startPosition) {
      var shift = 0;
      if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Center) {
        currentBounds.x = startPosition + (maximumWidth - lineWidth) / 2;
        currentBounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Right) {
        currentBounds.x = startPosition + (maximumWidth - lineWidth);
        currentBounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Justify) {
        currentBounds.x = startPosition;
        currentBounds.width = maximumWidth;
      } else {
        currentBounds.width = startPosition;
        currentBounds.width = lineWidth;
      }
      return currentBounds;
    };
    return PdfTextWebLink2;
  }(PdfTextElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/pdf-numbers-convertor.js
var PdfNumbersConvertor = (
  /** @class */
  function() {
    function PdfNumbersConvertor2() {
    }
    PdfNumbersConvertor2.convert = function(intArabic, numberStyle) {
      var result = "";
      switch (numberStyle) {
        case PdfNumberStyle.None:
          result = "";
          break;
        case PdfNumberStyle.Numeric:
          result = intArabic.toString();
          break;
        case PdfNumberStyle.LowerLatin:
          result = this.arabicToLetter(intArabic).toLowerCase();
          break;
        case PdfNumberStyle.LowerRoman:
          result = this.arabicToRoman(intArabic).toLowerCase();
          break;
        case PdfNumberStyle.UpperLatin:
          result = this.arabicToLetter(intArabic);
          break;
        case PdfNumberStyle.UpperRoman:
          result = this.arabicToRoman(intArabic);
          break;
      }
      return result;
    };
    PdfNumbersConvertor2.arabicToRoman = function(intArabic) {
      var retval = "";
      var retvalM = this.generateNumber(intArabic, 1e3, "M");
      retval += retvalM.returnValue;
      intArabic = retvalM.intArabic;
      var retvalCM = this.generateNumber(intArabic, 900, "CM");
      retval += retvalCM.returnValue;
      intArabic = retvalCM.intArabic;
      var retvalD = this.generateNumber(intArabic, 500, "D");
      retval += retvalD.returnValue;
      intArabic = retvalD.intArabic;
      var retvalCD = this.generateNumber(intArabic, 400, "CD");
      retval += retvalCD.returnValue;
      intArabic = retvalCD.intArabic;
      var retvalC = this.generateNumber(intArabic, 100, "C");
      retval += retvalC.returnValue;
      intArabic = retvalC.intArabic;
      var retvalXC = this.generateNumber(intArabic, 90, "XC");
      retval += retvalXC.returnValue;
      intArabic = retvalXC.intArabic;
      var retvalL = this.generateNumber(intArabic, 50, "L");
      retval += retvalL.returnValue;
      intArabic = retvalL.intArabic;
      var retvalXL = this.generateNumber(intArabic, 40, "XL");
      retval += retvalXL.returnValue;
      intArabic = retvalXL.intArabic;
      var retvalX = this.generateNumber(intArabic, 10, "X");
      retval += retvalX.returnValue;
      intArabic = retvalX.intArabic;
      var retvalIX = this.generateNumber(intArabic, 9, "IX");
      retval += retvalIX.returnValue;
      intArabic = retvalIX.intArabic;
      var retvalV = this.generateNumber(intArabic, 5, "V");
      retval += retvalV.returnValue;
      intArabic = retvalV.intArabic;
      var retvalIV = this.generateNumber(intArabic, 4, "IV");
      retval += retvalIV.returnValue;
      intArabic = retvalIV.intArabic;
      var retvalI = this.generateNumber(intArabic, 1, "I");
      retval += retvalI.returnValue;
      intArabic = retvalI.intArabic;
      return retval.toString();
    };
    PdfNumbersConvertor2.arabicToLetter = function(arabic) {
      var stack = this.convertToLetter(arabic);
      var result = "";
      while (stack.length > 0) {
        var num = stack.pop();
        result = this.appendChar(result, num);
      }
      return result.toString();
    };
    PdfNumbersConvertor2.generateNumber = function(value, magnitude, letter) {
      var numberstring = "";
      while (value >= magnitude) {
        value -= magnitude;
        numberstring += letter;
      }
      return { returnValue: numberstring.toString(), intArabic: value };
    };
    PdfNumbersConvertor2.convertToLetter = function(arabic) {
      if (arabic <= 0) {
        throw Error("ArgumentOutOfRangeException-arabic, Value can not be less 0");
      }
      var stack = [];
      while (arabic > this.letterLimit) {
        var remainder = arabic % this.letterLimit;
        if (remainder === 0) {
          arabic = arabic / this.letterLimit - 1;
          remainder = this.letterLimit;
        } else {
          arabic /= this.letterLimit;
        }
        stack.push(remainder);
      }
      stack.push(arabic);
      return stack;
    };
    PdfNumbersConvertor2.appendChar = function(builder, value) {
      var letter = String.fromCharCode(PdfNumbersConvertor2.acsiiStartIndex + value);
      builder += letter;
      return builder;
    };
    PdfNumbersConvertor2.letterLimit = 26;
    PdfNumbersConvertor2.acsiiStartIndex = 65 - 1;
    return PdfNumbersConvertor2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/pdf-template-value-pair.js
var PdfTemplateValuePair = (
  /** @class */
  function() {
    function PdfTemplateValuePair2(template, value) {
      this.pdfTemplate = null;
      this.content = "";
      if (typeof template === "undefined") {
      } else {
        this.template = template;
        this.value = value;
      }
    }
    Object.defineProperty(PdfTemplateValuePair2.prototype, "template", {
      // Properties
      /**
       * Gets or sets the template.
       * @private
       */
      get: function() {
        return this.pdfTemplate;
      },
      set: function(value) {
        this.pdfTemplate = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplateValuePair2.prototype, "value", {
      /**
       * Gets or sets the value.
       * @private
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.content = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTemplateValuePair2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/multiple-value-field.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfMultipleValueField = (
  /** @class */
  function(_super) {
    __extends22(PdfMultipleValueField2, _super);
    function PdfMultipleValueField2() {
      var _this = _super.call(this) || this;
      _this.list = new TemporaryDictionary();
      return _this;
    }
    PdfMultipleValueField2.prototype.performDraw = function(graphics, location, scalingX, scalingY) {
      _super.prototype.performDrawHelper.call(this, graphics, location, scalingX, scalingY);
      var value = this.getValue(graphics);
      var template = new PdfTemplate(this.getSize());
      this.list.setValue(graphics, new PdfTemplateValuePair(template, value));
      var g = template.graphics;
      var size = this.getSize();
      template.graphics.drawString(value, this.getFont(), this.pen, this.getBrush(), 0, 0, size.width, size.height, this.stringFormat);
      var drawLocation = new PointF(location.x + this.location.x, location.y + this.location.y);
      graphics.drawPdfTemplate(template, drawLocation, new SizeF(template.width * scalingX, template.height * scalingY));
    };
    return PdfMultipleValueField2;
  }(PdfAutomaticField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/pdf-page-number-field.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfPageNumberField = (
  /** @class */
  function(_super) {
    __extends23(PdfPageNumberField2, _super);
    function PdfPageNumberField2(font, arg2) {
      var _this = _super.call(this) || this;
      _this.internalNumberStyle = PdfNumberStyle.Numeric;
      if (typeof arg2 === "undefined") {
        _this.font = font;
      } else if (arg2 instanceof PdfBrush) {
        _this.font = font;
        _this.brush = arg2;
      } else {
        _this.font = font;
        _this.bounds = arg2;
      }
      return _this;
    }
    Object.defineProperty(PdfPageNumberField2.prototype, "numberStyle", {
      // Properties
      /**
       * Gets and sets the number style of the page number field.
       * @private
       */
      get: function() {
        return this.internalNumberStyle;
      },
      set: function(value) {
        this.internalNumberStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageNumberField2.prototype.getValue = function(graphics) {
      var result = null;
      var page = this.getPageFromGraphics(graphics);
      result = this.internalGetValue(page);
      return result;
    };
    PdfPageNumberField2.prototype.internalGetValue = function(page) {
      var document2 = page.document;
      var pageIndex = document2.pages.indexOf(page) + 1;
      return PdfNumbersConvertor.convert(pageIndex, this.numberStyle);
    };
    return PdfPageNumberField2;
  }(PdfMultipleValueField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/composite-field.js
var __extends24 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfCompositeField = (
  /** @class */
  function(_super) {
    __extends24(PdfCompositeField2, _super);
    function PdfCompositeField2(font, brush, text) {
      var list = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        list[_i - 3] = arguments[_i];
      }
      var _this = _super.call(this) || this;
      _this.internalAutomaticFields = null;
      _this.internalText = "";
      _this.font = font;
      _this.brush = brush;
      _this.text = text;
      _this.automaticFields = list;
      return _this;
    }
    Object.defineProperty(PdfCompositeField2.prototype, "text", {
      // Properties
      /**
       * Gets and sets the content of the field.
       * @public
       */
      get: function() {
        return this.internalText;
      },
      set: function(value) {
        this.internalText = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCompositeField2.prototype, "automaticFields", {
      /**
       * Gets and sets the list of the field to drawn.
       * @public
       */
      get: function() {
        return this.internalAutomaticFields;
      },
      set: function(value) {
        this.internalAutomaticFields = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfCompositeField2.prototype.getValue = function(graphics) {
      var values = [];
      var text = this.text.toString();
      if (typeof this.automaticFields !== "undefined" && this.automaticFields != null && this.automaticFields.length > 0) {
        for (var i = 0; i < this.automaticFields.length; i++) {
          var automaticField = this.automaticFields[i];
          text = text.replace("{" + i + "}", automaticField.getValue(graphics));
        }
      }
      return text;
    };
    return PdfCompositeField2;
  }(PdfMultipleValueField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/single-value-field.js
var __extends25 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfSingleValueField = (
  /** @class */
  function(_super) {
    __extends25(PdfSingleValueField2, _super);
    function PdfSingleValueField2() {
      var _this = _super.call(this) || this;
      _this.list = new TemporaryDictionary();
      _this.painterGraphics = [];
      return _this;
    }
    PdfSingleValueField2.prototype.performDraw = function(graphics, location, scalingX, scalingY) {
      _super.prototype.performDrawHelper.call(this, graphics, location, scalingX, scalingY);
      var page = this.getPageFromGraphics(graphics);
      var document2 = page.document;
      var textValue = this.getValue(graphics);
      if (this.list.containsKey(document2)) {
        var pair = this.list.getValue(document2);
        var drawLocation = new PointF(location.x + this.location.x, location.y + this.location.y);
        graphics.drawPdfTemplate(pair.template, drawLocation, new SizeF(pair.template.width * scalingX, pair.template.height * scalingY));
        this.painterGraphics.push(graphics);
      } else {
        var size = this.getSize();
        var template = new PdfTemplate(size);
        this.list.setValue(document2, new PdfTemplateValuePair(template, textValue));
        template.graphics.drawString(textValue, this.getFont(), this.pen, this.getBrush(), 0, 0, size.width, size.height, this.stringFormat);
        var drawLocation = new PointF(location.x + this.location.x, location.y + this.location.y);
        graphics.drawPdfTemplate(template, drawLocation, new SizeF(template.width * scalingX, template.height * scalingY));
        this.painterGraphics.push(graphics);
      }
    };
    return PdfSingleValueField2;
  }(PdfAutomaticField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/page-count-field.js
var __extends26 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfPageCountField = (
  /** @class */
  function(_super) {
    __extends26(PdfPageCountField2, _super);
    function PdfPageCountField2(font, arg2) {
      var _this = _super.call(this) || this;
      _this.internalNumberStyle = PdfNumberStyle.Numeric;
      if (typeof arg2 === "undefined") {
        _this.font = font;
      } else if (arg2 instanceof PdfBrush) {
        _this.font = font;
        _this.brush = arg2;
      } else {
        _this.font = font;
        _this.bounds = arg2;
      }
      return _this;
    }
    Object.defineProperty(PdfPageCountField2.prototype, "numberStyle", {
      // Properties
      /**
       * Gets and sets the number style of the field.
       * @public
       */
      get: function() {
        return this.internalNumberStyle;
      },
      set: function(value) {
        this.internalNumberStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageCountField2.prototype.getValue = function(graphics) {
      var result = null;
      var page = this.getPageFromGraphics(graphics);
      var document2 = page.section.parent.document;
      var count = document2.pages.count;
      result = PdfNumbersConvertor.convert(count, this.numberStyle);
      return result;
    };
    return PdfPageCountField2;
  }(PdfSingleValueField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/tables/light-tables/enum.js
var PdfBorderOverlapStyle;
(function(PdfBorderOverlapStyle2) {
  PdfBorderOverlapStyle2[PdfBorderOverlapStyle2["Overlap"] = 0] = "Overlap";
  PdfBorderOverlapStyle2[PdfBorderOverlapStyle2["Inside"] = 1] = "Inside";
})(PdfBorderOverlapStyle || (PdfBorderOverlapStyle = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/styles/style.js
var __extends27 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfGridStyleBase = (
  /** @class */
  function() {
    function PdfGridStyleBase2() {
    }
    Object.defineProperty(PdfGridStyleBase2.prototype, "backgroundBrush", {
      // Properties
      /**
       * Gets or sets the `background brush`.
       * @private
       */
      get: function() {
        return this.gridBackgroundBrush;
      },
      set: function(value) {
        this.gridBackgroundBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "textBrush", {
      /**
       * Gets or sets the `text brush`.
       * @private
       */
      get: function() {
        return this.gridTextBrush;
      },
      set: function(value) {
        this.gridTextBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "textPen", {
      /**
       * Gets or sets the `text pen`.
       * @private
       */
      get: function() {
        return this.gridTextPen;
      },
      set: function(value) {
        this.gridTextPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "font", {
      /**
       * Gets or sets the `font`.
       * @private
       */
      get: function() {
        return this.gridFont;
      },
      set: function(value) {
        this.gridFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "backgroundImage", {
      /**
       * Gets or sets the `background Image`.
       * @private
       */
      get: function() {
        return this.gridBackgroundImage;
      },
      set: function(value) {
        this.gridBackgroundImage = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridStyleBase2;
  }()
);
var PdfGridStyle = (
  /** @class */
  function(_super) {
    __extends27(PdfGridStyle2, _super);
    function PdfGridStyle2() {
      var _this = _super.call(this) || this;
      _this.gridBorderOverlapStyle = PdfBorderOverlapStyle.Overlap;
      _this.bAllowHorizontalOverflow = false;
      _this.gridHorizontalOverflowType = PdfHorizontalOverflowType.LastPage;
      return _this;
    }
    Object.defineProperty(PdfGridStyle2.prototype, "cellSpacing", {
      //Properties
      /**
       * Gets or sets the `cell spacing` of the 'PdfGrid'.
       * @private
       */
      get: function() {
        if (typeof this.gridCellSpacing === "undefined") {
          this.gridCellSpacing = 0;
        }
        return this.gridCellSpacing;
      },
      set: function(value) {
        this.gridCellSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "horizontalOverflowType", {
      /**
       * Gets or sets the type of the `horizontal overflow` of the 'PdfGrid'.
       * @private
       */
      get: function() {
        return this.gridHorizontalOverflowType;
      },
      set: function(value) {
        this.gridHorizontalOverflowType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "allowHorizontalOverflow", {
      /**
       * Gets or sets a value indicating whether to `allow horizontal overflow`.
       * @private
       */
      get: function() {
        return this.bAllowHorizontalOverflow;
      },
      set: function(value) {
        this.bAllowHorizontalOverflow = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "cellPadding", {
      /**
       * Gets or sets the `cell padding`.
       * @private
       */
      get: function() {
        if (typeof this.gridCellPadding === "undefined") {
          this.gridCellPadding = new PdfPaddings();
        }
        return this.gridCellPadding;
      },
      set: function(value) {
        if (typeof this.gridCellPadding === "undefined") {
          this.gridCellPadding = new PdfPaddings();
          this.gridCellPadding = value;
        } else {
          this.gridCellPadding = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "borderOverlapStyle", {
      /**
       * Gets or sets the `border overlap style` of the 'PdfGrid'.
       * @private
       */
      get: function() {
        return this.gridBorderOverlapStyle;
      },
      set: function(value) {
        this.gridBorderOverlapStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridStyle2;
  }(PdfGridStyleBase)
);
var PdfGridCellStyle = (
  /** @class */
  function(_super) {
    __extends27(PdfGridCellStyle2, _super);
    function PdfGridCellStyle2() {
      var _this = _super.call(this) || this;
      _this.gridCellBorders = PdfBorders.default;
      return _this;
    }
    Object.defineProperty(PdfGridCellStyle2.prototype, "stringFormat", {
      //Properties
      /**
       * Gets the `string format` of the 'PdfGridCell'.
       * @private
       */
      get: function() {
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCellStyle2.prototype, "borders", {
      /**
       * Gets or sets the `border` of the 'PdfGridCell'.
       * @private
       */
      get: function() {
        return this.gridCellBorders;
      },
      set: function(value) {
        this.gridCellBorders = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCellStyle2.prototype, "cellPadding", {
      /**
       * Gets or sets the `cell padding`.
       * @private
       */
      get: function() {
        return this.gridCellPadding;
      },
      set: function(value) {
        if (this.gridCellPadding == null || typeof this.gridCellPadding === "undefined") {
          this.gridCellPadding = new PdfPaddings();
        }
        this.gridCellPadding = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridCellStyle2;
  }(PdfGridStyleBase)
);
var PdfGridRowStyle = (
  /** @class */
  function() {
    function PdfGridRowStyle2() {
    }
    Object.defineProperty(PdfGridRowStyle2.prototype, "backgroundBrush", {
      // Properties
      /**
       * Gets or sets the `background brush`.
       * @private
       */
      get: function() {
        return this.gridRowBackgroundBrush;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setBackgroundBrush = function(value) {
      this.gridRowBackgroundBrush = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.backgroundBrush = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "textBrush", {
      /**
       * Gets or sets the `text brush`.
       * @private
       */
      get: function() {
        return this.gridRowTextBrush;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setTextBrush = function(value) {
      this.gridRowTextBrush = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.textBrush = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "textPen", {
      /**
       * Gets or sets the `text pen`.
       * @private
       */
      get: function() {
        return this.gridRowTextPen;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setTextPen = function(value) {
      this.gridRowTextPen = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.textPen = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "font", {
      /**
       * Gets or sets the `font`.
       * @private
       */
      get: function() {
        return this.gridRowFont;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setFont = function(value) {
      this.gridRowFont = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.font = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "border", {
      /**
       * Gets or sets the `border` of the current row.
       * @private
       */
      get: function() {
        if (typeof this.gridRowBorder === "undefined") {
          this.setBorder(new PdfBorders());
        }
        return this.gridRowBorder;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setBorder = function(value) {
      this.gridRowBorder = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.borders = value;
        }
      }
    };
    PdfGridRowStyle2.prototype.setParent = function(parent) {
      this.parent = parent;
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "backgroundImage", {
      /**
       * Gets or sets the `backgroundImage` of the 'PdfGridCell'.
       * @private
       */
      get: function() {
        return this.gridRowBackgroundImage;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setBackgroundImage = function(value) {
      this.gridRowBackgroundImage = value;
    };
    return PdfGridRowStyle2;
  }()
);
var PdfHorizontalOverflowType;
(function(PdfHorizontalOverflowType2) {
  PdfHorizontalOverflowType2[PdfHorizontalOverflowType2["NextPage"] = 0] = "NextPage";
  PdfHorizontalOverflowType2[PdfHorizontalOverflowType2["LastPage"] = 1] = "LastPage";
})(PdfHorizontalOverflowType || (PdfHorizontalOverflowType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/layout/grid-layouter.js
var __extends28 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfGridLayouter = (
  /** @class */
  function(_super) {
    __extends28(PdfGridLayouter2, _super);
    function PdfGridLayouter2(baseFormat) {
      var _this = _super.call(this, baseFormat) || this;
      _this.gridInitialWidth = 0;
      _this.gridSize = new SizeF(0, 0);
      _this.parentCellIndex = 0;
      _this.tempWidth = 0;
      _this.childheight = 0;
      _this.isChildGrid = false;
      _this.hasRowSpanSpan = false;
      _this.isRearranged = false;
      _this.pageBounds = new RectangleF();
      _this.listOfNavigatePages = [];
      _this.flag = true;
      _this.columnRanges = [];
      _this.currentLocation = new PointF(0, 0);
      _this.breakRow = true;
      _this.slr = null;
      _this.remainderText = null;
      _this.isPaginate = false;
      _this.isOverloadWithPosition = false;
      return _this;
    }
    Object.defineProperty(PdfGridLayouter2.prototype, "Grid", {
      //Properties
      get: function() {
        return this.elements;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridLayouter2.prototype.getFormat = function(format) {
      var f = format;
      return f;
    };
    PdfGridLayouter2.prototype.layoutInternal = function(param) {
      var format = this.getFormat(param.format);
      this.gridLayoutFormat = this.getFormat(param.format);
      this.currentPage = param.page;
      if (this.currentPage !== null) {
        var pageHeight = this.currentPage.getClientSize().height;
        var pageWidth = this.currentPage.getClientSize().width;
        this.currentPageBounds = this.currentPage.getClientSize();
      } else {
        throw Error("Can not set page as null");
      }
      this.currentGraphics = this.currentPage.graphics;
      var index = 0;
      index = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);
      this.listOfNavigatePages.push(index);
      if (format != null && format.break === PdfLayoutBreakType.FitColumnsToPage) {
        this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), new SizeF(this.Grid.columns.width, this.currentGraphics.clientSize.height));
      } else {
        this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), this.currentGraphics.clientSize);
      }
      if (this.Grid.rows.count !== 0) {
        this.currentBounds.width = param.bounds.width > 0 ? param.bounds.width : this.currentBounds.width - this.Grid.rows.getRow(0).cells.getCell(0).style.borders.left.width / 2;
      } else if (this.Grid.headers.count !== 0) {
        this.currentBounds.width = param.bounds.width;
      } else {
        throw Error("Please add row or header into grid");
      }
      this.startLocation = new PointF(param.bounds.x, param.bounds.y);
      if (param.bounds.height > 0 && !this.Grid.isChildGrid) {
        this.currentBounds.height = param.bounds.height;
      }
      if (!this.Grid.isChildGrid) {
        this.hType = this.Grid.style.horizontalOverflowType;
      }
      if (!this.Grid.style.allowHorizontalOverflow) {
        this.columnRanges = [];
        if (typeof this.Grid.isChildGrid !== "undefined" && typeof this.Grid.isChildGrid) {
          this.Grid.measureColumnsWidth(this.currentBounds);
        } else {
          this.Grid.measureColumnsWidth(new RectangleF(this.currentBounds.x, this.currentBounds.y, this.currentBounds.x + this.currentBounds.width, this.currentBounds.height));
        }
        this.columnRanges.push([0, this.Grid.columns.count - 1]);
      } else {
        this.Grid.measureColumnsWidth();
        this.determineColumnDrawRanges();
      }
      if (this.Grid.hasRowSpanSpan) {
        for (var i = 0; i < this.Grid.rows.count; i++) {
          if (this.Grid.rows.getRow(i).height !== -1 && !this.Grid.rows.getRow(i).isRowHeightSet) {
            this.Grid.rows.getRow(i).isRowHeightSet = true;
          }
        }
      }
      var result = this.layoutOnPage(param);
      return result;
    };
    PdfGridLayouter2.prototype.determineColumnDrawRanges = function() {
      var startColumn = 0;
      var endColumn = 0;
      var cellWidths = 0;
      var availableWidth = this.currentGraphics.clientSize.width - this.currentBounds.x;
      for (var i = 0; i < this.Grid.columns.count; i++) {
        cellWidths += this.Grid.columns.getColumn(i).width;
        if (cellWidths >= availableWidth) {
          var subWidths = 0;
          for (var j = startColumn; j <= i; j++) {
            subWidths += this.Grid.columns.getColumn(j).width;
            if (subWidths > availableWidth) {
              break;
            }
            endColumn = j;
          }
          this.columnRanges.push([startColumn, endColumn]);
          startColumn = endColumn + 1;
          endColumn = startColumn;
          cellWidths = endColumn <= i ? this.Grid.columns.getColumn(i).width : 0;
        }
      }
      this.columnRanges.push([startColumn, this.Grid.columns.count - 1]);
    };
    PdfGridLayouter2.prototype.layoutOnPage = function(param) {
      this.pageBounds.x = param.bounds.x;
      this.pageBounds.y = param.bounds.y;
      this.pageBounds.height = param.bounds.height;
      var format = this.getFormat(param.format);
      var endArgs = null;
      var result = null;
      var layoutedPages = new TemporaryDictionary();
      var startPage = param.page;
      var isParentCell = false;
      var cellBounds = [];
      for (var index = 0; index < this.columnRanges.length; index++) {
        var range = this.columnRanges[index];
        this.cellStartIndex = range[0];
        this.cellEndIndex = range[1];
        var returnObject = this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex);
        this.currentBounds = returnObject.currentBounds;
        this.currentRowIndex = returnObject.currentRowIndex;
        var drawHeader = void 0;
        for (var i_1 = 0; i_1 < this.Grid.headers.count; i_1++) {
          var row = this.Grid.headers.getHeader(i_1);
          var headerHeight = this.currentBounds.y;
          this.isHeader = true;
          if (startPage != this.currentPage) {
            for (var k = this.cellStartIndex; k <= this.cellEndIndex; k++) {
              if (row.cells.getCell(k).isCellMergeContinue) {
                row.cells.getCell(k).isCellMergeContinue = false;
                row.cells.getCell(k).value = "";
              }
            }
          }
          var headerResult = this.drawRow(row);
          if (headerHeight === this.currentBounds.y) {
            drawHeader = true;
            if (PdfGridLayouter2.repeatRowIndex === -1) {
              PdfGridLayouter2.repeatRowIndex = i_1;
            }
          } else {
            drawHeader = false;
          }
          if (!headerResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && drawHeader) {
            this.startLocation.x = this.currentBounds.x;
            this.currentPage = this.getNextPageformat(format);
            this.startLocation.y = this.currentBounds.y;
            if (typeof format.paginateBounds !== "undefined" && format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0)
              this.currentBounds.x += this.startLocation.x;
            this.drawRow(row);
          }
          this.isHeader = false;
        }
        var i = 0;
        var length_1 = this.Grid.rows.count;
        var repeatRow = void 0;
        var startingHeight = 0;
        var flag = true;
        cellBounds = [];
        for (var j = 0; j < this.Grid.rows.count; j++) {
          var row = this.Grid.rows.getRow(j);
          i++;
          this.currentRowIndex = i - 1;
          var originalHeight = this.currentBounds.y;
          startPage = this.currentPage;
          PdfGridLayouter2.repeatRowIndex = -1;
          if (flag && row.grid.isChildGrid) {
            startingHeight = originalHeight;
            flag = false;
          }
          var rowResult = null;
          if (this.Grid.splitChildRowIndex == -1) {
            rowResult = this.drawRow(row);
            row.isrowFinish = true;
          } else {
            if (row.grid.ParentCell.row.grid.isGridSplit && this.Grid.splitChildRowIndex <= row.rowIndex) {
              rowResult = this.drawRow(row);
              row.isrowFinish = true;
            } else if (row.isrowFinish) {
              continue;
            } else {
              break;
            }
          }
          cellBounds.push(rowResult.bounds.width);
          if (originalHeight === this.currentBounds.y) {
            repeatRow = true;
            PdfGridLayouter2.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);
          } else {
            repeatRow = false;
            PdfGridLayouter2.repeatRowIndex = -1;
          }
          while (!rowResult.isFinish && startPage != null) {
            var tempResult = this.getLayoutResult();
            endArgs = this.raisePageLayouted(tempResult);
            if (endArgs.cancel || repeatRow)
              break;
            else if (this.Grid.allowRowBreakAcrossPages) {
              this.currentPage = this.getNextPageformat(format);
              originalHeight = this.currentBounds.y;
              var location_1 = new PointF(PdfBorders.default.right.width / 2, PdfBorders.default.top.width / 2);
              if (format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0 && (this.startLocation.x === location_1.x && this.startLocation.y === location_1.y)) {
                this.currentBounds.x += this.startLocation.x;
                this.currentBounds.y += this.startLocation.y;
              }
              if (this.isPaginate) {
                this.startLocation.y = this.currentBounds.y;
                this.isPaginate = false;
              }
              if (this.Grid.isChildGrid && row.grid.ParentCell != null) {
                if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {
                  if (row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top < this.currentBounds.height) {
                    this.currentBounds.y = this.Grid.ParentCell.row.grid.style.cellPadding.top;
                  }
                }
              }
              if (row.grid.ParentCell != null) {
                row.grid.ParentCell.row.isRowBreaksNextPage = true;
                row.grid.ParentCell.row.rowBreakHeightValue = row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top + this.Grid.ParentCell.row.grid.style.cellPadding.bottom;
                for (var i_2 = row.rowIndex + 1; i_2 < row.grid.rows.count; i_2++) {
                  row.grid.ParentCell.row.rowBreakHeightValue += row.grid.rows.getRow(i_2).height;
                }
              }
              if (row.grid.isChildGrid) {
                row.isrowFinish = false;
                row.grid.splitChildRowIndex = row.rowIndex;
                row.grid.ParentCell.row.grid.splitChildRowIndex = row.grid.ParentCell.row.rowIndex;
                if (row.grid.ParentCell.row.grid.isGridSplit) {
                  row.grid.ParentCell.row.noOfPageCount += 1;
                  row.grid.ParentCell.row.grid.isGridSplit = false;
                }
                break;
              }
              if (row.noOfPageCount < 1) {
                if (row.grid.splitChildRowIndex != -1) {
                  row.grid.isGridSplit = true;
                }
                if (row.style.border != null && (row.style.border.left != null && row.style.border.left.width !== 1 || row.style.border.top != null && row.style.border.top.width !== 1)) {
                  var x = row.style.border.left.width / 2;
                  var y = row.style.border.top.width / 2;
                  if (this.currentBounds.x === PdfBorders.default.right.width / 2 && this.currentBounds.y === PdfBorders.default.right.width / 2) {
                    var newBound = new RectangleF(x, y, this.currentBounds.width, this.currentBounds.height);
                    this.currentBounds = newBound;
                  }
                }
                if (this.Grid.repeatHeader) {
                  for (var j_1 = 0; j_1 < this.Grid.headers.count; j_1++) {
                    var headerRepeat = this.Grid.headers.getHeader(j_1);
                    this.drawRow(headerRepeat);
                  }
                }
                rowResult = this.drawRow(row);
                if (row.noOfPageCount >= 1) {
                  var temp = row.rowBreakHeightValue;
                  for (var j_2 = 0; j_2 < row.noOfPageCount; j_2++) {
                    var tempResult1 = this.getLayoutResult();
                    endArgs = this.raisePageLayouted(tempResult1);
                    this.currentPage = this.getNextPageformat(format);
                    originalHeight = this.currentBounds.y;
                    if (row.grid.splitChildRowIndex != -1) {
                      row.grid.isGridSplit = true;
                    }
                    this.currentBounds.y = 0.5;
                    if (this.Grid.repeatHeader) {
                      for (var i_3 = 0; i_3 < this.Grid.headers.count; i_3++) {
                        var header = this.Grid.headers.getHeader(i_3);
                        this.drawRow(header);
                      }
                    }
                    this.drawRow(row);
                  }
                }
                row.grid.splitChildRowIndex = -1;
                row.grid.isGridSplit = false;
                rowResult.isFinish = this.checkIsFisished(row);
                for (var i_4 = 0; i_4 < row.cells.count; i_4++) {
                  if (row.cells.getCell(i_4).value instanceof PdfGrid) {
                    row.cells.getCell(i_4).value.splitChildRowIndex = -1;
                  }
                }
              }
            }
          }
          if (!rowResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && repeatRow) {
            this.startLocation.x = this.currentBounds.x;
            var isAddNextPage = false;
            this.currentPage = this.getNextPageformat(format);
            if (this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex).returnValue) {
              break;
            }
            if (param.format !== null && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.height > 0 && !this.Grid.isChildGrid) {
              this.currentBounds.height = param.bounds.height;
            }
            if (typeof param.format !== "undefined" && param.format != null && typeof param.format.usePaginateBounds !== "undefined" && !param.format.usePaginateBounds && !(param.format.paginateBounds.x === 0 && param.format.paginateBounds.y === 0 && param.format.paginateBounds.width === 0 && param.format.paginateBounds.height === 0) && param.format.paginateBounds.y === 0) {
              this.currentBounds.y = PdfBorders.default.top.width / 2;
            } else {
              this.currentBounds.y = format == null ? 0 : format.paginateBounds.y;
              if (format != null && (format.paginateBounds.x !== 0 || format.paginateBounds.y !== 0 || format.paginateBounds.height !== 0 || format.paginateBounds.width !== 0)) {
                this.currentBounds.x = format.paginateBounds.x;
                this.currentBounds.width = format.paginateBounds.width;
                this.currentBounds.height = format.paginateBounds.height;
              }
            }
            if (typeof param.format !== "undefined" && param.format !== null && typeof param.format.usePaginateBounds !== "undefined" && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.y > 0 && !this.Grid.isChildGrid) {
              this.currentBounds.y = param.bounds.y;
            }
            this.startLocation.y = this.currentBounds.y;
            if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {
              this.currentBounds.x += this.startLocation.x;
            }
            if (this.currentBounds.x === PdfBorders.default.left.width / 2) {
              this.currentBounds.y += this.startLocation.x;
            }
            if (this.Grid.repeatHeader) {
              for (var i_5 = 0; i_5 < this.Grid.headers.count; i_5++) {
                var header = this.Grid.headers.getHeader(i_5);
                this.drawRow(header);
              }
            }
            this.drawRow(row);
            if (this.currentPage !== null && !layoutedPages.containsKey(this.currentPage)) {
              layoutedPages.add(this.currentPage, range);
            }
          }
          if (row.NestedGridLayoutResult != null) {
            this.currentPage = row.NestedGridLayoutResult.page;
            this.currentGraphics = this.currentPage.graphics;
            this.startLocation = new PointF(row.NestedGridLayoutResult.bounds.x, row.NestedGridLayoutResult.bounds.y);
            var recalHeight = this.ReCalculateHeight(row, row.NestedGridLayoutResult.bounds.height);
            this.currentBounds.y = recalHeight;
            if (startPage != this.currentPage) {
              var secion = this.currentPage.section;
              var startIndex = secion.indexOf(startPage) + 1;
              var endIndex = secion.indexOf(this.currentPage);
              for (var page = startIndex; page < endIndex + 1; page++) {
                var pageGraphics = this.currentPage.graphics;
                var location_2 = new PointF(format.paginateBounds.x, format.paginateBounds.y);
                var height = page == endIndex ? row.NestedGridLayoutResult.bounds.height - param.bounds.y : this.currentBounds.height - location_2.y;
                if (height <= pageGraphics.clientSize.height)
                  height += param.bounds.y;
                location_2.y = format == null ? 0.5 : format.paginateBounds.y;
                for (var c = 0; c < row.cells.count; c++) {
                  var cell = row.cells.getCell(c);
                  var cellWidth = 0;
                  var totalwidth = 0;
                  if (cell.value instanceof PdfGrid) {
                    for (var i_6 = 0; i_6 < cell.value.columns.count; i_6++) {
                      totalwidth += cell.value.columns.getColumn(i_6).columnWidth;
                    }
                  } else {
                    totalwidth = cell.width;
                  }
                  cellWidth = Math.max(totalwidth, row.grid.columns.getColumn(c).width);
                  cell.drawCellBorders(pageGraphics, new RectangleF(location_2, new SizeF(cellWidth, height)));
                  location_2.x += cellWidth;
                  c += cell.columnSpan - 1;
                }
              }
              startPage = this.currentPage;
            }
          }
        }
        var isPdfGrid = false;
        var maximumCellBoundsWidth = 0;
        if (cellBounds.length > 0) {
          maximumCellBoundsWidth = cellBounds[0];
        }
        var largeNavigatePage = [[1, 2]];
        for (var c = 0; c < this.Grid.rows.count; c++) {
          if (this.cellEndIndex != -1 && this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value instanceof PdfGrid) {
            var grid = this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value;
            this.rowLayoutBoundsWidth = grid.rowLayoutBoundsWidth;
            isPdfGrid = true;
          }
        }
        if (!isPdfGrid && cellBounds.length > 0) {
          for (var c = 0; c < i - 1; c++) {
            if (maximumCellBoundsWidth < cellBounds[c]) {
              maximumCellBoundsWidth = cellBounds[c];
            }
          }
          this.rowLayoutBoundsWidth = maximumCellBoundsWidth;
        } else {
          this.rowLayoutBoundsWidth = largeNavigatePage[0][1];
        }
        if (this.columnRanges.indexOf(range) < this.columnRanges.length - 1 && startPage != null && format.layout != PdfLayoutType.OnePage) {
          isParentCell = this.Grid.isChildGrid;
          if (largeNavigatePage[0][0] != 0) {
            var section = this.currentPage.section;
            var pageIndex = section.indexOf(this.currentPage);
            this.currentGraphics = this.currentPage.graphics;
            this.currentBounds = new RectangleF(new PointF(0, 0), this.currentPage.getClientSize());
            var pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);
          } else {
            this.currentPage = this.getNextPageformat(format);
          }
        }
        if (this.columnRanges.length - 1 !== index && this.columnRanges.length > 1 && format.layout !== PdfLayoutType.OnePage) {
          this.currentPage = this.getNextPageformat(format);
          if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {
            this.currentBounds.x += this.startLocation.x;
            this.currentBounds.y += this.startLocation.y;
          }
        }
      }
      result = this.getLayoutResult();
      if (this.Grid.style.allowHorizontalOverflow && this.Grid.style.horizontalOverflowType == PdfHorizontalOverflowType.NextPage) {
        this.reArrangePages(layoutedPages);
      }
      this.raisePageLayouted(result);
      return result;
    };
    PdfGridLayouter2.prototype.checkIsFisished = function(row) {
      var result = true;
      for (var i = 0; i < row.cells.count; i++) {
        if (!row.cells.getCell(i).FinishedDrawingCell) {
          result = false;
        }
      }
      return result;
    };
    PdfGridLayouter2.prototype.getNextPageformat = function(format) {
      var section = this.currentPage.section;
      var nextPage = null;
      var index = section.indexOf(this.currentPage);
      this.flag = false;
      if (index === section.count - 1) {
        nextPage = section.add();
      } else {
        nextPage = section.getPages()[index + 1];
      }
      this.currentGraphics = nextPage.graphics;
      var pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);
      if (!(this.listOfNavigatePages.indexOf(pageindex) !== -1)) {
        this.listOfNavigatePages.push(pageindex);
      }
      this.currentBounds = new RectangleF(new PointF(0, 0), nextPage.getClientSize());
      if (typeof format !== "undefined" && format != null && format.usePaginateBounds && typeof format.paginateBounds !== "undefined" && format.paginateBounds != null && format.paginateBounds.x !== format.paginateBounds.y && format.paginateBounds.y !== format.paginateBounds.height && format.paginateBounds.height !== format.paginateBounds.width && format.paginateBounds.width !== 0) {
        this.currentBounds.x = format.paginateBounds.x;
        this.currentBounds.y = format.paginateBounds.y;
        this.currentBounds.height = format.paginateBounds.height;
      }
      return nextPage;
    };
    PdfGridLayouter2.prototype.CheckIfDefaultFormat = function(format) {
      var defaultFormat = new PdfStringFormat();
      return format.alignment === defaultFormat.alignment && format.characterSpacing === defaultFormat.characterSpacing && format.clipPath === defaultFormat.clipPath && format.firstLineIndent === defaultFormat.firstLineIndent && format.horizontalScalingFactor === defaultFormat.horizontalScalingFactor && format.lineAlignment === defaultFormat.lineAlignment && format.lineLimit === defaultFormat.lineLimit && format.lineSpacing === defaultFormat.lineSpacing && format.measureTrailingSpaces === defaultFormat.measureTrailingSpaces && format.noClip === defaultFormat.noClip && format.paragraphIndent === defaultFormat.paragraphIndent && format.rightToLeft === defaultFormat.rightToLeft && format.subSuperScript === defaultFormat.subSuperScript && format.wordSpacing === defaultFormat.wordSpacing && format.wordWrap === defaultFormat.wordWrap;
    };
    PdfGridLayouter2.prototype.RaiseBeforeCellDraw = function(graphics, rowIndex, cellIndex, bounds, value, style) {
      var args = null;
      if (this.Grid.raiseBeginCellDraw) {
        args = new PdfGridBeginCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, style);
        this.Grid.onBeginCellDraw(args);
        style = args.style;
      }
      return style;
    };
    PdfGridLayouter2.prototype.raiseAfterCellDraw = function(graphics, rowIndex, cellIndex, bounds, value, cellstyle) {
      var args = null;
      if (this.Grid.raiseEndCellDraw) {
        args = new PdfGridEndCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, cellstyle);
        this.Grid.onEndCellDraw(args);
      }
    };
    PdfGridLayouter2.prototype.reArrangePages = function(layoutedPages) {
      var document2 = this.currentPage.document;
      var pages = [];
      var keys = layoutedPages.keys();
      var values = layoutedPages.values();
      for (var i = 0; i < keys.length; i++) {
        var page = keys[i];
        page.section = null;
        pages.push(page);
        document2.pages.remove(page);
      }
      for (var i = 0; i < layoutedPages.size(); i++) {
        var count = 0;
        for (var j = i, count_1 = layoutedPages.size() / this.columnRanges.length; j < layoutedPages.size(); j += count_1) {
          var page = pages[j];
          if (typeof page !== "undefined" && document2.pages.indexOf(page) === -1) {
            document2.pages.add(page);
          }
        }
      }
    };
    PdfGridLayouter2.prototype.getLayoutResult = function() {
      if (this.Grid.isChildGrid && this.Grid.allowRowBreakAcrossPages) {
        for (var i = 0; i < this.Grid.rows.count; i++) {
          var row = this.Grid.rows.getRow(i);
          if (row.rowBreakHeight > 0 && row.repeatFlag) {
            this.startLocation.y = this.currentPage.origin.y;
          }
        }
      }
      var bounds;
      if (!this.isChanged) {
        bounds = new RectangleF(this.startLocation, new SizeF(this.currentBounds.width, this.currentBounds.y - this.startLocation.y));
      }
      return new PdfGridLayoutResult(this.currentPage, bounds);
    };
    PdfGridLayouter2.prototype.ReCalculateHeight = function(row, height) {
      var newHeight = 0;
      for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {
        if (!(row.cells.getCell(i).remainingString === null || row.cells.getCell(i).remainingString === "" || typeof row.cells.getCell(i).remainingString === "undefined")) {
          newHeight = Math.max(newHeight, row.cells.getCell(i).measureHeight());
        }
      }
      return Math.max(height, newHeight);
    };
    PdfGridLayouter2.prototype.raiseBeforePageLayout = function(currentPage, currentBounds, currentRow) {
      var cancel = false;
      if (this.Grid.raiseBeginPageLayout) {
        var args = new PdfGridBeginPageLayoutEventArgs(currentBounds, currentPage, currentRow);
        this.Grid.onBeginPageLayout(args);
        cancel = typeof args.cancel === "undefined" ? false : args.cancel;
        currentBounds = args.bounds;
        currentRow = args.startRowIndex;
      }
      return { returnValue: cancel, currentBounds, currentRowIndex: currentRow };
    };
    PdfGridLayouter2.prototype.raisePageLayouted = function(result) {
      var args = new PdfGridEndPageLayoutEventArgs(result);
      if (this.Grid.raiseEndPageLayout) {
        this.Grid.onEndPageLayout(args);
      }
      return args;
    };
    PdfGridLayouter2.prototype.drawRow = function(row, result, height) {
      if (typeof result === "undefined") {
        var result_1 = new RowLayoutResult();
        var rowHeightWithSpan = 0;
        var location_3 = new PointF(0, 0);
        var size = new SizeF(0, 0);
        var isHeader = false;
        if (row.rowSpanExists) {
          var maxSpan = 0;
          var currRowIndex = this.Grid.rows.rowCollection.indexOf(row);
          if (currRowIndex === -1) {
            currRowIndex = this.Grid.headers.indexOf(row);
            if (currRowIndex !== -1) {
              isHeader = true;
            }
          }
          for (var i = 0; i < row.cells.count; i++) {
            var cell = row.cells.getCell(i);
            maxSpan = Math.max(maxSpan, cell.rowSpan);
          }
          for (var i = currRowIndex; i < currRowIndex + maxSpan; i++) {
            rowHeightWithSpan += isHeader ? this.Grid.headers.getHeader(i).height : this.Grid.rows.getRow(i).height;
          }
        }
        var calculatedHeight = row.rowBreakHeight > 0 ? row.rowBreakHeight : row.height;
        if (typeof this.Grid.isChildGrid !== "undefined" && this.Grid.isChildGrid && typeof this.Grid.ParentCell !== "undefined" && this.Grid.ParentCell != null) {
          if (this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + rowHeightWithSpan > this.currentPageBounds.height) {
            if (typeof this.Grid.ParentCell.row.grid.LayoutFormat !== "undefined" && this.Grid.ParentCell.row.grid.LayoutFormat.break === PdfLayoutBreakType.FitPage) {
              PdfGridLayouter2.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);
              this.Grid.splitChildRowIndex = this.Grid.rows.rowCollection.indexOf(row);
            }
            if (PdfGridLayouter2.repeatRowIndex > -1 && PdfGridLayouter2.repeatRowIndex === row.rowIndex) {
              if (this.Grid.allowRowBreakAcrossPages) {
                result_1.isFinish = true;
                result_1.bounds = this.currentBounds;
                this.drawRowWithBreak(result_1, row, calculatedHeight);
                row.repeatFlag = true;
                row.repeatRowNumber = PdfGridLayouter2.repeatRowIndex;
              }
            }
          } else {
            result_1.isFinish = true;
            if (row.grid.ParentCell.row.rowBreakHeightValue > 0) {
              row.repeatFlag = true;
            } else {
              row.repeatFlag = false;
              calculatedHeight = row.height;
            }
            if (this.Grid.isChildGrid && row.rowBreakHeight > 0) {
              if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {
                calculatedHeight += this.Grid.ParentCell.row.grid.style.cellPadding.bottom;
              }
            }
            this.drawRow(row, result_1, calculatedHeight);
          }
        } else {
          if (calculatedHeight > this.currentPageBounds.height) {
            if (this.Grid.allowRowBreakAcrossPages) {
              result_1.isFinish = true;
              this.drawRowWithBreak(result_1, row, calculatedHeight);
              row.isrowFinish = true;
              row.repeatFlag = true;
              if (row.grid.splitChildRowIndex !== -1) {
                result_1.isFinish = false;
              }
            }
          } else if (this.currentBounds.y + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + calculatedHeight > this.currentBounds.height + this.startLocation.y || this.currentBounds.y + rowHeightWithSpan > this.currentPageBounds.height) {
            var isFit = false;
            if (this.Grid.allowRowBreakAcrossPages && !this.Grid.repeatHeader && !row.isRowHeightSet && !row.rowMergeComplete) {
              if (this.Grid.LayoutFormat !== null && this.Grid.LayoutFormat.paginateBounds.height > 0) {
                isFit = this.isFitToCell(this.currentBounds.height + this.startLocation.y - this.currentBounds.y, this.Grid, row);
              } else
                isFit = this.isFitToCell(this.currentPageBounds.height - this.currentBounds.y, this.Grid, row);
              if (isFit) {
                this.isPaginate = true;
              }
            } else if (this.Grid.allowRowBreakAcrossPages && this.Grid.LayoutFormat != null && this.Grid.LayoutFormat.layout == PdfLayoutType.Paginate && this.Grid.LayoutFormat.break != PdfLayoutBreakType.FitElement && row.isRowHeightSet && this.currentBounds.y + height > this.currentPageBounds.height) {
              isFit = this.isFitToCell(this.currentPageBounds.height - this.currentBounds.y, this.Grid, row);
              if (!isFit)
                isFit = !(this.slr !== null && this.slr.actualSize.height == 0 && this.slr.remainder != null && this.slr.remainder.length > 0 && this.remainderText == this.slr.remainder);
              if (isFit && this.slr != null && this.slr.lineCount > 1) {
                isFit = false;
              }
              this.remainderText = null;
            }
            if (PdfGridLayouter2.repeatRowIndex > -1 && PdfGridLayouter2.repeatRowIndex === row.rowIndex || isFit) {
              if (this.Grid.allowRowBreakAcrossPages) {
                result_1.isFinish = true;
                this.drawRowWithBreak(result_1, row, calculatedHeight);
                row.repeatFlag = true;
                row.repeatRowNumber = PdfGridLayouter2.repeatRowIndex;
                if (row.grid.splitChildRowIndex !== -1) {
                  result_1.isFinish = false;
                }
              } else {
                result_1.isFinish = false;
                this.drawRow(row, result_1, calculatedHeight);
              }
            } else {
              result_1.isFinish = false;
            }
          } else {
            result_1.isFinish = true;
            this.drawRow(row, result_1, calculatedHeight);
            row.repeatFlag = false;
          }
        }
        return result_1;
      } else {
        var skipcell = false;
        var location_4 = new PointF(this.currentBounds.x, this.currentBounds.y);
        result.bounds = new RectangleF(location_4, new SizeF(0, 0));
        height = this.ReCalculateHeight(row, height);
        for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {
          var cancelSpans = i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1;
          if (!cancelSpans) {
            for (var j = 1; j < row.cells.getCell(i).columnSpan; j++) {
              row.cells.getCell(i + j).isCellMergeContinue = true;
            }
          }
          var size = new SizeF(this.Grid.columns.getColumn(i).width, height);
          if (!this.CheckIfDefaultFormat(this.Grid.columns.getColumn(i).format) && this.CheckIfDefaultFormat(row.cells.getCell(i).stringFormat)) {
            row.cells.getCell(i).stringFormat = this.Grid.columns.getColumn(i).format;
          }
          var cellstyle = row.cells.getCell(i).style;
          var tempValue = typeof row.cells.getCell(i).value === "string" && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : "";
          row.cells.getCell(i).style = this.RaiseBeforeCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location_4, size), tempValue, cellstyle);
          if (!skipcell) {
            if (row.cells.getCell(i).value instanceof PdfGrid) {
              var grid = row.cells.getCell(i).value;
              grid.parentCellIndex = i;
            }
            var stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location_4, size), cancelSpans);
            if (row.grid.style.allowHorizontalOverflow && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1) && this.cellEndIndex < row.cells.count - 1) {
              row.rowOverflowIndex = this.cellEndIndex;
            }
            if (row.grid.style.allowHorizontalOverflow && (row.rowOverflowIndex > 0 && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1)) && row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1 > 0) {
              row.cells.getCell(row.rowOverflowIndex + 1).value = stringResult !== null ? stringResult.remainder !== void 0 ? stringResult.remainder : "" : "";
              row.cells.getCell(row.rowOverflowIndex + 1).stringFormat = row.cells.getCell(i).stringFormat;
              row.cells.getCell(row.rowOverflowIndex + 1).style = row.cells.getCell(i).style;
              row.cells.getCell(row.rowOverflowIndex + 1).columnSpan = row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1;
            }
          }
          tempValue = typeof row.cells.getCell(i).value === "string" && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : "";
          if (!cancelSpans) {
            this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location_4, size), tempValue, row.cells.getCell(i).style);
          }
          if (row.cells.getCell(i).value instanceof PdfGrid) {
            var grid = row.cells.getCell(i).value;
            if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {
              location_4.x = grid.rowLayoutBoundsWidth;
              location_4.x += grid.style.cellSpacing;
            } else {
              location_4.x += this.Grid.columns.getColumn(i).width;
            }
          } else {
            location_4.x += this.Grid.columns.getColumn(i).width;
          }
        }
        if (!row.rowMergeComplete || row.isRowHeightSet) {
          this.currentBounds.y += height;
        }
        result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location_4.x, location_4.y));
      }
    };
    PdfGridLayouter2.prototype.isFitToCell = function(currentHeight, grid, gridRow) {
      var isFit = false;
      var layouter = new PdfStringLayouter();
      for (var i = 0; i < gridRow.cells.count; i++) {
        var cell = gridRow.cells.getCell(i);
        if (typeof cell.value !== "undefined" && cell.value !== null && typeof cell.value === "string") {
          var font = null;
          if (typeof cell.style.font !== "undefined" && cell.style.font != null) {
            font = cell.style.font;
          } else if (typeof cell.row.style.font !== "undefined" && cell.row.style.font != null) {
            font = cell.row.style.font;
          } else if (typeof cell.row.grid.style.font !== "undefined" && cell.row.grid.style.font != null) {
            font = cell.row.grid.style.font;
          } else {
            font = PdfDocument.defaultFont;
          }
          this.remainderText = gridRow.cells.getCell(i).value;
          var width = gridRow.cells.getCell(i).width;
          if (grid.columns.getColumn(i).isCustomWidth && gridRow.cells.getCell(i).width > grid.columns.getColumn(i).width) {
            width = grid.columns.getColumn(i).width;
          }
          this.slr = layouter.layout(gridRow.cells.getCell(i).value, font, gridRow.cells.getCell(i).stringFormat, new SizeF(width, currentHeight), false, this.currentPageBounds);
          var height = this.slr.actualSize.height;
          if (height == 0) {
            isFit = false;
            break;
          }
          if (gridRow.cells.getCell(i).style != null && gridRow.cells.getCell(i).style.borders != null && gridRow.cells.getCell(i).style.borders.top != null && gridRow.cells.getCell(i).style.borders.bottom != null)
            height += (gridRow.cells.getCell(i).style.borders.top.width + gridRow.cells.getCell(i).style.borders.bottom.width) * 2;
          if (this.slr.lineCount > 1 && gridRow.cells.getCell(i).stringFormat != null && gridRow.cells.getCell(i).stringFormat.lineSpacing != 0)
            height += (this.slr.lineCount - 1) * gridRow.cells.getCell(i).style.stringFormat.lineSpacing;
          if (gridRow.cells.getCell(i).style.cellPadding == null) {
            height += grid.style.cellPadding.top + grid.style.cellPadding.bottom;
          } else {
            height += grid.style.cellPadding.top + grid.style.cellPadding.bottom;
          }
          height += grid.style.cellSpacing;
          if (currentHeight > height || typeof this.slr.remainder !== "undefined" && this.slr.remainder !== null) {
            isFit = true;
            break;
          }
        }
      }
      return isFit;
    };
    PdfGridLayouter2.prototype.drawRowWithBreak = function(result, row, calculateHeight) {
      var location = new PointF(this.currentBounds.x, this.currentBounds.y);
      if (row.grid.isChildGrid && row.grid.allowRowBreakAcrossPages && this.startLocation.x !== this.currentBounds.x) {
        location.x = this.startLocation.x;
      }
      result.bounds = new RectangleF(location, new SizeF(0, 0));
      this.gridHeight = row.rowBreakHeight > 0 ? this.currentPageBounds.height : 0;
      if (row.grid.style.cellPadding.top + this.currentBounds.y + row.grid.style.cellPadding.bottom < this.currentPageBounds.height) {
        row.rowBreakHeight = this.currentBounds.y + calculateHeight - this.currentPageBounds.height;
      }
      for (var i = 0; i < row.cells.count; i++) {
        var cell = row.cells.getCell(i);
        var cellHeight = cell.measureHeight();
        if (cellHeight === calculateHeight && cell.value instanceof PdfGrid) {
          row.rowBreakHeight = 0;
        }
      }
      for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {
        var cancelSpans = row.cells.getCell(i).columnSpan + i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1;
        var size = new SizeF(this.Grid.columns.getColumn(i).width, this.gridHeight > 0 ? this.gridHeight : this.currentPageBounds.height);
        var cellstyle1 = row.cells.getCell(i).style;
        row.cells.getCell(i).style = cellstyle1;
        var skipcell = false;
        var stringResult = null;
        if (!skipcell) {
          stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location, size), cancelSpans);
        }
        if (row.rowBreakHeight > 0) {
          if (stringResult != null && typeof stringResult.remainder !== "undefined") {
            row.cells.getCell(i).FinishedDrawingCell = false;
            row.cells.getCell(i).remainingString = stringResult.remainder == null ? " " : stringResult.remainder;
            row.rowBreakHeight = calculateHeight - stringResult.actualSize.height;
          }
        }
        result.isFinish = !result.isFinish ? result.isFinish : row.cells.getCell(i).FinishedDrawingCell;
        if (row.cells.getCell(i).value instanceof PdfGrid) {
          var grid = row.cells.getCell(i).value;
          this.rowBreakPageHeightCellIndex = i;
          if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {
            location.x = this.rowLayoutBoundsWidth;
            location.x += grid.style.cellSpacing;
          } else {
            location.x += this.Grid.columns.getColumn(i).width;
          }
        } else {
          location.x += this.Grid.columns.getColumn(i).width;
        }
      }
      this.currentBounds.y += this.gridHeight > 0 ? this.gridHeight : calculateHeight;
      result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location.x, location.y));
    };
    PdfGridLayouter2.repeatRowIndex = -1;
    return PdfGridLayouter2;
  }(ElementLayouter)
);
var PdfGridLayoutResult = (
  /** @class */
  function(_super) {
    __extends28(PdfGridLayoutResult2, _super);
    function PdfGridLayoutResult2(page, bounds) {
      return _super.call(this, page, bounds) || this;
    }
    return PdfGridLayoutResult2;
  }(PdfLayoutResult)
);
var PdfGridLayoutFormat = (
  /** @class */
  function(_super) {
    __extends28(PdfGridLayoutFormat2, _super);
    function PdfGridLayoutFormat2(baseFormat) {
      return _super.call(this, baseFormat) || this;
    }
    return PdfGridLayoutFormat2;
  }(PdfLayoutFormat)
);
var GridCellEventArgs = (
  /** @class */
  function() {
    function GridCellEventArgs2(graphics, rowIndex, cellIndex, bounds, value) {
      this.gridRowIndex = rowIndex;
      this.gridCellIndex = cellIndex;
      this.internalValue = value;
      this.gridBounds = bounds;
      this.pdfGraphics = graphics;
    }
    Object.defineProperty(GridCellEventArgs2.prototype, "rowIndex", {
      // Properties
      /**
       * Gets the value of current `row index`.
       * @private
       */
      get: function() {
        return this.gridRowIndex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "cellIndex", {
      /**
       * Gets the value of current `cell index`.
       * @private
       */
      get: function() {
        return this.gridCellIndex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "value", {
      /**
       * Gets the actual `value` of current cell.
       * @private
       */
      get: function() {
        return this.internalValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "bounds", {
      /**
       * Gets the `bounds` of current cell.
       * @private
       */
      get: function() {
        return this.gridBounds;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "graphics", {
      /**
       * Gets the instance of `current graphics`.
       * @private
       */
      get: function() {
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    return GridCellEventArgs2;
  }()
);
var PdfGridBeginCellDrawEventArgs = (
  /** @class */
  function(_super) {
    __extends28(PdfGridBeginCellDrawEventArgs2, _super);
    function PdfGridBeginCellDrawEventArgs2(graphics, rowIndex, cellIndex, bounds, value, style) {
      var _this = _super.call(this, graphics, rowIndex, cellIndex, bounds, value) || this;
      _this.style = style;
      return _this;
    }
    Object.defineProperty(PdfGridBeginCellDrawEventArgs2.prototype, "skip", {
      // Properties
      /**
       * Gets or sets a value indicating whether the value of this cell should be `skipped`.
       * @private
       */
      get: function() {
        return this.bSkip;
      },
      set: function(value) {
        this.bSkip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridBeginCellDrawEventArgs2.prototype, "style", {
      /**
       * Gets or sets a `style` value of the cell.
       * @private
       */
      get: function() {
        return this.cellStyle;
      },
      set: function(value) {
        this.cellStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridBeginCellDrawEventArgs2;
  }(GridCellEventArgs)
);
var PdfGridEndCellDrawEventArgs = (
  /** @class */
  function(_super) {
    __extends28(PdfGridEndCellDrawEventArgs2, _super);
    function PdfGridEndCellDrawEventArgs2(graphics, rowIndex, cellIndex, bounds, value, style) {
      var _this = _super.call(this, graphics, rowIndex, cellIndex, bounds, value) || this;
      _this.cellStyle = style;
      return _this;
    }
    Object.defineProperty(PdfGridEndCellDrawEventArgs2.prototype, "style", {
      // Propertise
      /**
       * Get the `PdfGridCellStyle`.
       * @private
       */
      get: function() {
        return this.cellStyle;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridEndCellDrawEventArgs2;
  }(GridCellEventArgs)
);
var PdfCancelEventArgs = (
  /** @class */
  function() {
    function PdfCancelEventArgs2() {
    }
    Object.defineProperty(PdfCancelEventArgs2.prototype, "cancel", {
      // Properties
      /**
       * Gets and Sets the value of `cancel`.
       * @private
       */
      get: function() {
        return this.isCancel;
      },
      set: function(value) {
        this.isCancel = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfCancelEventArgs2;
  }()
);
var BeginPageLayoutEventArgs = (
  /** @class */
  function(_super) {
    __extends28(BeginPageLayoutEventArgs2, _super);
    function BeginPageLayoutEventArgs2(bounds, page) {
      var _this = _super.call(this) || this;
      _this.bounds = bounds;
      _this.pdfPage = page;
      return _this;
    }
    Object.defineProperty(BeginPageLayoutEventArgs2.prototype, "bounds", {
      // Properties
      /**
       * Gets or sets value that indicates the lay outing `bounds` on the page.
       * @private
       */
      get: function() {
        return this.cellBounds;
      },
      set: function(value) {
        this.cellBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BeginPageLayoutEventArgs2.prototype, "page", {
      /**
       * Gets the `page` where the lay outing should start.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    return BeginPageLayoutEventArgs2;
  }(PdfCancelEventArgs)
);
var EndPageLayoutEventArgs = (
  /** @class */
  function(_super) {
    __extends28(EndPageLayoutEventArgs2, _super);
    function EndPageLayoutEventArgs2(result) {
      var _this = _super.call(this) || this;
      _this.layoutResult = result;
      return _this;
    }
    Object.defineProperty(EndPageLayoutEventArgs2.prototype, "result", {
      // Properties
      /**
       * Gets the lay outing `result` of the page.
       * @private
       */
      get: function() {
        return this.layoutResult;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EndPageLayoutEventArgs2.prototype, "nextPage", {
      /**
       * Gets or sets a value indicating the `next page` where the element should be layout.
       * @private
       */
      get: function() {
        return this.nextPdfPage;
      },
      set: function(value) {
        this.nextPdfPage = value;
      },
      enumerable: true,
      configurable: true
    });
    return EndPageLayoutEventArgs2;
  }(PdfCancelEventArgs)
);
var PdfGridBeginPageLayoutEventArgs = (
  /** @class */
  function(_super) {
    __extends28(PdfGridBeginPageLayoutEventArgs2, _super);
    function PdfGridBeginPageLayoutEventArgs2(bounds, page, startRow) {
      var _this = _super.call(this, bounds, page) || this;
      _this.startRow = startRow;
      return _this;
    }
    Object.defineProperty(PdfGridBeginPageLayoutEventArgs2.prototype, "startRowIndex", {
      // Properties
      /**
       * Gets the `start row index`.
       * @private
       */
      get: function() {
        return this.startRow;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridBeginPageLayoutEventArgs2;
  }(BeginPageLayoutEventArgs)
);
var PdfGridEndPageLayoutEventArgs = (
  /** @class */
  function(_super) {
    __extends28(PdfGridEndPageLayoutEventArgs2, _super);
    function PdfGridEndPageLayoutEventArgs2(result) {
      return _super.call(this, result) || this;
    }
    return PdfGridEndPageLayoutEventArgs2;
  }(EndPageLayoutEventArgs)
);
var RowLayoutResult = (
  /** @class */
  function() {
    function RowLayoutResult2() {
      this.layoutedBounds = new RectangleF(0, 0, 0, 0);
    }
    Object.defineProperty(RowLayoutResult2.prototype, "isFinish", {
      /**
       * Gets or sets a value indicating whether this instance `is finish`.
       * @private
       */
      get: function() {
        return this.bIsFinished;
      },
      set: function(value) {
        this.bIsFinished = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RowLayoutResult2.prototype, "bounds", {
      /**
       * Gets or sets the `bounds`.
       * @private
       */
      get: function() {
        return this.layoutedBounds;
      },
      set: function(value) {
        this.layoutedBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    return RowLayoutResult2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid-cell.js
var PdfGridCell = (
  /** @class */
  function() {
    function PdfGridCell2(row) {
      this.cellWidth = 0;
      this.cellHeight = 0;
      this.tempval = 0;
      this.fontSpilt = false;
      this.finsh = true;
      this.rowSpanRemainingHeight = 0;
      this.hasRowSpan = false;
      this.hasColSpan = false;
      this.isFinish = true;
      this.present = false;
      this.gridRowSpan = 1;
      this.colSpan = 1;
      if (typeof row !== "undefined") {
        this.gridRow = row;
      }
    }
    Object.defineProperty(PdfGridCell2.prototype, "isCellMergeContinue", {
      //Properties
      get: function() {
        return this.internalIsCellMergeContinue;
      },
      set: function(value) {
        this.internalIsCellMergeContinue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "isRowMergeContinue", {
      get: function() {
        return this.internalIsRowMergeContinue;
      },
      set: function(value) {
        this.internalIsRowMergeContinue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "isCellMergeStart", {
      get: function() {
        return this.internalIsCellMergeStart;
      },
      set: function(value) {
        this.internalIsCellMergeStart = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "isRowMergeStart", {
      get: function() {
        return this.internalIsRowMergeStart;
      },
      set: function(value) {
        this.internalIsRowMergeStart = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "remainingString", {
      /**
       * Gets or sets the `remaining string` after the row split between pages.
       * @private
       */
      get: function() {
        return this.remaining;
      },
      set: function(value) {
        this.remaining = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "FinishedDrawingCell", {
      /**
       * Gets or sets the `FinishedDrawingCell` .
       * @private
       */
      get: function() {
        return this.isFinish;
      },
      set: function(value) {
        this.isFinish = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "stringFormat", {
      /**
       * Gets or sets the `string format`.
       * @private
       */
      get: function() {
        if (this.format == null) {
          this.format = new PdfStringFormat();
        }
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "row", {
      /**
       * Gets or sets the parent `row`.
       * @private
       */
      get: function() {
        return this.gridRow;
      },
      set: function(value) {
        this.gridRow = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "value", {
      /**
       * Gets or sets the `value` of the cell.
       * @private
       */
      get: function() {
        return this.objectValue;
      },
      set: function(value) {
        this.objectValue = value;
        if (this.objectValue instanceof PdfGrid) {
          this.row.grid.isSingleGrid = false;
          var grid = this.objectValue;
          grid.ParentCell = this;
          this.objectValue.isChildGrid = true;
          var rowCount = this.row.grid.rows.count;
          for (var i = 0; i < rowCount; i++) {
            var row = this.row.grid.rows.getRow(i);
            var colCount = row.cells.count;
            for (var j = 0; j < colCount; j++) {
              var cell = row.cells.getCell(j);
              cell.parent = this;
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "rowSpan", {
      /**
       * Gets or sets a value that indicates the total number of rows that cell `spans` within a PdfGrid.
       * @private
       */
      get: function() {
        return this.gridRowSpan;
      },
      set: function(value) {
        if (value < 1) {
          throw new Error("ArgumentException : Invalid span specified, must be greater than or equal to 1");
        } else {
          this.gridRowSpan = value;
          this.row.rowSpanExists = true;
          this.row.grid.hasRowSpanSpan = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "style", {
      /**
       * Gets or sets the cell `style`.
       * @private
       */
      get: function() {
        if (this.cellStyle == null) {
          this.cellStyle = new PdfGridCellStyle();
        }
        return this.cellStyle;
      },
      set: function(value) {
        this.cellStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "height", {
      /**
       * Gets the `height` of the PdfGrid cell.[Read-Only].
       * @private
       */
      get: function() {
        if (this.cellHeight === 0) {
          this.cellHeight = this.measureHeight();
        }
        return this.cellHeight;
      },
      set: function(value) {
        this.cellHeight = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "columnSpan", {
      /**
       * Gets or sets a value that indicates the total number of columns that cell `spans` within a PdfGrid.
       * @private
       */
      get: function() {
        return this.colSpan;
      },
      set: function(value) {
        if (value < 1) {
          throw Error("Invalid span specified, must be greater than or equal to 1");
        } else {
          this.colSpan = value;
          this.row.columnSpanExists = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "width", {
      /**
       * Gets the `width` of the PdfGrid cell.[Read-Only].
       * @private
       */
      get: function() {
        if (this.cellWidth === 0 || this.row.grid.isComplete) {
          this.cellWidth = this.measureWidth();
        }
        return Math.round(this.cellWidth);
      },
      set: function(value) {
        this.cellWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridCell2.prototype.measureWidth = function() {
      var width = 0;
      var layouter = new PdfStringLayouter();
      if (typeof this.objectValue === "string") {
        var slr = layouter.layout(this.objectValue, this.getTextFont(), this.stringFormat, new SizeF(Number.MAX_VALUE, Number.MAX_VALUE), false, new SizeF(0, 0));
        width += slr.actualSize.width;
        width += (this.style.borders.left.width + this.style.borders.right.width) * 2;
      } else if (this.objectValue instanceof PdfGrid) {
        width = this.objectValue.size.width;
      } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {
        width += this.objectValue.width;
      } else if (this.objectValue instanceof PdfTextWebLink) {
        var webLink = this.objectValue;
        var result = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(0, 0), false, new SizeF(0, 0));
        width += result.actualSize.width;
        width += (this.style.borders.left.width + this.style.borders.right.width) * 2;
      }
      if (!(this.objectValue instanceof PdfGrid)) {
        if (this.style.cellPadding != null) {
          width += this.style.cellPadding.left + this.style.cellPadding.right;
        } else {
          width += this.row.grid.style.cellPadding.left + this.row.grid.style.cellPadding.right;
        }
      } else {
        if (this.style.cellPadding != null || typeof this.style.cellPadding !== "undefined") {
          if (typeof this.style.cellPadding.left !== "undefined" && this.style.cellPadding.hasLeftPad) {
            width += this.style.cellPadding.left;
          }
          if (typeof this.style.cellPadding.right !== "undefined" && this.style.cellPadding.hasRightPad) {
            width += this.style.cellPadding.right;
          }
        } else {
          if (typeof this.row.grid.style.cellPadding.left !== "undefined" && this.row.grid.style.cellPadding.hasLeftPad) {
            width += this.row.grid.style.cellPadding.left;
          }
          if (typeof this.row.grid.style.cellPadding.right !== "undefined" && this.row.grid.style.cellPadding.hasRightPad) {
            width += this.row.grid.style.cellPadding.right;
          }
        }
      }
      width += this.row.grid.style.cellSpacing;
      return width;
    };
    PdfGridCell2.prototype.drawCellBackground = function(graphics, bounds) {
      var backgroundBrush = this.getBackgroundBrush();
      if (backgroundBrush != null) {
        graphics.save();
        graphics.drawRectangle(backgroundBrush, bounds.x, bounds.y, bounds.width, bounds.height);
        graphics.restore();
      }
      if (this.style.backgroundImage != null) {
        var image = this.getBackgroundImage();
        graphics.drawImage(this.style.backgroundImage, bounds.x, bounds.y, bounds.width, bounds.height);
      }
    };
    PdfGridCell2.prototype.adjustContentLayoutArea = function(bounds) {
      var returnBounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);
      if (!(this.objectValue instanceof PdfGrid)) {
        if (typeof this.style.cellPadding === "undefined" || this.style.cellPadding == null) {
          returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;
          returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;
          returnBounds.width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
          returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom + this.gridRow.grid.style.cellPadding.top;
          returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;
        } else {
          returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;
          returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;
          returnBounds.width -= this.style.cellPadding.right + this.style.cellPadding.left;
          returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;
          returnBounds.height -= this.style.cellPadding.bottom + this.style.cellPadding.top;
          returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;
          if (this.rowSpan === 1) {
            returnBounds.width -= this.style.borders.left.width;
          }
        }
      } else {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          if (typeof this.gridRow.grid.style.cellPadding.left !== "undefined" && this.gridRow.grid.style.cellPadding.hasLeftPad) {
            returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;
            returnBounds.width -= this.gridRow.grid.style.cellPadding.left;
          }
          if (typeof this.gridRow.grid.style.cellPadding.top !== "undefined" && this.gridRow.grid.style.cellPadding.hasTopPad) {
            returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;
            returnBounds.height -= this.gridRow.grid.style.cellPadding.top;
          }
          if (typeof this.gridRow.grid.style.cellPadding.right !== "undefined" && this.gridRow.grid.style.cellPadding.hasRightPad) {
            returnBounds.width -= this.gridRow.grid.style.cellPadding.right;
          }
          if (typeof this.gridRow.grid.style.cellPadding.bottom !== "undefined" && this.gridRow.grid.style.cellPadding.hasBottomPad) {
            returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom;
          }
        } else {
          if (typeof this.style.cellPadding.left !== "undefined" && this.style.cellPadding.hasLeftPad) {
            returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;
            returnBounds.width -= this.style.cellPadding.left;
          }
          if (typeof this.style.cellPadding.top !== "undefined" && this.style.cellPadding.hasTopPad) {
            returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;
            returnBounds.height -= this.style.cellPadding.top;
          }
          if (typeof this.style.cellPadding.right !== "undefined" && this.style.cellPadding.hasRightPad) {
            returnBounds.width -= this.style.cellPadding.right;
          }
          if (typeof this.style.cellPadding.bottom !== "undefined" && this.style.cellPadding.hasBottomPad) {
            returnBounds.height -= this.style.cellPadding.bottom;
          }
        }
        returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;
        returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;
      }
      return returnBounds;
    };
    PdfGridCell2.prototype.draw = function(graphics, bounds, cancelSubsequentSpans) {
      var isrowbreak = false;
      var result = null;
      if (this.internalIsCellMergeContinue || this.internalIsRowMergeContinue) {
        if (this.internalIsCellMergeContinue && this.row.grid.style.allowHorizontalOverflow) {
          if (this.row.rowOverflowIndex > 0 && this.row.cells.indexOf(this) != this.row.rowOverflowIndex + 1 || this.row.rowOverflowIndex == 0 && this.internalIsCellMergeContinue) {
            return result;
          }
        } else {
          return result;
        }
      }
      bounds = this.adjustOuterLayoutArea(bounds, graphics);
      this.drawCellBackground(graphics, bounds);
      var textPen = this.getTextPen();
      var textBrush = this.getTextBrush();
      if (typeof textPen === "undefined" && typeof textBrush === "undefined") {
        textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
      }
      var font = this.getTextFont();
      var strFormat = this.getStringFormat();
      var innerLayoutArea = bounds;
      if (innerLayoutArea.height >= graphics.clientSize.height) {
        if (this.row.grid.allowRowBreakAcrossPages) {
          innerLayoutArea.height -= innerLayoutArea.y;
        }
      }
      innerLayoutArea = this.adjustContentLayoutArea(innerLayoutArea);
      if (typeof this.objectValue === "string" || typeof this.remaining === "string") {
        var temp = void 0;
        var layoutRectangle = void 0;
        if (innerLayoutArea.height < font.height)
          layoutRectangle = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, font.height);
        else
          layoutRectangle = innerLayoutArea;
        if (innerLayoutArea.height < font.height && this.row.grid.isChildGrid && this.row.grid.ParentCell != null) {
          var height = layoutRectangle.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom - this.row.grid.style.cellPadding.bottom;
          if (this.row.grid.splitChildRowIndex != -1) {
            this.fontSpilt = true;
            this.row.rowFontSplit = true;
          }
          if (height > 0 && height < font.height)
            layoutRectangle.height = height;
        }
        if (this.gridRow.grid.style.cellSpacing != 0) {
          layoutRectangle.width -= this.gridRow.grid.style.cellSpacing;
          bounds.width -= this.gridRow.grid.style.cellSpacing;
        }
        if (this.isFinish) {
          temp = this.remaining === "" ? this.remaining : this.objectValue;
          graphics.drawString(temp, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);
          if (this.row.grid.splitChildRowIndex != -1 && !this.row.grid.isChildGrid && typeof this.remaining === "undefined") {
            this.remaining = "";
          }
        } else {
          if (typeof this.remaining == "undefined" || this.remaining === null) {
            this.remaining = "";
          }
          if (this.row.repeatFlag) {
            graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);
          }
          this.isFinish = true;
        }
        result = graphics.stringLayoutResult;
      } else if (this.objectValue instanceof PdfGrid) {
        var childGrid = this.objectValue;
        childGrid.isChildGrid = true;
        childGrid.ParentCell = this;
        var layoutRect = void 0;
        layoutRect = innerLayoutArea;
        if (this.gridRow.grid.style.cellSpacing != 0) {
          bounds.width -= this.gridRow.grid.style.cellSpacing;
        }
        var layouter = new PdfGridLayouter(childGrid);
        var format = new PdfGridLayoutFormat();
        if (this.row.grid.LayoutFormat != null)
          format = this.row.grid.LayoutFormat;
        else
          format.layout = PdfLayoutType.Paginate;
        var param = new PdfLayoutParams();
        if (graphics.layer != null) {
          param.page = graphics.page;
          param.bounds = layoutRect;
          param.format = format;
          childGrid.setSpan();
          childGrid.checkSpan();
          var childGridResult = layouter.Layouter(param);
          this.value = childGrid;
          if (this.row.grid.splitChildRowIndex !== -1) {
            this.height = this.row.rowBreakHeightValue;
          }
          if (param.page != childGridResult.page) {
            childGridResult.bounds.height = this.row.rowBreakHeightValue;
            if (this.row.rowBreakHeight == 0)
              this.row.NestedGridLayoutResult = childGridResult;
            else
              this.row.rowBreakHeight = this.row.rowBreakHeightValue;
          }
        }
      } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {
        var imageBounds = void 0;
        if (this.objectValue.width <= innerLayoutArea.width) {
          imageBounds = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, this.objectValue.width, innerLayoutArea.height);
        } else {
          imageBounds = innerLayoutArea;
        }
        graphics.drawImage(this.objectValue, imageBounds.x, imageBounds.y, imageBounds.width, imageBounds.height);
      } else if (this.objectValue instanceof PdfTextWebLink) {
        this.objectValue.draw(graphics.currentPage, innerLayoutArea);
      } else if (typeof this.objectValue === "undefined") {
        this.objectValue = "";
        graphics.drawString(this.objectValue, font, textPen, textBrush, innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, innerLayoutArea.height, strFormat);
        if (this.style.cellPadding != null && this.style.cellPadding.bottom == 0 && this.style.cellPadding.left == 0 && this.style.cellPadding.right == 0 && this.style.cellPadding.top == 0) {
          bounds.width -= this.style.borders.left.width + this.style.borders.right.width;
        }
        if (this.gridRow.grid.style.cellSpacing != 0) {
          bounds.width -= this.gridRow.grid.style.cellSpacing;
        }
      }
      if (this.style.borders != null) {
        if (!this.fontSpilt)
          this.drawCellBorders(graphics, bounds);
        else {
          if (this.row.grid.ParentCell.row.grid.splitChildRowIndex != -1) {
            this.row.rowFontSplit = false;
            this.drawCellBorders(graphics, bounds);
          }
        }
      }
      return result;
    };
    PdfGridCell2.prototype.drawCellBorders = function(graphics, bounds) {
      if (this.row.grid.style.borderOverlapStyle === PdfBorderOverlapStyle.Inside) {
        bounds.x += this.style.borders.left.width;
        bounds.y += this.style.borders.top.width;
        bounds.width -= this.style.borders.right.width;
        bounds.height -= this.style.borders.bottom.width;
      }
      var p1 = new PointF(bounds.x, bounds.y + bounds.height);
      var p2 = new PointF(bounds.x, bounds.y);
      var pen = this.cellStyle.borders.left;
      if (this.cellStyle.borders.left.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
      p1 = new PointF(bounds.x + bounds.width, bounds.y);
      p2 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);
      pen = this.cellStyle.borders.right;
      if (bounds.x + bounds.width > graphics.clientSize.width - pen.width / 2) {
        p1 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y);
        p2 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y + bounds.height);
      }
      if (this.cellStyle.borders.right.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
      p1 = new PointF(bounds.x, bounds.y);
      p2 = new PointF(bounds.x + bounds.width, bounds.y);
      pen = this.cellStyle.borders.top;
      if (this.cellStyle.borders.top.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
      p1 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);
      p2 = new PointF(bounds.x, bounds.y + bounds.height);
      pen = this.cellStyle.borders.bottom;
      if (bounds.y + bounds.height > graphics.clientSize.height - pen.width / 2) {
        p1 = new PointF(bounds.x + bounds.width, graphics.clientSize.height - pen.width / 2);
        p2 = new PointF(bounds.x, graphics.clientSize.height - pen.width / 2);
      }
      if (this.cellStyle.borders.bottom.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
    };
    PdfGridCell2.prototype.adjustOuterLayoutArea = function(bounds, g) {
      var isHeader = false;
      var cellSpacing = this.row.grid.style.cellSpacing;
      if (cellSpacing > 0) {
        bounds = new RectangleF(bounds.x + cellSpacing, bounds.y + cellSpacing, bounds.width - cellSpacing, bounds.height - cellSpacing);
      }
      var currentColIndex = this.row.cells.indexOf(this);
      if (this.columnSpan > 1 || this.row.rowOverflowIndex > 0 && currentColIndex == this.row.rowOverflowIndex + 1 && this.isCellMergeContinue) {
        var span = this.columnSpan;
        if (span == 1 && this.isCellMergeContinue) {
          for (var j = currentColIndex + 1; j < this.row.grid.columns.count; j++) {
            if (this.row.cells.getCell(j).isCellMergeContinue)
              span++;
            else
              break;
          }
        }
        var totalWidth = 0;
        for (var i = currentColIndex; i < currentColIndex + span; i++) {
          if (this.row.grid.style.allowHorizontalOverflow) {
            var width = void 0;
            var compWidth = this.row.grid.size.width < g.clientSize.width ? this.row.grid.size.width : g.clientSize.width;
            if (this.row.grid.size.width > g.clientSize.width) {
              width = bounds.x + totalWidth + this.row.grid.columns.getColumn(i).width;
            } else {
              width = totalWidth + this.row.grid.columns.getColumn(i).width;
            }
            if (width > compWidth) {
              break;
            }
          }
          totalWidth += this.row.grid.columns.getColumn(i).width;
        }
        totalWidth -= this.row.grid.style.cellSpacing;
        bounds.width = totalWidth;
      }
      if (this.rowSpan > 1 || this.row.rowSpanExists) {
        var span = this.rowSpan;
        var currentRowIndex = this.row.grid.rows.rowCollection.indexOf(this.row);
        if (currentRowIndex == -1) {
          currentRowIndex = this.row.grid.headers.indexOf(this.row);
          if (currentRowIndex != -1) {
            isHeader = true;
          }
        }
        var totalHeight = 0;
        var max = 0;
        for (var i = currentRowIndex; i < currentRowIndex + span; i++) {
          totalHeight += isHeader ? this.row.grid.headers.getHeader(i).height : this.row.grid.rows.getRow(i).height;
          var row = this.row.grid.rows.getRow(i);
          var rowIndex = this.row.grid.rows.rowCollection.indexOf(row);
        }
        var cellIndex = this.row.cells.indexOf(this);
        totalHeight -= this.row.grid.style.cellSpacing;
        bounds.height = totalHeight;
        if (!this.row.rowMergeComplete) {
          bounds.height = totalHeight;
        }
      }
      return bounds;
    };
    PdfGridCell2.prototype.getTextFont = function() {
      if (typeof this.style.font !== "undefined" && this.style.font != null) {
        return this.style.font;
      } else if (typeof this.row.style.font !== "undefined" && this.row.style.font != null) {
        return this.row.style.font;
      } else if (typeof this.row.grid.style.font !== "undefined" && this.row.grid.style.font != null) {
        return this.row.grid.style.font;
      } else {
        return PdfDocument.defaultFont;
      }
    };
    PdfGridCell2.prototype.getTextBrush = function() {
      if (typeof this.style.textBrush !== "undefined" && this.style.textBrush != null) {
        return this.style.textBrush;
      } else if (typeof this.row.style.textBrush !== "undefined" && this.row.style.textBrush != null) {
        return this.row.style.textBrush;
      } else {
        return this.row.grid.style.textBrush;
      }
    };
    PdfGridCell2.prototype.getTextPen = function() {
      if (typeof this.style.textPen !== "undefined" && this.style.textPen != null) {
        return this.style.textPen;
      } else if (typeof this.row.style.textPen !== "undefined" && this.row.style.textPen != null) {
        return this.row.style.textPen;
      } else {
        return this.row.grid.style.textPen;
      }
    };
    PdfGridCell2.prototype.getBackgroundBrush = function() {
      if (typeof this.style.backgroundBrush !== "undefined" && this.style.backgroundBrush != null) {
        return this.style.backgroundBrush;
      } else if (typeof this.row.style.backgroundBrush !== "undefined" && this.row.style.backgroundBrush != null) {
        return this.row.style.backgroundBrush;
      } else {
        return this.row.grid.style.backgroundBrush;
      }
    };
    PdfGridCell2.prototype.getBackgroundImage = function() {
      if (typeof this.style.backgroundImage !== "undefined" && this.style.backgroundImage != null) {
        return this.style.backgroundImage;
      } else if (typeof this.row.style.backgroundImage !== "undefined" && this.row.style.backgroundImage != null) {
        return this.row.style.backgroundImage;
      } else {
        return this.row.grid.style.backgroundImage;
      }
    };
    PdfGridCell2.prototype.getStringFormat = function() {
      if (typeof this.style.stringFormat !== "undefined" && this.style.stringFormat != null) {
        return this.style.stringFormat;
      } else {
        return this.stringFormat;
      }
    };
    PdfGridCell2.prototype.measureHeight = function() {
      var width = this.calculateWidth();
      if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
        width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
      } else {
        width -= this.style.cellPadding.right + this.style.cellPadding.left;
        width -= this.style.borders.left.width + this.style.borders.right.width;
      }
      var height = 0;
      var layouter = new PdfStringLayouter();
      if (typeof this.objectValue === "string" || typeof this.remaining === "string") {
        var currentValue = this.objectValue;
        if (!this.isFinish)
          currentValue = !(this.remaining === null || this.remaining === "" || typeof this.remaining === "undefined") ? this.remaining : this.objectValue;
        var slr = null;
        var cellIndex = this.row.cells.indexOf(this);
        if (this.gridRow.grid.style.cellSpacing != 0) {
          width -= this.gridRow.grid.style.cellSpacing * 2;
        }
        if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {
          if (this.gridRow.grid.isChildGrid) {
            if (width < 0) {
              this.tempval = width;
              if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
                this.tempval += this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
              } else {
                this.tempval += this.style.cellPadding.right + this.style.cellPadding.left;
                this.tempval += this.style.borders.left.width + this.style.borders.right.width;
              }
            } else {
              this.tempval = width;
            }
            slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(this.tempval, 0), false, new SizeF(0, 0));
            height += slr.actualSize.height;
          } else {
            slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));
            height += slr.actualSize.height;
          }
        }
        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
      } else if (this.objectValue instanceof PdfGrid) {
        var cellIndex = this.row.cells.indexOf(this);
        var internalWidth = 0;
        if (this.style.cellPadding != null || typeof this.style.cellPadding !== "undefined") {
          internalWidth = this.calculateWidth();
          if (typeof this.style.cellPadding.left !== "undefined" && this.style.cellPadding.hasLeftPad) {
            internalWidth -= this.style.cellPadding.left;
          }
          if (typeof this.style.cellPadding.right !== "undefined" && this.style.cellPadding.hasRightPad) {
            internalWidth -= this.style.cellPadding.right;
          }
        } else if (this.row.grid.style.cellPadding != null || typeof this.row.grid.style.cellPadding !== "undefined") {
          internalWidth = this.calculateWidth();
          if (typeof this.row.grid.style.cellPadding.left !== "undefined" && this.row.grid.style.cellPadding.hasLeftPad) {
            internalWidth -= this.row.grid.style.cellPadding.left;
          }
          if (typeof this.row.grid.style.cellPadding.right !== "undefined" && this.row.grid.style.cellPadding.hasRightPad) {
            internalWidth -= this.row.grid.style.cellPadding.right;
          }
        } else {
          internalWidth = this.calculateWidth();
        }
        this.objectValue.tempWidth = internalWidth;
        if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {
          height = this.objectValue.size.height;
        } else {
          height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
        }
        if (this.gridRow.grid.style.cellSpacing !== 0) {
          width -= this.gridRow.grid.style.cellSpacing * 2;
        }
        if (this.style.cellPadding != null || typeof this.style.cellPadding !== "undefined") {
          if (typeof this.row.grid.style.cellPadding.top !== "undefined" && this.row.grid.style.cellPadding.hasTopPad) {
            height += this.row.grid.style.cellPadding.top;
          }
          if (this.row.grid.style.cellPadding.hasBottomPad && typeof this.row.grid.style.cellPadding.bottom !== "undefined") {
            height += this.row.grid.style.cellPadding.bottom;
          }
        }
        height += this.objectValue.style.cellSpacing;
      } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {
        height += this.objectValue.height;
      } else if (this.objectValue instanceof PdfTextWebLink) {
        var webLink = this.objectValue;
        var slr = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));
        height += slr.actualSize.height;
        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
      } else if (typeof this.objectValue === "undefined") {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
        } else {
          width -= this.style.cellPadding.right + this.style.cellPadding.left;
          width -= this.style.borders.left.width + this.style.borders.right.width;
        }
        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
      }
      if (!(this.objectValue instanceof PdfGrid)) {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          height += this.row.grid.style.cellPadding.top + this.row.grid.style.cellPadding.bottom;
        } else {
          height += this.style.cellPadding.top + this.style.cellPadding.bottom;
        }
      } else {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          if (typeof this.row.grid.style.cellPadding.top !== "undefined" && this.row.grid.style.cellPadding.hasTopPad) {
            height += this.row.grid.style.cellPadding.top;
          }
          if (typeof this.row.grid.style.cellPadding.bottom !== "undefined" && this.row.grid.style.cellPadding.hasBottomPad) {
            height += this.row.grid.style.cellPadding.bottom;
          }
        } else {
          if (typeof this.style.cellPadding.top !== "undefined" && this.style.cellPadding.hasTopPad) {
            height += this.style.cellPadding.top;
          }
          if (typeof this.style.cellPadding.bottom !== "undefined" && this.style.cellPadding.hasBottomPad) {
            height += this.style.cellPadding.bottom;
          }
        }
      }
      height += this.row.grid.style.cellSpacing;
      return height;
    };
    PdfGridCell2.prototype.calculateWidth = function() {
      var cellIndex = this.row.cells.indexOf(this);
      var rowindex = this.row.grid.rows.rowCollection.indexOf(this.row);
      var columnSpan = this.columnSpan;
      var width = 0;
      if (columnSpan === 1) {
        for (var i = 0; i < columnSpan; i++) {
          width += this.row.grid.columns.getColumn(cellIndex + i).width;
        }
      } else if (columnSpan > 1) {
        for (var i = 0; i < columnSpan; i++) {
          width += this.row.grid.columns.getColumn(cellIndex + i).width;
          if (i + 1 < columnSpan) {
            this.row.cells.getCell(cellIndex + i + 1).hasColSpan = true;
          }
        }
      }
      if (this.parent != null && this.parent.row.width > 0) {
        if (this.row.grid.isChildGrid && this.parent != null && this.row.width > this.parent.row.width) {
          width = 0;
          for (var j = 0; j < this.parent.columnSpan; j++) {
            width += this.parent.row.grid.columns.getColumn(j).width;
          }
          width = width / this.row.cells.count;
        }
      }
      return width;
    };
    return PdfGridCell2;
  }()
);
var PdfGridCellCollection = (
  /** @class */
  function() {
    function PdfGridCellCollection2(row) {
      this.cells = [];
      this.gridRow = row;
    }
    PdfGridCellCollection2.prototype.getCell = function(index) {
      if (index < 0 || index >= this.count) {
        throw new Error("IndexOutOfRangeException");
      }
      return this.cells[index];
    };
    Object.defineProperty(PdfGridCellCollection2.prototype, "count", {
      /**
       * Gets the cells `count`.[Read-Only].
       * @private
       */
      get: function() {
        return this.cells.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridCellCollection2.prototype.add = function(cell) {
      if (typeof cell === "undefined") {
        var tempcell = new PdfGridCell();
        this.add(tempcell);
        return cell;
      } else {
        cell.row = this.gridRow;
        this.cells.push(cell);
      }
    };
    PdfGridCellCollection2.prototype.indexOf = function(cell) {
      return this.cells.indexOf(cell);
    };
    return PdfGridCellCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid-column.js
var PdfGridColumn = (
  /** @class */
  function() {
    function PdfGridColumn2(grid) {
      this.columnWidth = 0;
      this.grid = grid;
    }
    Object.defineProperty(PdfGridColumn2.prototype, "width", {
      /**
       * Gets or sets the `width` of the 'PdfGridColumn'.
       * @private
       */
      get: function() {
        return this.columnWidth;
      },
      set: function(value) {
        this.isCustomWidth = true;
        this.columnWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridColumn2.prototype, "format", {
      /**
       * Gets or sets the information about the text `formatting`.
       * @private
       */
      get: function() {
        if (this.stringFormat == null) {
          this.stringFormat = new PdfStringFormat();
        }
        return this.stringFormat;
      },
      set: function(value) {
        this.stringFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridColumn2;
  }()
);
var PdfGridColumnCollection = (
  /** @class */
  function() {
    function PdfGridColumnCollection2(grid) {
      this.internalColumns = [];
      this.columnWidth = 0;
      this.grid = grid;
      this.internalColumns = [];
    }
    PdfGridColumnCollection2.prototype.add = function(count) {
      for (var i = 0; i < count; i++) {
        this.internalColumns.push(new PdfGridColumn(this.grid));
        for (var index = 0; index < this.grid.rows.count; index++) {
          var row = this.grid.rows.getRow(index);
          var cell = new PdfGridCell();
          cell.value = "";
          row.cells.add(cell);
        }
      }
    };
    Object.defineProperty(PdfGridColumnCollection2.prototype, "count", {
      /**
       * Gets the `number of columns` in the 'PdfGrid'.[Read-Only].
       * @private
       */
      get: function() {
        return this.internalColumns.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridColumnCollection2.prototype, "width", {
      /**
       * Gets the `widths`.
       * @private
       */
      get: function() {
        if (this.columnWidth === 0) {
          this.columnWidth = this.measureColumnsWidth();
        }
        if (this.grid.initialWidth !== 0 && this.columnWidth !== this.grid.initialWidth && !this.grid.style.allowHorizontalOverflow) {
          this.columnWidth = this.grid.initialWidth;
          this.grid.isPageWidth = true;
        }
        return this.columnWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridColumnCollection2.prototype, "columns", {
      /**
       * Gets the `array of PdfGridColumn`.[Read-Only]
       * @private
       */
      get: function() {
        return this.internalColumns;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridColumnCollection2.prototype.getColumn = function(index) {
      if (index >= 0 && index <= this.columns.length) {
        return this.columns[index];
      } else {
        throw Error("can not get the column from the index: " + index);
      }
    };
    PdfGridColumnCollection2.prototype.measureColumnsWidth = function() {
      var totalWidth = 0;
      this.grid.measureColumnsWidth();
      for (var i = 0, count = this.internalColumns.length; i < count; i++) {
        totalWidth += this.internalColumns[i].width;
      }
      return totalWidth;
    };
    PdfGridColumnCollection2.prototype.getDefaultWidths = function(totalWidth) {
      var widths = [];
      var summ = 0;
      var subFactor = this.count;
      for (var i = 0; i < this.count; i++) {
        if (this.grid.isPageWidth && totalWidth >= 0 && !this.internalColumns[i].isCustomWidth) {
          this.internalColumns[i].width = 0;
        } else {
          widths[i] = this.internalColumns[i].width;
          if (this.internalColumns[i].width > 0 && this.internalColumns[i].isCustomWidth) {
            totalWidth -= this.internalColumns[i].width;
            subFactor--;
          } else {
            widths[i] = 0;
          }
        }
      }
      for (var i = 0; i < this.count; i++) {
        var width = totalWidth / subFactor;
        if (widths[i] <= 0) {
          widths[i] = width;
        }
      }
      return widths;
    };
    return PdfGridColumnCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid-row.js
var PdfGridRow = (
  /** @class */
  function() {
    function PdfGridRow2(grid) {
      this.gridRowOverflowIndex = 0;
      this.rowHeight = 0;
      this.rowWidth = 0;
      this.isrowFinish = false;
      this.isRowSpanRowHeightSet = false;
      this.noOfPageCount = 0;
      this.isRowHeightSet = false;
      this.isPageBreakRowSpanApplied = false;
      this.isRowMergeComplete = true;
      this.repeatFlag = false;
      this.rowFontSplit = false;
      this.isHeaderRow = false;
      this.pdfGrid = grid;
    }
    Object.defineProperty(PdfGridRow2.prototype, "rowSpanExists", {
      //Properties
      /**
       * Gets or sets a value indicating [`row span exists`].
       * @private
       */
      get: function() {
        return this.bRowSpanExists;
      },
      set: function(value) {
        this.bRowSpanExists = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "cells", {
      /**
       * Gets the `cells` from the selected row.[Read-Only].
       * @private
       */
      get: function() {
        if (this.gridCells == null) {
          this.gridCells = new PdfGridCellCollection(this);
        }
        return this.gridCells;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "grid", {
      /**
       * Gets or sets the parent `grid`.
       * @private
       */
      get: function() {
        return this.pdfGrid;
      },
      set: function(value) {
        this.pdfGrid = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "style", {
      /**
       * Gets or sets the row `style`.
       * @private
       */
      get: function() {
        if (typeof this.rowStyle === "undefined") {
          this.rowStyle = new PdfGridRowStyle();
          this.rowStyle.setParent(this);
        }
        return this.rowStyle;
      },
      set: function(value) {
        this.rowStyle = value;
        for (var i = 0; i < this.cells.count; i++) {
          this.cells.getCell(i).style.borders = value.border;
          if (typeof value.font !== "undefined") {
            this.cells.getCell(i).style.font = value.font;
          }
          if (typeof value.backgroundBrush !== "undefined") {
            this.cells.getCell(i).style.backgroundBrush = value.backgroundBrush;
          }
          if (typeof value.backgroundImage !== "undefined") {
            this.cells.getCell(i).style.backgroundImage = value.backgroundImage;
          }
          if (typeof value.textBrush !== "undefined") {
            this.cells.getCell(i).style.textBrush = value.textBrush;
          }
          if (typeof value.textPen !== "undefined") {
            this.cells.getCell(i).style.textPen = value.textPen;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowBreakHeight", {
      /**
       * `Height` of the row yet to be drawn after split.
       * @private
       */
      get: function() {
        if (typeof this.gridRowBreakHeight === "undefined") {
          this.gridRowBreakHeight = 0;
        }
        return this.gridRowBreakHeight;
      },
      set: function(value) {
        this.gridRowBreakHeight = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowOverflowIndex", {
      /**
       * `over flow index` of the row.
       * @private
       */
      get: function() {
        return this.gridRowOverflowIndex;
      },
      set: function(value) {
        this.gridRowOverflowIndex = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "height", {
      /**
       * Gets or sets the `height` of the row.
       * @private
       */
      get: function() {
        if (!this.isRowHeightSet) {
          this.rowHeight = this.measureHeight();
        }
        return this.rowHeight;
      },
      set: function(value) {
        this.rowHeight = value;
        this.isRowHeightSet = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "width", {
      /**
       * Gets or sets the `width` of the row.
       * @private
       */
      get: function() {
        if (this.rowWidth === 0 || typeof this.rowWidth === "undefined") {
          this.rowWidth = this.measureWidth();
        }
        return this.rowWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "NestedGridLayoutResult", {
      /**
       * Gets or sets the row `Nested grid Layout Result`.
       * @private
       */
      get: function() {
        return this.gridResult;
      },
      set: function(value) {
        this.gridResult = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "columnSpanExists", {
      /**
       * Gets or sets a value indicating [`column span exists`].
       * @private
       */
      get: function() {
        return this.bColumnSpanExists;
      },
      set: function(value) {
        this.bColumnSpanExists = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowMergeComplete", {
      /**
       * Check whether the Row `has row span or row merge continue`.
       * @private
       */
      get: function() {
        return this.isRowMergeComplete;
      },
      set: function(value) {
        this.isRowMergeComplete = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowIndex", {
      /**
       * Returns `index` of the row.
       * @private
       */
      get: function() {
        return this.grid.rows.rowCollection.indexOf(this);
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRow2.prototype.measureHeight = function() {
      var rowSpanRemainingHeight = 0;
      var rowHeight;
      var maxHeight = 0;
      if (this.cells.getCell(0).rowSpan > 1) {
        rowHeight = 0;
      } else {
        rowHeight = this.cells.getCell(0).height;
      }
      for (var i = 0; i < this.cells.count; i++) {
        var cell = this.cells.getCell(i);
        if (cell.rowSpanRemainingHeight > rowSpanRemainingHeight) {
          rowSpanRemainingHeight = cell.rowSpanRemainingHeight;
        }
        this.rowMergeComplete = false;
        if (cell.rowSpan > 1) {
          var cellIn = i;
          var rowin = this.isHeaderRow ? this.grid.headers.indexOf(this) : this.grid.rows.rowCollection.indexOf(this);
          for (var j = 0; j < cell.rowSpan; j++) {
            if (j + 1 < cell.rowSpan) {
              (this.isHeaderRow ? this.grid.headers.getHeader(rowin + j + 1) : this.grid.rows.getRow(rowin + j + 1)).cells.getCell(cellIn).hasRowSpan = true;
            }
          }
          if (maxHeight < cell.height) {
            maxHeight = cell.height;
          }
          continue;
        }
        rowHeight = Math.max(rowHeight, cell.height);
      }
      if (maxHeight > rowHeight) {
        rowHeight = maxHeight;
      }
      if (rowHeight === 0) {
        rowHeight = maxHeight;
      } else if (rowSpanRemainingHeight > 0) {
        rowHeight += rowSpanRemainingHeight;
      }
      return rowHeight;
    };
    PdfGridRow2.prototype.measureWidth = function() {
      var rowWid = 0;
      for (var i = 0; i < this.grid.columns.count; i++) {
        var column = this.grid.columns.getColumn(i);
        rowWid += column.width;
      }
      return rowWid;
    };
    return PdfGridRow2;
  }()
);
var PdfGridRowCollection = (
  /** @class */
  function() {
    function PdfGridRowCollection2(grid) {
      this.rows = [];
      this.grid = grid;
    }
    Object.defineProperty(PdfGridRowCollection2.prototype, "count", {
      //Properties
      /**
       * Gets the number of header in the `PdfGrid`.[Read-Only].
       * @private
       */
      get: function() {
        return this.rows.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRowCollection2.prototype, "rowCollection", {
      //Implementation
      /**
       * Return the row collection of the `grid`.
       * @private
       */
      get: function() {
        return this.rows;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowCollection2.prototype.addRow = function(arg) {
      if (typeof arg === "undefined") {
        var temprow = new PdfGridRow(this.grid);
        this.addRow(temprow);
        return temprow;
      } else {
        arg.style.setBackgroundBrush(this.grid.style.backgroundBrush);
        arg.style.setFont(this.grid.style.font);
        arg.style.setTextBrush(this.grid.style.textBrush);
        arg.style.setTextPen(this.grid.style.textPen);
        if (arg.cells.count === 0) {
          for (var i = 0; i < this.grid.columns.count; i++) {
            arg.cells.add(new PdfGridCell());
          }
        }
        this.rows.push(arg);
      }
    };
    PdfGridRowCollection2.prototype.getRow = function(index) {
      return this.rows[index];
    };
    return PdfGridRowCollection2;
  }()
);
var PdfGridHeaderCollection = (
  /** @class */
  function() {
    function PdfGridHeaderCollection2(grid) {
      this.rows = [];
      this.grid = grid;
      this.rows = [];
    }
    PdfGridHeaderCollection2.prototype.getHeader = function(index) {
      return this.rows[index];
    };
    Object.defineProperty(PdfGridHeaderCollection2.prototype, "count", {
      /**
       * Gets the `number of header` in the 'PdfGrid'.[Read-Only]
       * @private
       */
      get: function() {
        return this.rows.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridHeaderCollection2.prototype.add = function(arg) {
      if (typeof arg === "number") {
        var row = void 0;
        for (var i = 0; i < arg; i++) {
          row = new PdfGridRow(this.grid);
          row.isHeaderRow = true;
          for (var j = 0; j < this.grid.columns.count; j++) {
            row.cells.add(new PdfGridCell());
          }
          this.rows.push(row);
        }
        return this.rows;
      } else {
        this.rows.push(arg);
      }
    };
    PdfGridHeaderCollection2.prototype.indexOf = function(row) {
      return this.rows.indexOf(row);
    };
    return PdfGridHeaderCollection2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid.js
var __extends29 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfGrid = (
  /** @class */
  function(_super) {
    __extends29(PdfGrid2, _super);
    function PdfGrid2() {
      var _this = _super.call(this) || this;
      _this.gridSize = new SizeF(0, 0);
      _this.isGridSplit = false;
      _this.isRearranged = false;
      _this.pageBounds = new RectangleF();
      _this.listOfNavigatePages = [];
      _this.parentCellIndex = 0;
      _this.tempWidth = 0;
      _this.breakRow = true;
      _this.splitChildRowIndex = -1;
      _this.hasRowSpanSpan = false;
      _this.hasColumnSpan = false;
      _this.isSingleGrid = true;
      return _this;
    }
    Object.defineProperty(PdfGrid2.prototype, "raiseBeginCellDraw", {
      //Properties
      /**
       * Gets a value indicating whether the `start cell layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.beginCellDraw !== "undefined" && typeof this.beginCellDraw !== null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "raiseEndCellDraw", {
      /**
       * Gets a value indicating whether the `end cell layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.endCellDraw !== "undefined" && typeof this.endCellDraw !== null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "repeatHeader", {
      /**
       * Gets or sets a value indicating whether to `repeat header`.
       * @private
       */
      get: function() {
        if (this.bRepeatHeader == null || typeof this.bRepeatHeader === "undefined") {
          this.bRepeatHeader = false;
        }
        return this.bRepeatHeader;
      },
      set: function(value) {
        this.bRepeatHeader = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "allowRowBreakAcrossPages", {
      /**
       * Gets or sets a value indicating whether to split or cut rows that `overflow a page`.
       * @private
       */
      get: function() {
        return this.breakRow;
      },
      set: function(value) {
        this.breakRow = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "columns", {
      /**
       * Gets the `column` collection of the PdfGrid.[Read-Only]
       * @private
       */
      get: function() {
        if (this.gridColumns == null || typeof this.gridColumns === "undefined") {
          this.gridColumns = new PdfGridColumnCollection(this);
        }
        return this.gridColumns;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "rows", {
      /**
       * Gets the `row` collection from the PdfGrid.[Read-Only]
       * @private
       */
      get: function() {
        if (this.gridRows == null) {
          this.gridRows = new PdfGridRowCollection(this);
        }
        return this.gridRows;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "headers", {
      /**
       * Gets the `headers` collection from the PdfGrid.[Read-Only]
       * @private
       */
      get: function() {
        if (this.gridHeaders == null || typeof this.gridHeaders === "undefined") {
          this.gridHeaders = new PdfGridHeaderCollection(this);
        }
        return this.gridHeaders;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "initialWidth", {
      /**
       * Indicating `initial width` of the page.
       * @private
       */
      get: function() {
        return this.gridInitialWidth;
      },
      set: function(value) {
        this.gridInitialWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "style", {
      /**
       * Gets or sets the `grid style`.
       * @private
       */
      get: function() {
        if (this.gridStyle == null) {
          this.gridStyle = new PdfGridStyle();
        }
        return this.gridStyle;
      },
      set: function(value) {
        if (this.gridStyle == null) {
          this.gridStyle = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "isPageWidth", {
      /**
       * Gets a value indicating whether the grid column width is considered to be `page width`.
       * @private
       */
      get: function() {
        return this.ispageWidth;
      },
      set: function(value) {
        this.ispageWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "isChildGrid", {
      /**
       * Gets or set if grid `is nested grid`.
       * @private
       */
      get: function() {
        return this.ischildGrid;
      },
      set: function(value) {
        this.ischildGrid = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "size", {
      /**
       * Gets or set if grid ' is split or not'
       * @public
       */
      // public get isGridSplit() : boolean {
      //     return this.isgridSplit;
      // }
      // public set isGridSplit(value : boolean) {
      //     this.isgridSplit = value;
      // }public get isGridSplit() : boolean {
      //     return this.isgridSplit;
      // }
      // public set isGridSplit(value : boolean) {
      //     this.isgridSplit = value;
      // }
      /**
       * Gets the `size`.
       * @private
       */
      get: function() {
        if ((this.gridSize.width === 0 || typeof this.gridSize.width === "undefined") && this.gridSize.height === 0) {
          this.gridSize = this.measure();
        }
        return this.gridSize;
      },
      set: function(value) {
        this.gridSize = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "ParentCell", {
      get: function() {
        return this.parentCell;
      },
      set: function(value) {
        this.parentCell = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "LayoutFormat", {
      get: function() {
        return this.layoutFormat;
      },
      enumerable: true,
      configurable: true
    });
    PdfGrid2.prototype.draw = function(arg1, arg2, arg3, arg4) {
      if (arg2 instanceof PointF && typeof arg2.width === "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2.x, arg2.y);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        return this.drawHelper(arg1, arg2, arg3, null);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2, null);
      } else if (arg2 instanceof PointF && typeof arg2.width === "undefined" && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg1, arg2.x, arg2.y, arg3);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && (arg4 instanceof PdfLayoutFormat || arg4 == null)) {
        var width = arg1.graphics.clientSize.width - arg2;
        var layoutRectangle = new RectangleF(arg2, arg3, width, 0);
        return this.drawHelper(arg1, layoutRectangle, arg4);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "boolean") {
        return this.drawHelper(arg1, arg2, null);
      } else {
        return this.drawHelper(arg1, arg2, arg3);
      }
    };
    PdfGrid2.prototype.measure = function() {
      var height = 0;
      var width = this.columns.width;
      for (var i = 0; i < this.headers.count; i++) {
        var row = this.headers.getHeader(i);
        height += row.height;
      }
      for (var i = 0; i < this.rows.count; i++) {
        var row = this.rows.getRow(i);
        height += row.height;
      }
      return new SizeF(width, height);
    };
    PdfGrid2.prototype.onBeginCellDraw = function(args) {
      if (this.raiseBeginCellDraw) {
        this.beginCellDraw(this, args);
      }
    };
    PdfGrid2.prototype.onEndCellDraw = function(args) {
      if (this.raiseEndCellDraw) {
        this.endCellDraw(this, args);
      }
    };
    PdfGrid2.prototype.layout = function(param) {
      var width = param.bounds.width;
      var height = param.bounds.height;
      var hasChanged = false;
      if (typeof param.bounds.width === "undefined" || param.bounds.width === 0) {
        width = param.page.getClientSize().width - param.bounds.x;
        hasChanged = true;
      }
      if (typeof param.bounds.height === "undefined" || param.bounds.height === 0) {
        height = param.page.getClientSize().height - param.bounds.y;
        hasChanged = true;
      }
      if (hasChanged) {
        param.bounds = new RectangleF(param.bounds.x, param.bounds.y, width, height);
      }
      if (this.rows.count !== 0) {
        var currentRow = this.rows.getRow(0).cells.getCell(0).style;
        if (currentRow.borders != null && (currentRow.borders.left != null && currentRow.borders.left.width !== 1 || currentRow.borders.top != null && currentRow.borders.top.width !== 1)) {
          var x = currentRow.borders.left.width / 2;
          var y = currentRow.borders.top.width / 2;
          if (param.bounds.x === PdfBorders.default.right.width / 2 && param.bounds.y === PdfBorders.default.right.width / 2) {
            var newBound = new RectangleF(x, y, this.gridSize.width, this.gridSize.height);
            param.bounds = newBound;
          }
        }
      }
      this.setSpan();
      this.checkSpan();
      this.layoutFormat = param.format;
      this.gridLocation = param.bounds;
      var layouter = new PdfGridLayouter(this);
      var result = layouter.Layouter(param);
      return result;
    };
    PdfGrid2.prototype.setSpan = function() {
      var colSpan = 1;
      var rowSpan = 1;
      var currentCellIndex = 0;
      var currentRowIndex = 0;
      var maxSpan = 0;
      var rowCount = this.headers.count;
      for (var i = 0; i < rowCount; i++) {
        var row = this.headers.getHeader(i);
        maxSpan = 0;
        var colCount = row.cells.count;
        for (var j = 0; j < colCount; j++) {
          var cell = row.cells.getCell(j);
          maxSpan = Math.max(maxSpan, cell.rowSpan);
          if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {
            if (cell.columnSpan + j > row.cells.count) {
              throw new Error("Invalid span specified at row " + j.toString() + " column " + i.toString());
            }
            if (cell.rowSpan + i > this.headers.count) {
              throw new Error("Invalid span specified at Header " + j.toString() + " column " + i.toString());
            }
            if (cell.columnSpan > 1 && cell.rowSpan > 1) {
              colSpan = cell.columnSpan;
              rowSpan = cell.rowSpan;
              currentCellIndex = j;
              currentRowIndex = i;
              cell.isCellMergeStart = true;
              cell.isRowMergeStart = true;
              while (colSpan > 1) {
                currentCellIndex++;
                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                row.cells.getCell(currentCellIndex).isRowMergeContinue = true;
                row.cells.getCell(currentCellIndex).rowSpan = rowSpan;
                colSpan--;
              }
              currentCellIndex = j;
              colSpan = cell.columnSpan;
              while (rowSpan > 1) {
                currentRowIndex++;
                this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                rowSpan--;
                while (colSpan > 1) {
                  currentCellIndex++;
                  this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;
                  this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                  colSpan--;
                }
                colSpan = cell.columnSpan;
                currentCellIndex = j;
              }
            } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {
              colSpan = cell.columnSpan;
              currentCellIndex = j;
              cell.isCellMergeStart = true;
              while (colSpan > 1) {
                currentCellIndex++;
                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                colSpan--;
              }
            } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {
              rowSpan = cell.rowSpan;
              currentRowIndex = i;
              while (rowSpan > 1) {
                currentRowIndex++;
                this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                rowSpan--;
              }
            }
          }
        }
        row.maximumRowSpan = maxSpan;
      }
    };
    PdfGrid2.prototype.checkSpan = function() {
      var cellcolSpan;
      var cellrowSpan = 1;
      var cellmaxSpan = 0;
      var currentCellIndex;
      var currentRowIndex = 0;
      cellcolSpan = cellrowSpan = 1;
      currentCellIndex = currentRowIndex = 0;
      if (this.hasRowSpanSpan || this.hasColumnSpan) {
        var rowCount = this.rows.count;
        for (var i = 0; i < rowCount; i++) {
          var row = this.rows.getRow(i);
          cellmaxSpan = 0;
          var colCount = row.cells.count;
          for (var j = 0; j < colCount; j++) {
            var cell = row.cells.getCell(j);
            cellmaxSpan = Math.max(cellmaxSpan, cell.rowSpan);
            if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {
              if (cell.columnSpan + j > row.cells.count) {
                throw new Error("Invalid span specified at row  " + j.toString() + " column " + i.toString());
              }
              if (cell.rowSpan + i > this.rows.count) {
                throw new Error("Invalid span specified at row  " + j.toString() + " column " + i.toString());
              }
              if (cell.columnSpan > 1 && cell.rowSpan > 1) {
                cellcolSpan = cell.columnSpan;
                cellrowSpan = cell.rowSpan;
                currentCellIndex = j;
                currentRowIndex = i;
                cell.isCellMergeStart = true;
                cell.isRowMergeStart = true;
                while (cellcolSpan > 1) {
                  currentCellIndex++;
                  row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                  row.cells.getCell(currentCellIndex).isRowMergeContinue = true;
                  cellcolSpan--;
                }
                currentCellIndex = j;
                cellcolSpan = cell.columnSpan;
                while (cellrowSpan > 1) {
                  currentRowIndex++;
                  this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                  this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                  cellrowSpan--;
                  while (cellcolSpan > 1) {
                    currentCellIndex++;
                    this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;
                    this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                    cellcolSpan--;
                  }
                  cellcolSpan = cell.columnSpan;
                  currentCellIndex = j;
                }
              } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {
                cellcolSpan = cell.columnSpan;
                currentCellIndex = j;
                cell.isCellMergeStart = true;
                while (cellcolSpan > 1) {
                  currentCellIndex++;
                  row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                  cellcolSpan--;
                }
              } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {
                cellrowSpan = cell.rowSpan;
                currentRowIndex = i;
                while (cellrowSpan > 1) {
                  currentRowIndex++;
                  this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                  cellrowSpan--;
                }
              }
            }
          }
          row.maximumRowSpan = cellmaxSpan;
        }
      }
    };
    PdfGrid2.prototype.measureColumnsWidth = function(bounds) {
      if (typeof bounds !== "undefined") {
        this.isPageWidth = false;
        var widths = this.columns.getDefaultWidths(bounds.width - bounds.x);
        for (var i = 0, count = this.columns.count; i < count; i++) {
          this.columns.getColumn(i).columnWidth = widths[i];
          this.tempWidth = widths[i];
        }
        if (this.ParentCell != null && this.style.allowHorizontalOverflow == false && this.ParentCell.row.grid.style.allowHorizontalOverflow == false) {
          var padding = 0;
          var columnWidth = 0;
          var columnCount = this.columns.count;
          var childGridColumnWidth = 0;
          if (this.ParentCell.style.cellPadding != null || typeof this.ParentCell.style.cellPadding !== "undefined") {
            if (typeof this.ParentCell.style.cellPadding.left != "undefined" && this.ParentCell.style.cellPadding.hasLeftPad) {
              padding += this.ParentCell.style.cellPadding.left;
            }
            if (typeof this.ParentCell.style.cellPadding.right != "undefined" && this.ParentCell.style.cellPadding.hasRightPad) {
              padding += this.ParentCell.style.cellPadding.right;
            }
          }
          for (var i = 0; i < this.ParentCell.columnSpan; i++) {
            columnWidth += this.ParentCell.row.grid.columns.getColumn(this.parentCellIndex + i).width;
          }
          for (var j = 0; j < this.columns.count; j++) {
            if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {
              columnWidth -= this.gridColumns.getColumn(j).width;
              columnCount--;
            }
          }
          if (this.ParentCell.row.grid.style.cellPadding != null || typeof this.ParentCell.row.grid.style.cellPadding != "undefined") {
            if (typeof this.ParentCell.row.grid.style.cellPadding.top != "undefined" && this.ParentCell.row.grid.style.cellPadding.hasTopPad) {
              padding += this.ParentCell.row.grid.style.cellPadding.top;
            }
            if (typeof this.ParentCell.row.grid.style.cellPadding.bottom != "undefined" && this.ParentCell.row.grid.style.cellPadding.hasBottomPad) {
              padding += this.ParentCell.row.grid.style.cellPadding.bottom;
            }
          }
          if (this.ParentCell.row.grid.style.cellSpacing != 0) {
            columnWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;
          }
          if (columnWidth > padding) {
            childGridColumnWidth = (columnWidth - padding) / columnCount;
            this.tempWidth = childGridColumnWidth;
            if (this.ParentCell != null) {
              for (var j = 0; j < this.columns.count; j++) {
                if (!this.columns.getColumn(j).isCustomWidth)
                  this.columns.getColumn(j).columnWidth = childGridColumnWidth;
              }
            }
          }
        }
      } else {
        var widths = [this.columns.count];
        for (var n = 0; n < this.columns.count; n++) {
          widths[n] = 0;
        }
        var cellWidth = 0;
        var cellWidths = 0;
        if (typeof this.isChildGrid === "undefined" && typeof this.gridLocation !== "undefined" || this.isChildGrid === null && typeof this.gridLocation !== "undefined") {
          this.initialWidth = this.gridLocation.width;
        }
        if (this.headers.count > 0) {
          var colCount_1 = this.headers.getHeader(0).cells.count;
          var rowCount = this.headers.count;
          for (var i = 0; i < colCount_1; i++) {
            cellWidth = 0;
            for (var j = 0; j < rowCount; j++) {
              var rowWidth = Math.min(this.initialWidth, this.headers.getHeader(j).cells.getCell(i).width);
              cellWidth = Math.max(cellWidth, rowWidth);
            }
            widths[i] = cellWidth;
          }
        }
        cellWidth = 0;
        for (var i = 0, colCount_2 = this.columns.count; i < colCount_2; i++) {
          for (var j = 0, rowCount = this.rows.count; j < rowCount; j++) {
            if (this.rows.getRow(j).cells.getCell(i).columnSpan == 1 && !this.rows.getRow(j).cells.getCell(i).isCellMergeContinue || this.rows.getRow(j).cells.getCell(i).value != null) {
              if (this.rows.getRow(j).cells.getCell(i).value != null && !this.rows.getRow(j).grid.style.allowHorizontalOverflow) {
                var value = this.rows.getRow(j).grid.style.cellPadding.right + this.rows.getRow(j).grid.style.cellPadding.left + this.rows.getRow(j).cells.getCell(i).style.borders.left.width / 2;
              }
              var rowWidth = 0;
              rowWidth = this.initialWidth > 0 ? Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width) : this.rows.getRow(j).cells.getCell(i).width;
              cellWidth = Math.max(widths[i], Math.max(cellWidth, rowWidth));
              cellWidth = Math.max(this.columns.getColumn(i).width, cellWidth);
            }
          }
          if (this.rows.count != 0)
            widths[i] = cellWidth;
          cellWidth = 0;
        }
        for (var i = 0, RowCount = this.rows.count; i < RowCount; i++) {
          for (var j = 0, ColCount = this.columns.count; j < ColCount; j++) {
            if (this.rows.getRow(i).cells.getCell(j).columnSpan > 1) {
              var total = widths[j];
              for (var k = 1; k < this.rows.getRow(i).cells.getCell(j).columnSpan; k++) {
                total += widths[j + k];
              }
            }
          }
        }
        for (var i = 0, count = this.columns.count; i < count; i++) {
          if (this.columns.getColumn(i).width <= 0)
            this.columns.getColumn(i).columnWidth = widths[i];
          else if (this.columns.getColumn(i).width > 0 && !this.columns.getColumn(i).isCustomWidth)
            this.columns.getColumn(i).columnWidth = widths[i];
        }
        var padding = 0;
        var colWidth = 0;
        var colCount = this.columns.count;
        var childGridColWidth = 0;
        colWidth = this.tempWidth;
        for (var j = 0; j < this.columns.count; j++) {
          if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {
            colWidth -= this.gridColumns.getColumn(j).width;
            colCount--;
          }
        }
        if (colWidth > 0) {
          if (this.ParentCell.row.grid.style.cellSpacing != 0) {
            colWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;
          }
        }
        if (colWidth > padding) {
          childGridColWidth = colWidth / colCount;
          if (this.ParentCell != null) {
            for (var j = 0; j < this.columns.count; j++) {
              if (!this.columns.getColumn(j).isCustomWidth)
                this.columns.getColumn(j).columnWidth = childGridColWidth;
            }
          }
        }
      }
    };
    return PdfGrid2;
  }(PdfLayoutElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-true-type-font.js
var __extends30 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfTrueTypeFont = (
  /** @class */
  function(_super) {
    __extends30(PdfTrueTypeFont2, _super);
    function PdfTrueTypeFont2(base64String, size, style) {
      var _this = _super.call(this, size) || this;
      _this.isEmbedFont = false;
      _this.isUnicode = true;
      if (style !== void 0) {
        _this.createFontInternal(base64String, style);
      } else {
        _this.createFontInternal(base64String, PdfFontStyle.Regular);
      }
      return _this;
    }
    PdfTrueTypeFont2.prototype.equalsToFont = function(font) {
      var result = false;
      return result;
    };
    PdfTrueTypeFont2.prototype.getLineWidth = function(line, format) {
      var width = 0;
      if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
        var returnValue = this.getUnicodeLineWidth(
          line,
          /*out*/
          width,
          format
        );
        width = returnValue.width;
      } else {
        width = this.fontInternal.getLineWidth(line);
      }
      var size = this.metrics.getSize(format);
      width *= PdfFont.charSizeMultiplier * size;
      width = this.applyFormatSettings(line, format, width);
      return width;
    };
    PdfTrueTypeFont2.prototype.getCharWidth = function(charCode, format) {
      var codeWidth = this.fontInternal.getCharWidth(charCode);
      var size = this.metrics.getSize(format);
      codeWidth *= 1e-3 * size;
      return codeWidth;
    };
    PdfTrueTypeFont2.prototype.createFontInternal = function(base64String, style) {
      this.fontInternal = new UnicodeTrueTypeFont(base64String, this.size);
      this.calculateStyle(style);
      this.initializeInternals();
    };
    PdfTrueTypeFont2.prototype.calculateStyle = function(style) {
      var iStyle = this.fontInternal.ttfMetrics.macStyle;
      if ((style & PdfFontStyle.Underline) !== 0) {
        iStyle |= PdfFontStyle.Underline;
      }
      if ((style & PdfFontStyle.Strikeout) !== 0) {
        iStyle |= PdfFontStyle.Strikeout;
      }
      this.setStyle(iStyle);
    };
    PdfTrueTypeFont2.prototype.initializeInternals = function() {
      var equalFont = null;
      if (PdfDocument.enableCache) {
        equalFont = PdfDocument.cache.search(this);
      }
      var internals = null;
      if (equalFont !== null && equalFont !== void 0) {
        internals = equalFont.getInternals();
        var metrics = equalFont.metrics;
        metrics = metrics.clone();
        metrics.size = this.size;
        this.metrics = metrics;
        this.fontInternal = equalFont.fontInternal;
      } else {
        if (equalFont == null) {
          if (this.fontInternal instanceof UnicodeTrueTypeFont) {
            this.fontInternal.isEmbed = this.isEmbedFont;
          }
          this.fontInternal.createInternals();
          internals = this.fontInternal.getInternals();
          this.metrics = this.fontInternal.metrics;
        }
      }
      this.metrics.isUnicodeFont = true;
      this.setInternals(internals);
    };
    PdfTrueTypeFont2.prototype.setSymbols = function(text) {
      var internalFont = this.fontInternal;
      if (internalFont != null) {
        internalFont.setSymbols(text);
      }
    };
    Object.defineProperty(PdfTrueTypeFont2.prototype, "Unicode", {
      /**
       * Property
       *
       */
      get: function() {
        return this.isUnicode;
      },
      enumerable: true,
      configurable: true
    });
    PdfTrueTypeFont2.prototype.getUnicodeLineWidth = function(line, width, format) {
      width = 0;
      var glyphIndices = null;
      var rtlRender = new RtlRenderer();
      var result = rtlRender.getGlyphIndex(
        line,
        this,
        format.textDirection === PdfTextDirection.RightToLeft ? true : false,
        /*out*/
        glyphIndices,
        true
      );
      var resultGlyph = result.success;
      glyphIndices = result.glyphs;
      if (resultGlyph && glyphIndices !== null) {
        var ttfReader = this.fontInternal.ttfReader;
        for (var i = 0, len = glyphIndices.length; i < len; i++) {
          var glyphIndex = glyphIndices[i];
          var glyph = ttfReader.getGlyph(glyphIndex);
          if (glyph !== null && typeof glyph !== "undefined") {
            width += glyph.width;
          }
        }
      }
      return { success: resultGlyph, width };
    };
    return PdfTrueTypeFont2;
  }(PdfFont)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-template-element.js
var PdfPageTemplateElement = (
  /** @class */
  function() {
    function PdfPageTemplateElement2(arg1, arg2, arg3, arg4, arg5) {
      if (arg1 instanceof RectangleF && typeof arg2 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, null);
      } else if (arg1 instanceof RectangleF && arg2 instanceof PdfPage && typeof arg3 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, arg2);
      } else if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, null);
      } else if (arg1 instanceof PointF && arg2 instanceof SizeF && arg3 instanceof PdfPage && typeof arg4 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, arg3);
      } else if (arg1 instanceof SizeF && typeof arg2 === "undefined") {
        this.InitiateBounds(0, 0, arg1.width, arg1.height, null);
      } else if (typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "undefined") {
        this.InitiateBounds(0, 0, arg1, arg2, null);
      } else if (typeof arg1 === "number" && typeof arg2 === "number" && arg3 instanceof PdfPage && typeof arg4 === "undefined") {
        this.InitiateBounds(0, 0, arg1, arg2, arg3);
      } else if (typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "number" && typeof arg5 === "undefined") {
        this.InitiateBounds(arg1, arg2, arg3, arg4, null);
      } else {
        this.InitiateBounds(arg1, arg2, arg3, arg4, null);
      }
    }
    Object.defineProperty(PdfPageTemplateElement2.prototype, "dock", {
      // Properties
      /**
       * Gets or sets the `dock style` of the page template element.
       * @private
       */
      get: function() {
        return this.dockStyle;
      },
      set: function(value) {
        this.dockStyle = value;
        this.resetAlignment();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "alignment", {
      /**
       * Gets or sets `alignment` of the page template element.
       * @private
       */
      get: function() {
        return this.alignmentStyle;
      },
      set: function(value) {
        this.setAlignment(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "foreground", {
      /**
       * Indicates whether the page template is located `in front of the page layers or behind of it`.
       * @private
       */
      get: function() {
        return this.isForeground;
      },
      set: function(value) {
        this.isForeground = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "background", {
      /**
       * Indicates whether the page template is located `behind of the page layers or in front of it`.
       * @private
       */
      get: function() {
        return !this.isForeground;
      },
      set: function(value) {
        this.isForeground = !value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "location", {
      /**
       * Gets or sets `location` of the page template element.
       * @private
       */
      get: function() {
        return this.currentLocation;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.currentLocation = value;
        } else {
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "x", {
      /**
       * Gets or sets `X` co-ordinate of the template element on the page.
       * @private
       */
      get: function() {
        var value = typeof this.currentLocation !== "undefined" ? this.currentLocation.x : 0;
        return value;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.currentLocation.x = value;
        } else {
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "y", {
      /**
       * Gets or sets `Y` co-ordinate of the template element on the page.
       * @private
       */
      get: function() {
        var value = typeof this.currentLocation !== "undefined" ? this.currentLocation.y : 0;
        return value;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.currentLocation.y = value;
        } else {
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "size", {
      /**
       * Gets or sets `size` of the page template element.
       * @private
       */
      get: function() {
        return this.template.size;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.template.reset(value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "width", {
      /**
       * Gets or sets `width` of the page template element.
       * @private
       */
      get: function() {
        return this.template.width;
      },
      set: function(value) {
        if (this.template.width !== value && this.type === TemplateType.None) {
          var size = this.template.size;
          size.width = value;
          this.template.reset(size);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "height", {
      /**
       * Gets or sets `height` of the page template element.
       * @private
       */
      get: function() {
        return this.template.height;
      },
      set: function(value) {
        if (this.template.height !== value && this.type === TemplateType.None) {
          var size = this.template.size;
          size.height = value;
          this.template.reset(size);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "graphics", {
      /**
       * Gets `graphics` context of the page template element.
       * @private
       */
      get: function() {
        return this.template.graphics;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "template", {
      /**
       * Gets Pdf `template` object.
       * @private
       */
      get: function() {
        return this.pdfTemplate;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "type", {
      /**
       * Gets or sets `type` of the usage of this page template.
       * @private
       */
      get: function() {
        return this.templateType;
      },
      set: function(value) {
        this.updateDocking(value);
        this.templateType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "bounds", {
      /**
       * Gets or sets `bounds` of the page template.
       * @public
       */
      get: function() {
        return new RectangleF(new PointF(this.x, this.y), this.size);
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.location = new PointF(value.x, value.y);
          this.size = new SizeF(value.width, value.height);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfPageTemplateElement2.prototype.InitiateBounds = function(arg1, arg2, arg3, arg4, arg5) {
      this.x = arg1;
      this.y = arg2;
      this.pdfTemplate = new PdfTemplate(arg3, arg4);
    };
    PdfPageTemplateElement2.prototype.updateDocking = function(type) {
      if (type !== TemplateType.None) {
        switch (type) {
          case TemplateType.Top:
            this.dock = PdfDockStyle.Top;
            break;
          case TemplateType.Bottom:
            this.dock = PdfDockStyle.Bottom;
            break;
          case TemplateType.Left:
            this.dock = PdfDockStyle.Left;
            break;
          case TemplateType.Right:
            this.dock = PdfDockStyle.Right;
            break;
        }
        this.resetAlignment();
      }
    };
    PdfPageTemplateElement2.prototype.resetAlignment = function() {
      this.alignment = PdfAlignmentStyle.None;
    };
    PdfPageTemplateElement2.prototype.setAlignment = function(alignment) {
      if (this.dock === PdfDockStyle.None) {
        this.alignmentStyle = alignment;
      } else {
        var canBeSet = false;
        switch (this.dock) {
          case PdfDockStyle.Left:
            canBeSet = alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.MiddleLeft || alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Top:
            canBeSet = alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.TopCenter || alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Right:
            canBeSet = alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.MiddleRight || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Bottom:
            canBeSet = alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.BottomCenter || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Fill:
            canBeSet = alignment === PdfAlignmentStyle.MiddleCenter || alignment === PdfAlignmentStyle.None;
            break;
        }
        if (canBeSet) {
          this.alignmentStyle = alignment;
        }
      }
    };
    PdfPageTemplateElement2.prototype.draw = function(layer, document2) {
      var page = layer.page;
      var bounds = this.calculateBounds(page, document2);
      if (bounds.x === -0) {
        bounds.x = 0;
      }
      layer.graphics.drawPdfTemplate(this.template, new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));
    };
    PdfPageTemplateElement2.prototype.calculateBounds = function(page, document2) {
      var result = this.bounds;
      if (this.alignmentStyle !== PdfAlignmentStyle.None) {
        result = this.getAlignmentBounds(page, document2);
      } else if (this.dockStyle !== PdfDockStyle.None) {
        result = this.getDockBounds(page, document2);
      }
      return result;
    };
    PdfPageTemplateElement2.prototype.getAlignmentBounds = function(page, document2) {
      var result = this.bounds;
      if (this.type === TemplateType.None) {
        result = this.getSimpleAlignmentBounds(page, document2);
      } else {
        result = this.getTemplateAlignmentBounds(page, document2);
      }
      return result;
    };
    PdfPageTemplateElement2.prototype.getSimpleAlignmentBounds = function(page, document2) {
      var bounds = this.bounds;
      var pdfSection = page.section;
      var actualBounds = pdfSection.getActualBounds(document2, page, false);
      var x = this.x;
      var y = this.y;
      switch (this.alignmentStyle) {
        case PdfAlignmentStyle.TopLeft:
          x = 0;
          y = 0;
          break;
        case PdfAlignmentStyle.TopCenter:
          x = (actualBounds.width - this.width) / 2;
          y = 0;
          break;
        case PdfAlignmentStyle.TopRight:
          x = actualBounds.width - this.width;
          y = 0;
          break;
        case PdfAlignmentStyle.MiddleLeft:
          x = 0;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleCenter:
          x = (actualBounds.width - this.width) / 2;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleRight:
          x = actualBounds.width - this.width;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.BottomLeft:
          x = 0;
          y = actualBounds.height - this.height;
          break;
        case PdfAlignmentStyle.BottomCenter:
          x = (actualBounds.width - this.width) / 2;
          y = actualBounds.height - this.height;
          break;
        case PdfAlignmentStyle.BottomRight:
          x = actualBounds.width - this.width;
          y = actualBounds.height - this.height;
          break;
      }
      bounds.x = x;
      bounds.y = y;
      return bounds;
    };
    PdfPageTemplateElement2.prototype.getTemplateAlignmentBounds = function(page, document2) {
      var result = this.bounds;
      var section = page.section;
      var actualBounds = section.getActualBounds(document2, page, false);
      var x = this.x;
      var y = this.y;
      switch (this.alignmentStyle) {
        case PdfAlignmentStyle.TopLeft:
          if (this.type === TemplateType.Left) {
            x = -actualBounds.x;
            y = 0;
          } else if (this.type === TemplateType.Top) {
            x = -actualBounds.x;
            y = -actualBounds.y;
          }
          break;
        case PdfAlignmentStyle.TopCenter:
          x = (actualBounds.width - this.width) / 2;
          y = -actualBounds.y;
          break;
        case PdfAlignmentStyle.TopRight:
          if (this.type === TemplateType.Right) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = 0;
          } else if (this.type === TemplateType.Top) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = -actualBounds.y;
          }
          break;
        case PdfAlignmentStyle.MiddleLeft:
          x = -actualBounds.x;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleCenter:
          x = (actualBounds.width - this.width) / 2;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleRight:
          x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.BottomLeft:
          if (this.type === TemplateType.Left) {
            x = -actualBounds.x;
            y = actualBounds.height - this.height;
          } else if (this.type === TemplateType.Bottom) {
            x = -actualBounds.x;
            y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          }
          break;
        case PdfAlignmentStyle.BottomCenter:
          x = (actualBounds.width - this.width) / 2;
          y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          break;
        case PdfAlignmentStyle.BottomRight:
          if (this.type === TemplateType.Right) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = actualBounds.height - this.height;
          } else if (this.type === TemplateType.Bottom) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          }
          break;
      }
      result.x = x;
      result.y = y;
      return result;
    };
    PdfPageTemplateElement2.prototype.getDockBounds = function(page, document2) {
      var result = this.bounds;
      if (this.type === TemplateType.None) {
        result = this.getSimpleDockBounds(page, document2);
      } else {
        result = this.getTemplateDockBounds(page, document2);
      }
      return result;
    };
    PdfPageTemplateElement2.prototype.getSimpleDockBounds = function(page, document2) {
      var result = this.bounds;
      var section = page.section;
      var actualBounds = section.getActualBounds(document2, page, false);
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      switch (this.dockStyle) {
        case PdfDockStyle.Left:
          x = 0;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Top:
          x = 0;
          y = 0;
          width = actualBounds.width;
          height = this.height;
          break;
        case PdfDockStyle.Right:
          x = actualBounds.width - this.width;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Bottom:
          x = 0;
          y = actualBounds.height - this.height;
          width = actualBounds.width;
          height = this.height;
          break;
        case PdfDockStyle.Fill:
          x = 0;
          x = 0;
          width = actualBounds.width;
          height = actualBounds.height;
          break;
      }
      result = new RectangleF(x, y, width, height);
      return result;
    };
    PdfPageTemplateElement2.prototype.getTemplateDockBounds = function(page, document2) {
      var result = this.bounds;
      var section = page.section;
      var actualBounds = section.getActualBounds(document2, page, false);
      var actualSize = section.pageSettings.getActualSize();
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      switch (this.dockStyle) {
        case PdfDockStyle.Left:
          x = -actualBounds.x;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Top:
          x = -actualBounds.x;
          y = -actualBounds.y;
          width = actualSize.width;
          height = this.height;
          if (actualBounds.height < 0) {
            y = -actualBounds.y + actualSize.height;
          }
          break;
        case PdfDockStyle.Right:
          x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Bottom:
          x = -actualBounds.x;
          y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          width = actualSize.width;
          height = this.height;
          if (actualBounds.height < 0) {
            y -= actualSize.height;
          }
          break;
        case PdfDockStyle.Fill:
          x = 0;
          x = 0;
          width = actualBounds.width;
          height = actualBounds.height;
          break;
      }
      result = new RectangleF(x, y, width, height);
      return result;
    };
    return PdfPageTemplateElement2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/document-link-annotation.js
var __extends31 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfDocumentLinkAnnotation = (
  /** @class */
  function(_super) {
    __extends31(PdfDocumentLinkAnnotation2, _super);
    function PdfDocumentLinkAnnotation2(rectangle, destination) {
      var _this = _super.call(this, rectangle) || this;
      _this.pdfDestination = null;
      if (typeof destination !== "undefined") {
        _this.destination = destination;
      }
      return _this;
    }
    Object.defineProperty(PdfDocumentLinkAnnotation2.prototype, "destination", {
      // Properties
      /**
       * Gets or sets the `destination` of the annotation.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // create new pages
       * let page1 : PdfPage = document.pages.add();
       * let page2 : PdfPage = document.pages.add();
       * // create a new rectangle
       * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});
       * //
       * // create a new document link annotation
       * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);
       * // set the annotation text
       * documentLinkAnnotation.text = 'Document link annotation';
       * // set the destination
       * documentLinkAnnotation.destination = new PdfDestination(page2);
       * // set the documentlink annotation location
       * documentLinkAnnotation.destination.location = new PointF(10, 0);
       * // add this annotation to a new page
       * page1.annotations.add(documentLinkAnnotation);
       * //
       * // save the document to disk
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       * @default null
       */
      get: function() {
        return this.pdfDestination;
      },
      set: function(value) {
        this.pdfDestination = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentLinkAnnotation2.prototype.save = function() {
      _super.prototype.save.call(this);
      if (this.pdfDestination != null) {
        this.dictionary.items.setValue(this.dictionaryProperties.dest, this.pdfDestination.element);
      }
    };
    PdfDocumentLinkAnnotation2.prototype.clone = function() {
      var annot = new PdfDocumentLinkAnnotation2(this.bounds, this.destination);
      annot.color = this.color;
      annot.brush = this.brush;
      annot.destination = this.destination;
      annot.font = this.font;
      return annot;
    };
    return PdfDocumentLinkAnnotation2;
  }(PdfLinkAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/enum.js
var PdfDestinationMode;
(function(PdfDestinationMode2) {
  PdfDestinationMode2[PdfDestinationMode2["Location"] = 0] = "Location";
  PdfDestinationMode2[PdfDestinationMode2["FitToPage"] = 1] = "FitToPage";
  PdfDestinationMode2[PdfDestinationMode2["FitR"] = 2] = "FitR";
})(PdfDestinationMode || (PdfDestinationMode = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/pdf-destination.js
var PdfDestination = (
  /** @class */
  function() {
    function PdfDestination2(arg1, arg2) {
      this.dictionaryProperties = new DictionaryProperties();
      this.destinationMode = PdfDestinationMode.Location;
      this.zoomFactor = 0;
      this.destinationLocation = new PointF(0, 0);
      this.bounds = new RectangleF();
      this.array = new PdfArray();
      var angle = PdfPageRotateAngle.RotateAngle0;
      this.destinationLocation = new PointF(0, this.destinationLocation.y);
      this.pdfPage = arg1;
      if (arg2 instanceof PointF) {
        this.destinationLocation = arg2;
      } else {
        this.bounds = arg2;
      }
    }
    Object.defineProperty(PdfDestination2.prototype, "zoom", {
      // Properties
      /**
       * Gets and Sets the `zoom` factor.
       * @private
       */
      get: function() {
        return this.zoomFactor;
      },
      set: function(value) {
        this.zoomFactor = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDestination2.prototype, "page", {
      /**
       * Gets and Sets the `page` object.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      set: function(value) {
        this.pdfPage = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDestination2.prototype, "mode", {
      /**
       * Gets and Sets the destination `mode`.
       * @private
       */
      get: function() {
        return this.destinationMode;
      },
      set: function(value) {
        this.destinationMode = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDestination2.prototype, "location", {
      /**
       * Gets and Sets the `location`.
       * @private
       */
      get: function() {
        return this.destinationLocation;
      },
      set: function(value) {
        this.destinationLocation = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    PdfDestination2.prototype.pointToNativePdf = function(page, point) {
      var section = page.section;
      return section.pointToNativePdf(page, point);
    };
    PdfDestination2.prototype.initializePrimitive = function() {
      this.array.clear();
      this.array.add(new PdfReferenceHolder(this.pdfPage));
      switch (this.destinationMode) {
        case PdfDestinationMode.Location:
          var simplePage = this.pdfPage;
          var point = new PointF();
          point = this.pointToNativePdf(simplePage, this.destinationLocation);
          this.array.add(new PdfName(this.dictionaryProperties.xyz));
          this.array.add(new PdfNumber(point.x));
          this.array.add(new PdfNumber(point.y));
          this.array.add(new PdfNumber(this.zoomFactor));
          break;
        case PdfDestinationMode.FitToPage:
          this.array.add(new PdfName(this.dictionaryProperties.fit));
          break;
      }
    };
    Object.defineProperty(PdfDestination2.prototype, "element", {
      /**
       * Gets the `element` representing this object.
       * @private
       */
      get: function() {
        this.initializePrimitive();
        return this.array;
      },
      enumerable: true,
      configurable: true
    });
    return PdfDestination2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/functions/pdf-function.js
var PdfFunction = (
  /** @class */
  function() {
    function PdfFunction2(dictionary) {
      this.mDictionary = null;
      this.mDictionaryProperties = new DictionaryProperties();
      this.mDictionary = dictionary;
    }
    Object.defineProperty(PdfFunction2.prototype, "domain", {
      //Properties
      /**
       * Gets or sets the domain of the function.
       * @public
       */
      get: function() {
        var domain = this.mDictionary.items.getValue(this.mDictionaryProperties.domain);
        return domain;
      },
      set: function(value) {
        this.mDictionary.items.setValue(this.mDictionaryProperties.domain, value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFunction2.prototype, "range", {
      /**
       * Gets or sets the range.
       * @public
       */
      get: function() {
        var range = this.mDictionary.items.getValue(this.mDictionaryProperties.range);
        return range;
      },
      set: function(value) {
        this.mDictionary.items.setValue(this.mDictionaryProperties.range, value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFunction2.prototype, "dictionary", {
      /**
       * Gets the dictionary.
       */
      get: function() {
        return this.mDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFunction2.prototype, "element", {
      //IPdfWrapper Members
      /**
       * Gets the element.
       */
      get: function() {
        return this.mDictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfFunction2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/functions/pdf-sampled-function.js
var __extends32 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfSampledFunction = (
  /** @class */
  function(_super) {
    __extends32(PdfSampledFunction2, _super);
    function PdfSampledFunction2(domain, range, sizes, samples) {
      var _this = _super.call(this, new PdfStream()) || this;
      if (typeof domain === "undefined") {
        _this.dictionary.items.setValue(_this.mDictionaryProperties.functionType, new PdfNumber(0));
      } else {
        _this.dictionary.items.setValue(_this.mDictionaryProperties.functionType, new PdfNumber(0));
        _this.checkParams(domain, range, sizes, samples);
        _this.setDomainAndRange(domain, range);
        _this.setSizeAndValues(sizes, samples);
      }
      return _this;
    }
    PdfSampledFunction2.prototype.checkParams = function(domain, range, sizes, samples) {
      var rLength = range.length;
      var dLength = domain.length;
      var sLength = samples.length;
      var frameLength = rLength * (dLength / 4);
    };
    PdfSampledFunction2.prototype.setDomainAndRange = function(domain, range) {
      this.domain = new PdfArray(domain);
      this.range = new PdfArray(range);
    };
    PdfSampledFunction2.prototype.setSizeAndValues = function(sizes, samples) {
      var s = this.dictionary;
      this.dictionary.items.setValue(this.mDictionaryProperties.size, new PdfArray(sizes));
      this.dictionary.items.setValue(this.mDictionaryProperties.bitsPerSample, new PdfNumber(8));
      s.writeBytes(samples);
    };
    return PdfSampledFunction2;
  }(PdfFunction)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/enum.js
var PdfExtend;
(function(PdfExtend2) {
  PdfExtend2[PdfExtend2["None"] = 0] = "None";
  PdfExtend2[PdfExtend2["Start"] = 1] = "Start";
  PdfExtend2[PdfExtend2["End"] = 2] = "End";
  PdfExtend2[PdfExtend2["Both"] = 3] = "Both";
})(PdfExtend || (PdfExtend = {}));
var PdfLinearGradientMode;
(function(PdfLinearGradientMode2) {
  PdfLinearGradientMode2[PdfLinearGradientMode2["BackwardDiagonal"] = 0] = "BackwardDiagonal";
  PdfLinearGradientMode2[PdfLinearGradientMode2["ForwardDiagonal"] = 1] = "ForwardDiagonal";
  PdfLinearGradientMode2[PdfLinearGradientMode2["Horizontal"] = 2] = "Horizontal";
  PdfLinearGradientMode2[PdfLinearGradientMode2["Vertical"] = 3] = "Vertical";
})(PdfLinearGradientMode || (PdfLinearGradientMode = {}));
var ShadingType;
(function(ShadingType2) {
  ShadingType2[ShadingType2["Function"] = 1] = "Function";
  ShadingType2[ShadingType2["Axial"] = 2] = "Axial";
  ShadingType2[ShadingType2["Radial"] = 3] = "Radial";
})(ShadingType || (ShadingType = {}));
var KnownColor;
(function(KnownColor2) {
  KnownColor2[KnownColor2["ActiveBorder"] = 1] = "ActiveBorder";
  KnownColor2[KnownColor2["ActiveCaption"] = 2] = "ActiveCaption";
  KnownColor2[KnownColor2["ActiveCaptionText"] = 3] = "ActiveCaptionText";
  KnownColor2[KnownColor2["AppWorkspace"] = 4] = "AppWorkspace";
  KnownColor2[KnownColor2["Control"] = 5] = "Control";
  KnownColor2[KnownColor2["ControlDark"] = 6] = "ControlDark";
  KnownColor2[KnownColor2["ControlDarkDark"] = 7] = "ControlDarkDark";
  KnownColor2[KnownColor2["ControlLight"] = 8] = "ControlLight";
  KnownColor2[KnownColor2["ControlLightLight"] = 9] = "ControlLightLight";
  KnownColor2[KnownColor2["ControlText"] = 10] = "ControlText";
  KnownColor2[KnownColor2["Desktop"] = 11] = "Desktop";
  KnownColor2[KnownColor2["GrayText"] = 12] = "GrayText";
  KnownColor2[KnownColor2["Highlight"] = 13] = "Highlight";
  KnownColor2[KnownColor2["HighlightText"] = 14] = "HighlightText";
  KnownColor2[KnownColor2["HotTrack"] = 15] = "HotTrack";
  KnownColor2[KnownColor2["InactiveBorder"] = 16] = "InactiveBorder";
  KnownColor2[KnownColor2["InactiveCaption"] = 17] = "InactiveCaption";
  KnownColor2[KnownColor2["InactiveCaptionText"] = 18] = "InactiveCaptionText";
  KnownColor2[KnownColor2["Info"] = 19] = "Info";
  KnownColor2[KnownColor2["InfoText"] = 20] = "InfoText";
  KnownColor2[KnownColor2["Menu"] = 21] = "Menu";
  KnownColor2[KnownColor2["MenuText"] = 22] = "MenuText";
  KnownColor2[KnownColor2["ScrollBar"] = 23] = "ScrollBar";
  KnownColor2[KnownColor2["Window"] = 24] = "Window";
  KnownColor2[KnownColor2["WindowFrame"] = 25] = "WindowFrame";
  KnownColor2[KnownColor2["WindowText"] = 26] = "WindowText";
  KnownColor2[KnownColor2["Transparent"] = 27] = "Transparent";
  KnownColor2[KnownColor2["AliceBlue"] = 28] = "AliceBlue";
  KnownColor2[KnownColor2["AntiqueWhite"] = 29] = "AntiqueWhite";
  KnownColor2[KnownColor2["Aqua"] = 30] = "Aqua";
  KnownColor2[KnownColor2["Aquamarine"] = 31] = "Aquamarine";
  KnownColor2[KnownColor2["Azure"] = 32] = "Azure";
  KnownColor2[KnownColor2["Beige"] = 33] = "Beige";
  KnownColor2[KnownColor2["Bisque"] = 34] = "Bisque";
  KnownColor2[KnownColor2["Black"] = 35] = "Black";
  KnownColor2[KnownColor2["BlanchedAlmond"] = 36] = "BlanchedAlmond";
  KnownColor2[KnownColor2["Blue"] = 37] = "Blue";
  KnownColor2[KnownColor2["BlueViolet"] = 38] = "BlueViolet";
  KnownColor2[KnownColor2["Brown"] = 39] = "Brown";
  KnownColor2[KnownColor2["BurlyWood"] = 40] = "BurlyWood";
  KnownColor2[KnownColor2["CadetBlue"] = 41] = "CadetBlue";
  KnownColor2[KnownColor2["Chartreuse"] = 42] = "Chartreuse";
  KnownColor2[KnownColor2["Chocolate"] = 43] = "Chocolate";
  KnownColor2[KnownColor2["Coral"] = 44] = "Coral";
  KnownColor2[KnownColor2["CornflowerBlue"] = 45] = "CornflowerBlue";
  KnownColor2[KnownColor2["Cornsilk"] = 46] = "Cornsilk";
  KnownColor2[KnownColor2["Crimson"] = 47] = "Crimson";
  KnownColor2[KnownColor2["Cyan"] = 48] = "Cyan";
  KnownColor2[KnownColor2["DarkBlue"] = 49] = "DarkBlue";
  KnownColor2[KnownColor2["DarkCyan"] = 50] = "DarkCyan";
  KnownColor2[KnownColor2["DarkGoldenrod"] = 51] = "DarkGoldenrod";
  KnownColor2[KnownColor2["DarkGray"] = 52] = "DarkGray";
  KnownColor2[KnownColor2["DarkGreen"] = 53] = "DarkGreen";
  KnownColor2[KnownColor2["DarkKhaki"] = 54] = "DarkKhaki";
  KnownColor2[KnownColor2["DarkMagenta"] = 55] = "DarkMagenta";
  KnownColor2[KnownColor2["DarkOliveGreen"] = 56] = "DarkOliveGreen";
  KnownColor2[KnownColor2["DarkOrange"] = 57] = "DarkOrange";
  KnownColor2[KnownColor2["DarkOrchid"] = 58] = "DarkOrchid";
  KnownColor2[KnownColor2["DarkRed"] = 59] = "DarkRed";
  KnownColor2[KnownColor2["DarkSalmon"] = 60] = "DarkSalmon";
  KnownColor2[KnownColor2["DarkSeaGreen"] = 61] = "DarkSeaGreen";
  KnownColor2[KnownColor2["DarkSlateBlue"] = 62] = "DarkSlateBlue";
  KnownColor2[KnownColor2["DarkSlateGray"] = 63] = "DarkSlateGray";
  KnownColor2[KnownColor2["DarkTurquoise"] = 64] = "DarkTurquoise";
  KnownColor2[KnownColor2["DarkViolet"] = 65] = "DarkViolet";
  KnownColor2[KnownColor2["DeepPink"] = 66] = "DeepPink";
  KnownColor2[KnownColor2["DeepSkyBlue"] = 67] = "DeepSkyBlue";
  KnownColor2[KnownColor2["DimGray"] = 68] = "DimGray";
  KnownColor2[KnownColor2["DodgerBlue"] = 69] = "DodgerBlue";
  KnownColor2[KnownColor2["Firebrick"] = 70] = "Firebrick";
  KnownColor2[KnownColor2["FloralWhite"] = 71] = "FloralWhite";
  KnownColor2[KnownColor2["ForestGreen"] = 72] = "ForestGreen";
  KnownColor2[KnownColor2["Fuchsia"] = 73] = "Fuchsia";
  KnownColor2[KnownColor2["Gainsboro"] = 74] = "Gainsboro";
  KnownColor2[KnownColor2["GhostWhite"] = 75] = "GhostWhite";
  KnownColor2[KnownColor2["Gold"] = 76] = "Gold";
  KnownColor2[KnownColor2["Goldenrod"] = 77] = "Goldenrod";
  KnownColor2[KnownColor2["Gray"] = 78] = "Gray";
  KnownColor2[KnownColor2["Green"] = 79] = "Green";
  KnownColor2[KnownColor2["GreenYellow"] = 80] = "GreenYellow";
  KnownColor2[KnownColor2["Honeydew"] = 81] = "Honeydew";
  KnownColor2[KnownColor2["HotPink"] = 82] = "HotPink";
  KnownColor2[KnownColor2["IndianRed"] = 83] = "IndianRed";
  KnownColor2[KnownColor2["Indigo"] = 84] = "Indigo";
  KnownColor2[KnownColor2["Ivory"] = 85] = "Ivory";
  KnownColor2[KnownColor2["Khaki"] = 86] = "Khaki";
  KnownColor2[KnownColor2["Lavender"] = 87] = "Lavender";
  KnownColor2[KnownColor2["LavenderBlush"] = 88] = "LavenderBlush";
  KnownColor2[KnownColor2["LawnGreen"] = 89] = "LawnGreen";
  KnownColor2[KnownColor2["LemonChiffon"] = 90] = "LemonChiffon";
  KnownColor2[KnownColor2["LightBlue"] = 91] = "LightBlue";
  KnownColor2[KnownColor2["LightCoral"] = 92] = "LightCoral";
  KnownColor2[KnownColor2["LightCyan"] = 93] = "LightCyan";
  KnownColor2[KnownColor2["LightGoldenrodYellow"] = 94] = "LightGoldenrodYellow";
  KnownColor2[KnownColor2["LightGray"] = 95] = "LightGray";
  KnownColor2[KnownColor2["LightGreen"] = 96] = "LightGreen";
  KnownColor2[KnownColor2["LightPink"] = 97] = "LightPink";
  KnownColor2[KnownColor2["LightSalmon"] = 98] = "LightSalmon";
  KnownColor2[KnownColor2["LightSeaGreen"] = 99] = "LightSeaGreen";
  KnownColor2[KnownColor2["LightSkyBlue"] = 100] = "LightSkyBlue";
  KnownColor2[KnownColor2["LightSlateGray"] = 101] = "LightSlateGray";
  KnownColor2[KnownColor2["LightSteelBlue"] = 102] = "LightSteelBlue";
  KnownColor2[KnownColor2["LightYellow"] = 103] = "LightYellow";
  KnownColor2[KnownColor2["Lime"] = 104] = "Lime";
  KnownColor2[KnownColor2["LimeGreen"] = 105] = "LimeGreen";
  KnownColor2[KnownColor2["Linen"] = 106] = "Linen";
  KnownColor2[KnownColor2["Magenta"] = 107] = "Magenta";
  KnownColor2[KnownColor2["Maroon"] = 108] = "Maroon";
  KnownColor2[KnownColor2["MediumAquamarine"] = 109] = "MediumAquamarine";
  KnownColor2[KnownColor2["MediumBlue"] = 110] = "MediumBlue";
  KnownColor2[KnownColor2["MediumOrchid"] = 111] = "MediumOrchid";
  KnownColor2[KnownColor2["MediumPurple"] = 112] = "MediumPurple";
  KnownColor2[KnownColor2["MediumSeaGreen"] = 113] = "MediumSeaGreen";
  KnownColor2[KnownColor2["MediumSlateBlue"] = 114] = "MediumSlateBlue";
  KnownColor2[KnownColor2["MediumSpringGreen"] = 115] = "MediumSpringGreen";
  KnownColor2[KnownColor2["MediumTurquoise"] = 116] = "MediumTurquoise";
  KnownColor2[KnownColor2["MediumVioletRed"] = 117] = "MediumVioletRed";
  KnownColor2[KnownColor2["MidnightBlue"] = 118] = "MidnightBlue";
  KnownColor2[KnownColor2["MintCream"] = 119] = "MintCream";
  KnownColor2[KnownColor2["MistyRose"] = 120] = "MistyRose";
  KnownColor2[KnownColor2["Moccasin"] = 121] = "Moccasin";
  KnownColor2[KnownColor2["NavajoWhite"] = 122] = "NavajoWhite";
  KnownColor2[KnownColor2["Navy"] = 123] = "Navy";
  KnownColor2[KnownColor2["OldLace"] = 124] = "OldLace";
  KnownColor2[KnownColor2["Olive"] = 125] = "Olive";
  KnownColor2[KnownColor2["OliveDrab"] = 126] = "OliveDrab";
  KnownColor2[KnownColor2["Orange"] = 127] = "Orange";
  KnownColor2[KnownColor2["OrangeRed"] = 128] = "OrangeRed";
  KnownColor2[KnownColor2["Orchid"] = 129] = "Orchid";
  KnownColor2[KnownColor2["PaleGoldenrod"] = 130] = "PaleGoldenrod";
  KnownColor2[KnownColor2["PaleGreen"] = 131] = "PaleGreen";
  KnownColor2[KnownColor2["PaleTurquoise"] = 132] = "PaleTurquoise";
  KnownColor2[KnownColor2["PaleVioletRed"] = 133] = "PaleVioletRed";
  KnownColor2[KnownColor2["PapayaWhip"] = 134] = "PapayaWhip";
  KnownColor2[KnownColor2["PeachPuff"] = 135] = "PeachPuff";
  KnownColor2[KnownColor2["Peru"] = 136] = "Peru";
  KnownColor2[KnownColor2["Pink"] = 137] = "Pink";
  KnownColor2[KnownColor2["Plum"] = 138] = "Plum";
  KnownColor2[KnownColor2["PowderBlue"] = 139] = "PowderBlue";
  KnownColor2[KnownColor2["Purple"] = 140] = "Purple";
  KnownColor2[KnownColor2["Red"] = 141] = "Red";
  KnownColor2[KnownColor2["RosyBrown"] = 142] = "RosyBrown";
  KnownColor2[KnownColor2["RoyalBlue"] = 143] = "RoyalBlue";
  KnownColor2[KnownColor2["SaddleBrown"] = 144] = "SaddleBrown";
  KnownColor2[KnownColor2["Salmon"] = 145] = "Salmon";
  KnownColor2[KnownColor2["SandyBrown"] = 146] = "SandyBrown";
  KnownColor2[KnownColor2["SeaGreen"] = 147] = "SeaGreen";
  KnownColor2[KnownColor2["SeaShell"] = 148] = "SeaShell";
  KnownColor2[KnownColor2["Sienna"] = 149] = "Sienna";
  KnownColor2[KnownColor2["Silver"] = 150] = "Silver";
  KnownColor2[KnownColor2["SkyBlue"] = 151] = "SkyBlue";
  KnownColor2[KnownColor2["SlateBlue"] = 152] = "SlateBlue";
  KnownColor2[KnownColor2["SlateGray"] = 153] = "SlateGray";
  KnownColor2[KnownColor2["Snow"] = 154] = "Snow";
  KnownColor2[KnownColor2["SpringGreen"] = 155] = "SpringGreen";
  KnownColor2[KnownColor2["SteelBlue"] = 156] = "SteelBlue";
  KnownColor2[KnownColor2["Tan"] = 157] = "Tan";
  KnownColor2[KnownColor2["Teal"] = 158] = "Teal";
  KnownColor2[KnownColor2["Thistle"] = 159] = "Thistle";
  KnownColor2[KnownColor2["Tomato"] = 160] = "Tomato";
  KnownColor2[KnownColor2["Turquoise"] = 161] = "Turquoise";
  KnownColor2[KnownColor2["Violet"] = 162] = "Violet";
  KnownColor2[KnownColor2["Wheat"] = 163] = "Wheat";
  KnownColor2[KnownColor2["White"] = 164] = "White";
  KnownColor2[KnownColor2["WhiteSmoke"] = 165] = "WhiteSmoke";
  KnownColor2[KnownColor2["Yellow"] = 166] = "Yellow";
  KnownColor2[KnownColor2["YellowGreen"] = 167] = "YellowGreen";
  KnownColor2[KnownColor2["ButtonFace"] = 168] = "ButtonFace";
  KnownColor2[KnownColor2["ButtonHighlight"] = 169] = "ButtonHighlight";
  KnownColor2[KnownColor2["ButtonShadow"] = 170] = "ButtonShadow";
  KnownColor2[KnownColor2["GradientActiveCaption"] = 171] = "GradientActiveCaption";
  KnownColor2[KnownColor2["GradientInactiveCaption"] = 172] = "GradientInactiveCaption";
  KnownColor2[KnownColor2["MenuBar"] = 173] = "MenuBar";
  KnownColor2[KnownColor2["MenuHighlight"] = 174] = "MenuHighlight";
})(KnownColor || (KnownColor = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-brushes.js
var PdfBrushes = (
  /** @class */
  function() {
    function PdfBrushes2() {
    }
    Object.defineProperty(PdfBrushes2, "AliceBlue", {
      //Static Properties
      /**
       * Gets the AliceBlue brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.AliceBlue)) {
          brush = this.sBrushes.getValue(KnownColor.AliceBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.AliceBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "AntiqueWhite", {
      /**
       * Gets the antique white brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.AntiqueWhite)) {
          brush = this.sBrushes.getValue(KnownColor.AntiqueWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.AntiqueWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Aqua", {
      /**
       * Gets the Aqua default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Aqua)) {
          brush = this.sBrushes.getValue(KnownColor.Aqua);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Aqua);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Aquamarine", {
      /**
       * Gets the Aquamarine default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Aquamarine)) {
          brush = this.sBrushes.getValue(KnownColor.Aquamarine);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Aquamarine);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Azure", {
      /**
       * Gets the Azure default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Azure)) {
          brush = this.sBrushes.getValue(KnownColor.Azure);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Azure);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Beige", {
      /**
       * Gets the Beige default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Beige)) {
          brush = this.sBrushes.getValue(KnownColor.Beige);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Beige);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Bisque", {
      /**
       * Gets the Bisque default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Bisque)) {
          brush = this.sBrushes.getValue(KnownColor.Bisque);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Bisque);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Black", {
      /**
       * Gets the Black default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Black)) {
          brush = this.sBrushes.getValue(KnownColor.Black);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Black);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "BlanchedAlmond", {
      /**
       * Gets the BlanchedAlmond default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.BlanchedAlmond)) {
          brush = this.sBrushes.getValue(KnownColor.BlanchedAlmond);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.BlanchedAlmond);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Blue", {
      /**
       * Gets the Blue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Blue)) {
          brush = this.sBrushes.getValue(KnownColor.Blue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Blue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "BlueViolet", {
      /**
       * Gets the BlueViolet default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.BlueViolet)) {
          brush = this.sBrushes.getValue(KnownColor.BlueViolet);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.BlueViolet);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Brown", {
      /**
       * Gets the Brown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Brown)) {
          brush = this.sBrushes.getValue(KnownColor.Brown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Brown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "BurlyWood", {
      /**
       * Gets the BurlyWood default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.BurlyWood)) {
          brush = this.sBrushes.getValue(KnownColor.BurlyWood);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.BurlyWood);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "CadetBlue", {
      /**
       * Gets the CadetBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.CadetBlue)) {
          brush = this.sBrushes.getValue(KnownColor.CadetBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.CadetBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Chartreuse", {
      /**
       * Gets the Chartreuse default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Chartreuse)) {
          brush = this.sBrushes.getValue(KnownColor.Chartreuse);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Chartreuse);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Chocolate", {
      /**
       * Gets the Chocolate default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Chocolate)) {
          brush = this.sBrushes.getValue(KnownColor.Chocolate);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Chocolate);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Coral", {
      /**
       * Gets the Coral default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Coral)) {
          brush = this.sBrushes.getValue(KnownColor.Coral);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Coral);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "CornflowerBlue", {
      /**
       * Gets the CornflowerBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.CornflowerBlue)) {
          brush = this.sBrushes.getValue(KnownColor.CornflowerBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.CornflowerBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Cornsilk", {
      /**
       * Gets the Corn silk default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Cornsilk)) {
          brush = this.sBrushes.getValue(KnownColor.Cornsilk);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Cornsilk);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Crimson", {
      /**
       *  Gets the Crimson default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Crimson)) {
          brush = this.sBrushes.getValue(KnownColor.Crimson);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Crimson);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Cyan", {
      /**
       * Gets the Cyan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Cyan)) {
          brush = this.sBrushes.getValue(KnownColor.Cyan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Cyan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkBlue", {
      /**
       * Gets the DarkBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DarkBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkCyan", {
      /**
       * Gets the DarkCyan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkCyan)) {
          brush = this.sBrushes.getValue(KnownColor.DarkCyan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkCyan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkGoldenrod", {
      /**
       * Gets the DarkGoldenrod default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkGoldenrod)) {
          brush = this.sBrushes.getValue(KnownColor.DarkGoldenrod);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkGoldenrod);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkGray", {
      /**
       * Gets the DarkGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkGray)) {
          brush = this.sBrushes.getValue(KnownColor.DarkGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkGreen", {
      /**
       * Gets the DarkGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkGreen)) {
          brush = this.sBrushes.getValue(KnownColor.DarkGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkKhaki", {
      /**
       * Gets the DarkKhaki default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkKhaki)) {
          brush = this.sBrushes.getValue(KnownColor.DarkKhaki);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkKhaki);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkMagenta", {
      /**
       * Gets the DarkMagenta default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkMagenta)) {
          brush = this.sBrushes.getValue(KnownColor.DarkMagenta);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkMagenta);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkOliveGreen", {
      /**
       * Gets the DarkOliveGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkOliveGreen)) {
          brush = this.sBrushes.getValue(KnownColor.DarkOliveGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkOliveGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkOrange", {
      /**
       * Gets the DarkOrange default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkOrange)) {
          brush = this.sBrushes.getValue(KnownColor.DarkOrange);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkOrange);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkOrchid", {
      /**
       * Gets the DarkOrchid default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkOrchid)) {
          brush = this.sBrushes.getValue(KnownColor.DarkOrchid);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkOrchid);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkRed", {
      /**
       * Gets the DarkRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkRed)) {
          brush = this.sBrushes.getValue(KnownColor.DarkRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSalmon", {
      /**
       * Gets the DarkSalmon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSalmon)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSalmon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSalmon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSeaGreen", {
      /**
       * Gets the DarkSeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSlateBlue", {
      /**
       * Gets the DarkSlateBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSlateBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSlateBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSlateBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSlateGray", {
      /**
       * Gets the DarkSlateGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSlateGray)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSlateGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSlateGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkTurquoise", {
      /**
       * Gets the DarkTurquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkTurquoise)) {
          brush = this.sBrushes.getValue(KnownColor.DarkTurquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkTurquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkViolet", {
      /**
       * Gets the DarkViolet default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkViolet)) {
          brush = this.sBrushes.getValue(KnownColor.DarkViolet);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkViolet);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DeepPink", {
      /**
       * Gets the DeepPink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DeepPink)) {
          brush = this.sBrushes.getValue(KnownColor.DeepPink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DeepPink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DeepSkyBlue", {
      /**
       * Gets the DeepSkyBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DeepSkyBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DeepSkyBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DeepSkyBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DimGray", {
      /**
       * Gets the DimGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DimGray)) {
          brush = this.sBrushes.getValue(KnownColor.DimGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DimGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DodgerBlue", {
      /**
       * Gets the DodgerBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DodgerBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DodgerBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DodgerBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Firebrick", {
      /**
       * Gets the Firebrick default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Firebrick)) {
          brush = this.sBrushes.getValue(KnownColor.Firebrick);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Firebrick);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "FloralWhite", {
      /**
       * Gets the FloralWhite default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.FloralWhite)) {
          brush = this.sBrushes.getValue(KnownColor.FloralWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.FloralWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "ForestGreen", {
      /**
       * Gets the ForestGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.ForestGreen)) {
          brush = this.sBrushes.getValue(KnownColor.ForestGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.ForestGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Fuchsia", {
      /**
       * Gets the Fuchsia default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Fuchsia)) {
          brush = this.sBrushes.getValue(KnownColor.Fuchsia);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Fuchsia);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Gainsboro", {
      /**
       * Gets the Gainsborough default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Gainsboro)) {
          brush = this.sBrushes.getValue(KnownColor.Gainsboro);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Gainsboro);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "GhostWhite", {
      /**
       * Gets the GhostWhite default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.GhostWhite)) {
          brush = this.sBrushes.getValue(KnownColor.GhostWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.GhostWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Gold", {
      /**
       * Gets the Gold default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Gold)) {
          brush = this.sBrushes.getValue(KnownColor.Gold);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Gold);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Goldenrod", {
      /**
       * Gets the Goldenrod default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Goldenrod)) {
          brush = this.sBrushes.getValue(KnownColor.Goldenrod);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Goldenrod);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Gray", {
      /**
       * Gets the Gray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Gray)) {
          brush = this.sBrushes.getValue(KnownColor.Gray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Gray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Green", {
      /**
       * Gets the Green default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Green)) {
          brush = this.sBrushes.getValue(KnownColor.Green);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Green);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "GreenYellow", {
      /**
       * Gets the GreenYellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.GreenYellow)) {
          brush = this.sBrushes.getValue(KnownColor.GreenYellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.GreenYellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Honeydew", {
      /**
       * Gets the Honeydew default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Honeydew)) {
          brush = this.sBrushes.getValue(KnownColor.Honeydew);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Honeydew);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "HotPink", {
      /**
       * Gets the HotPink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.HotPink)) {
          brush = this.sBrushes.getValue(KnownColor.HotPink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.HotPink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "IndianRed", {
      /**
       * Gets the IndianRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.IndianRed)) {
          brush = this.sBrushes.getValue(KnownColor.IndianRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.IndianRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Indigo", {
      /**
       * Gets the Indigo default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Indigo)) {
          brush = this.sBrushes.getValue(KnownColor.Indigo);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Indigo);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Ivory", {
      /**
       * Gets the Ivory default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Ivory)) {
          brush = this.sBrushes.getValue(KnownColor.Ivory);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Ivory);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Khaki", {
      /**
       * Gets the Khaki default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Khaki)) {
          brush = this.sBrushes.getValue(KnownColor.Khaki);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Khaki);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Lavender", {
      /**
       * Gets the Lavender default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Lavender)) {
          brush = this.sBrushes.getValue(KnownColor.Lavender);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Lavender);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LavenderBlush", {
      /**
       * Gets the LavenderBlush default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LavenderBlush)) {
          brush = this.sBrushes.getValue(KnownColor.LavenderBlush);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LavenderBlush);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LawnGreen", {
      /**
       * Gets the LawnGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LawnGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LawnGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LawnGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LemonChiffon", {
      /**
       * Gets the LemonChiffon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LemonChiffon)) {
          brush = this.sBrushes.getValue(KnownColor.LemonChiffon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LemonChiffon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightBlue", {
      /**
       * Gets the LightBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightBlue)) {
          brush = this.sBrushes.getValue(KnownColor.LightBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightCoral", {
      /**
       * Gets the LightCoral default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightCoral)) {
          brush = this.sBrushes.getValue(KnownColor.LightCoral);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightCoral);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightCyan", {
      /**
       * Gets the LightCyan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightCyan)) {
          brush = this.sBrushes.getValue(KnownColor.LightCyan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightCyan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightGoldenrodYellow", {
      /**
       * Gets the LightGoldenrodYellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightGoldenrodYellow)) {
          brush = this.sBrushes.getValue(KnownColor.LightGoldenrodYellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightGoldenrodYellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightGray", {
      /**
       * Gets the LightGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightGray)) {
          brush = this.sBrushes.getValue(KnownColor.LightGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightGreen", {
      /**
       * Gets the LightGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LightGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightPink", {
      /**
       * Gets the LightPink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightPink)) {
          brush = this.sBrushes.getValue(KnownColor.LightPink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightPink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSalmon", {
      /**
       * Gets the LightSalmon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSalmon)) {
          brush = this.sBrushes.getValue(KnownColor.LightSalmon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSalmon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSeaGreen", {
      /**
       * Gets the LightSeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LightSeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSkyBlue", {
      /**
       * Gets the LightSkyBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSkyBlue)) {
          brush = this.sBrushes.getValue(KnownColor.LightSkyBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSkyBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSlateGray", {
      /**
       * Gets the LightSlateGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSlateGray)) {
          brush = this.sBrushes.getValue(KnownColor.LightSlateGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSlateGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSteelBlue", {
      /**
       * Gets the LightSteelBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSteelBlue)) {
          brush = this.sBrushes.getValue(KnownColor.LightSteelBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSteelBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightYellow", {
      /**
       * Gets the LightYellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightYellow)) {
          brush = this.sBrushes.getValue(KnownColor.LightYellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightYellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Lime", {
      /**
       * Gets the Lime default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Lime)) {
          brush = this.sBrushes.getValue(KnownColor.Lime);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Lime);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LimeGreen", {
      /**
       * Gets the LimeGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LimeGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LimeGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LimeGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Linen", {
      /**
       * Gets the Linen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Linen)) {
          brush = this.sBrushes.getValue(KnownColor.Linen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Linen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Magenta", {
      /**
       * Gets the Magenta default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Magenta)) {
          brush = this.sBrushes.getValue(KnownColor.Magenta);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Magenta);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Maroon", {
      /**
       * Gets the Maroon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Maroon)) {
          brush = this.sBrushes.getValue(KnownColor.Maroon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Maroon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumAquamarine", {
      /**
       * Gets the MediumAquamarine default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumAquamarine)) {
          brush = this.sBrushes.getValue(KnownColor.MediumAquamarine);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumAquamarine);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumBlue", {
      /**
       * Gets the MediumBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumBlue)) {
          brush = this.sBrushes.getValue(KnownColor.MediumBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumOrchid", {
      /**
       * Gets the MediumOrchid default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumOrchid)) {
          brush = this.sBrushes.getValue(KnownColor.MediumOrchid);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumOrchid);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumPurple", {
      /**
       * Gets the MediumPurple default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumPurple)) {
          brush = this.sBrushes.getValue(KnownColor.MediumPurple);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumPurple);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumSeaGreen", {
      /**
       * Gets the MediumSeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumSeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.MediumSeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumSeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumSlateBlue", {
      /**
       * Gets the MediumSlateBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumSlateBlue)) {
          brush = this.sBrushes.getValue(KnownColor.MediumSlateBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumSlateBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumSpringGreen", {
      /**
       * Gets the MediumSpringGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumSpringGreen)) {
          brush = this.sBrushes.getValue(KnownColor.MediumSpringGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumSpringGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumTurquoise", {
      /**
       * Gets the MediumTurquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumTurquoise)) {
          brush = this.sBrushes.getValue(KnownColor.MediumTurquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumTurquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumVioletRed", {
      /**
       * Gets the MediumVioletRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumVioletRed)) {
          brush = this.sBrushes.getValue(KnownColor.MediumVioletRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumVioletRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MidnightBlue", {
      /**
       * Gets the MidnightBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MidnightBlue)) {
          brush = this.sBrushes.getValue(KnownColor.MidnightBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MidnightBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MintCream", {
      /**
       * Gets the MintCream default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MintCream)) {
          brush = this.sBrushes.getValue(KnownColor.MintCream);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MintCream);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MistyRose", {
      /**
       * Gets the MistyRose default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MistyRose)) {
          brush = this.sBrushes.getValue(KnownColor.MistyRose);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MistyRose);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Moccasin", {
      /**
       * Gets the Moccasin default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Moccasin)) {
          brush = this.sBrushes.getValue(KnownColor.Moccasin);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Moccasin);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "NavajoWhite", {
      /**
       * Gets the NavajoWhite default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.NavajoWhite)) {
          brush = this.sBrushes.getValue(KnownColor.NavajoWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.NavajoWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Navy", {
      /**
       * Gets the Navy default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Navy)) {
          brush = this.sBrushes.getValue(KnownColor.Navy);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Navy);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "OldLace", {
      /**
       * Gets the OldLace default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.OldLace)) {
          brush = this.sBrushes.getValue(KnownColor.OldLace);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.OldLace);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Olive", {
      /**
       * Gets the Olive default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Olive)) {
          brush = this.sBrushes.getValue(KnownColor.Olive);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Olive);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "OliveDrab", {
      /**
       * Gets the OliveDrab default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.OliveDrab)) {
          brush = this.sBrushes.getValue(KnownColor.OliveDrab);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.OliveDrab);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Orange", {
      /**
       * Gets the Orange default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Orange)) {
          brush = this.sBrushes.getValue(KnownColor.Orange);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Orange);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "OrangeRed", {
      /**
       * Gets the OrangeRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.OrangeRed)) {
          brush = this.sBrushes.getValue(KnownColor.OrangeRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.OrangeRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Orchid", {
      /**
       * Gets the Orchid default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Orchid)) {
          brush = this.sBrushes.getValue(KnownColor.Orchid);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Orchid);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleGoldenrod", {
      /**
       * Gets the PaleGoldenrod default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleGoldenrod)) {
          brush = this.sBrushes.getValue(KnownColor.PaleGoldenrod);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleGoldenrod);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleGreen", {
      /**
       * Gets the PaleGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleGreen)) {
          brush = this.sBrushes.getValue(KnownColor.PaleGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleTurquoise", {
      /**
       * Gets the PaleTurquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleTurquoise)) {
          brush = this.sBrushes.getValue(KnownColor.PaleTurquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleTurquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleVioletRed", {
      /**
       * Gets the PaleVioletRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleVioletRed)) {
          brush = this.sBrushes.getValue(KnownColor.PaleVioletRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleVioletRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PapayaWhip", {
      /**
       * Gets the PapayaWhip default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PapayaWhip)) {
          brush = this.sBrushes.getValue(KnownColor.PapayaWhip);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PapayaWhip);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PeachPuff", {
      /**
       * Gets the PeachPuff default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PeachPuff)) {
          brush = this.sBrushes.getValue(KnownColor.PeachPuff);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PeachPuff);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Peru", {
      /**
       * Gets the Peru default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Peru)) {
          brush = this.sBrushes.getValue(KnownColor.Peru);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Peru);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Pink", {
      /**
       * Gets the Pink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Pink)) {
          brush = this.sBrushes.getValue(KnownColor.Pink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Pink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Plum", {
      /**
       * Gets the Plum default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Plum)) {
          brush = this.sBrushes.getValue(KnownColor.Plum);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Plum);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PowderBlue", {
      /**
       * Gets the PowderBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PowderBlue)) {
          brush = this.sBrushes.getValue(KnownColor.PowderBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PowderBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Purple", {
      /**
       * Gets the Purple default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Purple)) {
          brush = this.sBrushes.getValue(KnownColor.Purple);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Purple);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Red", {
      /**
       * Gets the Red default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Red)) {
          brush = this.sBrushes.getValue(KnownColor.Red);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Red);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "RosyBrown", {
      /**
       * Gets the RosyBrown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.RosyBrown)) {
          brush = this.sBrushes.getValue(KnownColor.RosyBrown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.RosyBrown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "RoyalBlue", {
      /**
       * Gets the RoyalBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.RoyalBlue)) {
          brush = this.sBrushes.getValue(KnownColor.RoyalBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.RoyalBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SaddleBrown", {
      /**
       * Gets the SaddleBrown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SaddleBrown)) {
          brush = this.sBrushes.getValue(KnownColor.SaddleBrown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SaddleBrown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Salmon", {
      /**
       * Gets the Salmon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Salmon)) {
          brush = this.sBrushes.getValue(KnownColor.Salmon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Salmon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SandyBrown", {
      /**
       * Gets the SandyBrown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SandyBrown)) {
          brush = this.sBrushes.getValue(KnownColor.SandyBrown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SandyBrown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SeaGreen", {
      /**
       * Gets the SeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.SeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SeaShell", {
      /**
       * Gets the SeaShell default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SeaShell)) {
          brush = this.sBrushes.getValue(KnownColor.SeaShell);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SeaShell);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Sienna", {
      /**
       * Gets the Sienna default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Sienna)) {
          brush = this.sBrushes.getValue(KnownColor.Sienna);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Sienna);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Silver", {
      /**
       * Gets the Silver default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Silver)) {
          brush = this.sBrushes.getValue(KnownColor.Silver);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Silver);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SkyBlue", {
      /**
       * Gets the SkyBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SkyBlue)) {
          brush = this.sBrushes.getValue(KnownColor.SkyBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SkyBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SlateBlue", {
      /**
       * Gets the SlateBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SlateBlue)) {
          brush = this.sBrushes.getValue(KnownColor.SlateBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SlateBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SlateGray", {
      /**
       * Gets the SlateGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SlateGray)) {
          brush = this.sBrushes.getValue(KnownColor.SlateGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SlateGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Snow", {
      /**
       * Gets the Snow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Snow)) {
          brush = this.sBrushes.getValue(KnownColor.Snow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Snow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SpringGreen", {
      /**
       * Gets the SpringGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SpringGreen)) {
          brush = this.sBrushes.getValue(KnownColor.SpringGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SpringGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SteelBlue", {
      /**
       * Gets the SteelBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SteelBlue)) {
          brush = this.sBrushes.getValue(KnownColor.SteelBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SteelBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Tan", {
      /**
       * Gets the Tan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Tan)) {
          brush = this.sBrushes.getValue(KnownColor.Tan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Tan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Teal", {
      /**
       * Gets the Teal default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Teal)) {
          brush = this.sBrushes.getValue(KnownColor.Teal);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Teal);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Thistle", {
      /**
       * Gets the Thistle default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Thistle)) {
          brush = this.sBrushes.getValue(KnownColor.Thistle);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Thistle);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Tomato", {
      /**
       * Gets the Tomato default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Tomato)) {
          brush = this.sBrushes.getValue(KnownColor.Tomato);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Tomato);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Transparent", {
      /**
       * Gets the Transparent default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Transparent)) {
          brush = this.sBrushes.getValue(KnownColor.Transparent);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Transparent);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Turquoise", {
      /**
       * Gets the Turquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Turquoise)) {
          brush = this.sBrushes.getValue(KnownColor.Turquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Turquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Violet", {
      /**
       * Gets the Violet default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Violet)) {
          brush = this.sBrushes.getValue(KnownColor.Violet);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Violet);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Wheat", {
      /**
       * Gets the Wheat default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Wheat)) {
          brush = this.sBrushes.getValue(KnownColor.Wheat);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Wheat);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "White", {
      /**
       * Gets the White default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.White)) {
          brush = this.sBrushes.getValue(KnownColor.White);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.White);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "WhiteSmoke", {
      /**
       * Gets the WhiteSmoke default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.WhiteSmoke)) {
          brush = this.sBrushes.getValue(KnownColor.WhiteSmoke);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.WhiteSmoke);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Yellow", {
      /**
       * Gets the Yellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Yellow)) {
          brush = this.sBrushes.getValue(KnownColor.Yellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Yellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "YellowGreen", {
      /**
       * Gets the YellowGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.YellowGreen)) {
          brush = this.sBrushes.getValue(KnownColor.YellowGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.YellowGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    PdfBrushes2.getBrush = function(colorName) {
      var pdfColor = this.getColorValue(colorName);
      var brush = new PdfSolidBrush(pdfColor);
      this.sBrushes.setValue(colorName, brush);
      return brush;
    };
    PdfBrushes2.getColorValue = function(colorName) {
      var color = new PdfColor();
      switch (colorName) {
        case KnownColor.Transparent:
          color = new PdfColor(0, 255, 255, 255);
          break;
        case KnownColor.AliceBlue:
          color = new PdfColor(255, 240, 248, 255);
          break;
        case KnownColor.AntiqueWhite:
          color = new PdfColor(255, 250, 235, 215);
          break;
        case KnownColor.Aqua:
          color = new PdfColor(255, 0, 255, 255);
          break;
        case KnownColor.Aquamarine:
          color = new PdfColor(255, 127, 255, 212);
          break;
        case KnownColor.Azure:
          color = new PdfColor(255, 240, 255, 255);
          break;
        case KnownColor.Beige:
          color = new PdfColor(255, 245, 245, 220);
          break;
        case KnownColor.Bisque:
          color = new PdfColor(255, 255, 228, 196);
          break;
        case KnownColor.Black:
          color = new PdfColor(255, 0, 0, 0);
          break;
        case KnownColor.BlanchedAlmond:
          color = new PdfColor(255, 255, 235, 205);
          break;
        case KnownColor.Blue:
          color = new PdfColor(255, 0, 0, 255);
          break;
        case KnownColor.BlueViolet:
          color = new PdfColor(255, 138, 43, 226);
          break;
        case KnownColor.Brown:
          color = new PdfColor(255, 165, 42, 42);
          break;
        case KnownColor.BurlyWood:
          color = new PdfColor(255, 222, 184, 135);
          break;
        case KnownColor.CadetBlue:
          color = new PdfColor(255, 95, 158, 160);
          break;
        case KnownColor.Chartreuse:
          color = new PdfColor(255, 127, 255, 0);
          break;
        case KnownColor.Chocolate:
          color = new PdfColor(255, 210, 105, 30);
          break;
        case KnownColor.Coral:
          color = new PdfColor(255, 255, 127, 80);
          break;
        case KnownColor.CornflowerBlue:
          color = new PdfColor(255, 100, 149, 237);
          break;
        case KnownColor.Cornsilk:
          color = new PdfColor(255, 255, 248, 220);
          break;
        case KnownColor.Crimson:
          color = new PdfColor(255, 220, 20, 60);
          break;
        case KnownColor.Cyan:
          color = new PdfColor(255, 0, 255, 255);
          break;
        case KnownColor.DarkBlue:
          color = new PdfColor(255, 0, 0, 139);
          break;
        case KnownColor.DarkCyan:
          color = new PdfColor(255, 0, 139, 139);
          break;
        case KnownColor.DarkGoldenrod:
          color = new PdfColor(255, 184, 134, 11);
          break;
        case KnownColor.DarkGray:
          color = new PdfColor(255, 169, 169, 169);
          break;
        case KnownColor.DarkGreen:
          color = new PdfColor(255, 0, 100, 0);
          break;
        case KnownColor.DarkKhaki:
          color = new PdfColor(255, 189, 183, 107);
          break;
        case KnownColor.DarkMagenta:
          color = new PdfColor(255, 139, 0, 139);
          break;
        case KnownColor.DarkOliveGreen:
          color = new PdfColor(255, 85, 107, 47);
          break;
        case KnownColor.DarkOrange:
          color = new PdfColor(255, 255, 140, 0);
          break;
        case KnownColor.DarkOrchid:
          color = new PdfColor(255, 153, 50, 204);
          break;
        case KnownColor.DarkRed:
          color = new PdfColor(255, 139, 0, 0);
          break;
        case KnownColor.DarkSalmon:
          color = new PdfColor(255, 233, 150, 122);
          break;
        case KnownColor.DarkSeaGreen:
          color = new PdfColor(255, 143, 188, 139);
          break;
        case KnownColor.DarkSlateBlue:
          color = new PdfColor(255, 72, 61, 139);
          break;
        case KnownColor.DarkSlateGray:
          color = new PdfColor(255, 47, 79, 79);
          break;
        case KnownColor.DarkTurquoise:
          color = new PdfColor(255, 0, 206, 209);
          break;
        case KnownColor.DarkViolet:
          color = new PdfColor(255, 148, 0, 211);
          break;
        case KnownColor.DeepPink:
          color = new PdfColor(255, 255, 20, 147);
          break;
        case KnownColor.DeepSkyBlue:
          color = new PdfColor(255, 0, 191, 255);
          break;
        case KnownColor.DimGray:
          color = new PdfColor(255, 105, 105, 105);
          break;
        case KnownColor.DodgerBlue:
          color = new PdfColor(255, 30, 144, 255);
          break;
        case KnownColor.Firebrick:
          color = new PdfColor(255, 178, 34, 34);
          break;
        case KnownColor.FloralWhite:
          color = new PdfColor(255, 255, 250, 240);
          break;
        case KnownColor.ForestGreen:
          color = new PdfColor(255, 34, 139, 34);
          break;
        case KnownColor.Fuchsia:
          color = new PdfColor(255, 255, 0, 255);
          break;
        case KnownColor.Gainsboro:
          color = new PdfColor(255, 220, 220, 220);
          break;
        case KnownColor.GhostWhite:
          color = new PdfColor(255, 248, 248, 255);
          break;
        case KnownColor.Gold:
          color = new PdfColor(255, 255, 215, 0);
          break;
        case KnownColor.Goldenrod:
          color = new PdfColor(255, 218, 165, 32);
          break;
        case KnownColor.Gray:
          color = new PdfColor(255, 128, 128, 128);
          break;
        case KnownColor.Green:
          color = new PdfColor(255, 0, 128, 0);
          break;
        case KnownColor.GreenYellow:
          color = new PdfColor(255, 173, 255, 47);
          break;
        case KnownColor.Honeydew:
          color = new PdfColor(255, 240, 255, 240);
          break;
        case KnownColor.HotPink:
          color = new PdfColor(255, 255, 105, 180);
          break;
        case KnownColor.IndianRed:
          color = new PdfColor(255, 205, 92, 92);
          break;
        case KnownColor.Indigo:
          color = new PdfColor(255, 75, 0, 130);
          break;
        case KnownColor.Ivory:
          color = new PdfColor(255, 255, 255, 240);
          break;
        case KnownColor.Khaki:
          color = new PdfColor(255, 240, 230, 140);
          break;
        case KnownColor.Lavender:
          color = new PdfColor(255, 230, 230, 250);
          break;
        case KnownColor.LavenderBlush:
          color = new PdfColor(255, 255, 240, 245);
          break;
        case KnownColor.LawnGreen:
          color = new PdfColor(255, 124, 252, 0);
          break;
        case KnownColor.LemonChiffon:
          color = new PdfColor(255, 255, 250, 205);
          break;
        case KnownColor.LightBlue:
          color = new PdfColor(255, 173, 216, 230);
          break;
        case KnownColor.LightCoral:
          color = new PdfColor(255, 240, 128, 128);
          break;
        case KnownColor.LightCyan:
          color = new PdfColor(255, 224, 255, 255);
          break;
        case KnownColor.LightGoldenrodYellow:
          color = new PdfColor(255, 250, 250, 210);
          break;
        case KnownColor.LightGreen:
          color = new PdfColor(255, 144, 238, 144);
          break;
        case KnownColor.LightGray:
          color = new PdfColor(255, 211, 211, 211);
          break;
        case KnownColor.LightPink:
          color = new PdfColor(255, 255, 182, 193);
          break;
        case KnownColor.LightSalmon:
          color = new PdfColor(255, 255, 160, 122);
          break;
        case KnownColor.LightSeaGreen:
          color = new PdfColor(255, 32, 178, 170);
          break;
        case KnownColor.LightSkyBlue:
          color = new PdfColor(255, 135, 206, 250);
          break;
        case KnownColor.LightSlateGray:
          color = new PdfColor(255, 119, 136, 153);
          break;
        case KnownColor.LightSteelBlue:
          color = new PdfColor(255, 176, 196, 222);
          break;
        case KnownColor.LightYellow:
          color = new PdfColor(255, 255, 255, 224);
          break;
        case KnownColor.Lime:
          color = new PdfColor(255, 0, 255, 0);
          break;
        case KnownColor.LimeGreen:
          color = new PdfColor(255, 50, 205, 50);
          break;
        case KnownColor.Linen:
          color = new PdfColor(255, 250, 240, 230);
          break;
        case KnownColor.Magenta:
          color = new PdfColor(255, 255, 0, 255);
          break;
        case KnownColor.Maroon:
          color = new PdfColor(255, 128, 0, 0);
          break;
        case KnownColor.MediumAquamarine:
          color = new PdfColor(255, 102, 205, 170);
          break;
        case KnownColor.MediumBlue:
          color = new PdfColor(255, 0, 0, 205);
          break;
        case KnownColor.MediumOrchid:
          color = new PdfColor(255, 186, 85, 211);
          break;
        case KnownColor.MediumPurple:
          color = new PdfColor(255, 147, 112, 219);
          break;
        case KnownColor.MediumSeaGreen:
          color = new PdfColor(255, 60, 179, 113);
          break;
        case KnownColor.MediumSlateBlue:
          color = new PdfColor(255, 123, 104, 238);
          break;
        case KnownColor.MediumSpringGreen:
          color = new PdfColor(255, 0, 250, 154);
          break;
        case KnownColor.MediumTurquoise:
          color = new PdfColor(255, 72, 209, 204);
          break;
        case KnownColor.MediumVioletRed:
          color = new PdfColor(255, 199, 21, 133);
          break;
        case KnownColor.MidnightBlue:
          color = new PdfColor(255, 25, 25, 112);
          break;
        case KnownColor.MintCream:
          color = new PdfColor(255, 245, 255, 250);
          break;
        case KnownColor.MistyRose:
          color = new PdfColor(255, 255, 228, 225);
          break;
        case KnownColor.Moccasin:
          color = new PdfColor(255, 255, 228, 181);
          break;
        case KnownColor.NavajoWhite:
          color = new PdfColor(255, 255, 222, 173);
          break;
        case KnownColor.Navy:
          color = new PdfColor(255, 0, 0, 128);
          break;
        case KnownColor.OldLace:
          color = new PdfColor(255, 253, 245, 230);
          break;
        case KnownColor.Olive:
          color = new PdfColor(255, 128, 128, 0);
          break;
        case KnownColor.OliveDrab:
          color = new PdfColor(255, 107, 142, 35);
          break;
        case KnownColor.Orange:
          color = new PdfColor(255, 255, 165, 0);
          break;
        case KnownColor.OrangeRed:
          color = new PdfColor(255, 255, 69, 0);
          break;
        case KnownColor.Orchid:
          color = new PdfColor(255, 218, 112, 214);
          break;
        case KnownColor.PaleGoldenrod:
          color = new PdfColor(255, 238, 232, 170);
          break;
        case KnownColor.PaleGreen:
          color = new PdfColor(255, 152, 251, 152);
          break;
        case KnownColor.PaleTurquoise:
          color = new PdfColor(255, 175, 238, 238);
          break;
        case KnownColor.PaleVioletRed:
          color = new PdfColor(255, 219, 112, 147);
          break;
        case KnownColor.PapayaWhip:
          color = new PdfColor(255, 255, 239, 213);
          break;
        case KnownColor.PeachPuff:
          color = new PdfColor(255, 255, 218, 185);
          break;
        case KnownColor.Peru:
          color = new PdfColor(255, 205, 133, 63);
          break;
        case KnownColor.Pink:
          color = new PdfColor(255, 255, 192, 203);
          break;
        case KnownColor.Plum:
          color = new PdfColor(255, 221, 160, 221);
          break;
        case KnownColor.PowderBlue:
          color = new PdfColor(255, 176, 224, 230);
          break;
        case KnownColor.Purple:
          color = new PdfColor(255, 128, 0, 128);
          break;
        case KnownColor.Red:
          color = new PdfColor(255, 255, 0, 0);
          break;
        case KnownColor.RosyBrown:
          color = new PdfColor(255, 188, 143, 143);
          break;
        case KnownColor.RoyalBlue:
          color = new PdfColor(255, 65, 105, 225);
          break;
        case KnownColor.SaddleBrown:
          color = new PdfColor(255, 139, 69, 19);
          break;
        case KnownColor.Salmon:
          color = new PdfColor(255, 250, 128, 114);
          break;
        case KnownColor.SandyBrown:
          color = new PdfColor(255, 244, 164, 96);
          break;
        case KnownColor.SeaGreen:
          color = new PdfColor(255, 46, 139, 87);
          break;
        case KnownColor.SeaShell:
          color = new PdfColor(255, 255, 245, 238);
          break;
        case KnownColor.Sienna:
          color = new PdfColor(255, 160, 82, 45);
          break;
        case KnownColor.Silver:
          color = new PdfColor(255, 192, 192, 192);
          break;
        case KnownColor.SkyBlue:
          color = new PdfColor(255, 135, 206, 235);
          break;
        case KnownColor.SlateBlue:
          color = new PdfColor(255, 106, 90, 205);
          break;
        case KnownColor.SlateGray:
          color = new PdfColor(255, 112, 128, 144);
          break;
        case KnownColor.Snow:
          color = new PdfColor(255, 255, 250, 250);
          break;
        case KnownColor.SpringGreen:
          color = new PdfColor(255, 0, 255, 127);
          break;
        case KnownColor.SteelBlue:
          color = new PdfColor(255, 70, 130, 180);
          break;
        case KnownColor.Tan:
          color = new PdfColor(255, 210, 180, 140);
          break;
        case KnownColor.Teal:
          color = new PdfColor(255, 0, 128, 128);
          break;
        case KnownColor.Thistle:
          color = new PdfColor(255, 216, 191, 216);
          break;
        case KnownColor.Tomato:
          color = new PdfColor(255, 255, 99, 71);
          break;
        case KnownColor.Turquoise:
          color = new PdfColor(255, 64, 224, 208);
          break;
        case KnownColor.Violet:
          color = new PdfColor(255, 238, 130, 238);
          break;
        case KnownColor.Wheat:
          color = new PdfColor(255, 245, 222, 179);
          break;
        case KnownColor.White:
          color = new PdfColor(255, 255, 255, 255);
          break;
        case KnownColor.WhiteSmoke:
          color = new PdfColor(255, 245, 245, 245);
          break;
        case KnownColor.Yellow:
          color = new PdfColor(255, 255, 255, 0);
          break;
        case KnownColor.YellowGreen:
          color = new PdfColor(255, 154, 205, 50);
          break;
      }
      return color;
    };
    PdfBrushes2.sBrushes = new Dictionary();
    return PdfBrushes2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-blend.js
var PdfBlend = (
  /** @class */
  function() {
    function PdfBlend2(count) {
      this.precision = 1e3;
    }
    Object.defineProperty(PdfBlend2.prototype, "factors", {
      //Properties
      /**
       * Gets or sets the array of factor to the blend.
       * @public
       */
      get: function() {
        return this.mFactors;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Factors");
        }
        this.mFactors = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBlend2.prototype, "positions", {
      /**
       * 'positions' Gets or sets the array of positions
       * @public
       */
      get: function() {
        return this.mPositions;
      },
      set: function(value) {
        var positionarray = value;
        for (var i = 0; i < positionarray.length; i++) {
          if (positionarray[i] < 0 || positionarray[i] > 1) {
            positionarray[i] = 0;
          }
        }
        this.mPositions = positionarray;
        this.mPositions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBlend2.prototype, "count", {
      /**
       * Gets the number of elements that specify the blend.
       * @protected
       */
      get: function() {
        return this.mCount;
      },
      enumerable: true,
      configurable: true
    });
    PdfBlend2.prototype.generateColorBlend = function(colours, colorSpace) {
      if (colours == null) {
        throw new Error("ArgumentNullException : colours");
      }
      if (this.positions == null) {
        this.positions = [0];
      }
      var cBlend = new PdfColorBlend(this.count);
      var positions = this.positions;
      var clrs = null;
      if (positions.length === 1) {
        positions = [3];
        positions[0] = 0;
        positions[1] = this.positions[0];
        positions[2] = 1;
        clrs = new Array(3);
        clrs[0] = colours[0];
        clrs[1] = colours[0];
        clrs[2] = colours[1];
      } else {
        var c1 = colours[0];
        var c2 = colours[1];
        clrs = new Array(this.count);
        var i = 0;
        var count = this.count;
        for (i = 0; i < count; ++i) {
          clrs[i] = this.interpolate(this.mFactors[i], c1, c2, colorSpace);
        }
      }
      cBlend.positions = positions;
      cBlend.colors = clrs;
      return cBlend;
    };
    PdfBlend2.prototype.clonePdfBlend = function() {
      var blend = this;
      if (this.mFactors != null) {
        blend.factors = this.mFactors;
      }
      if (this.positions != null) {
        blend.positions = this.positions;
      }
      return blend;
    };
    PdfBlend2.prototype.gcd = function(u, v) {
      if (typeof u === "number" && typeof v === "number" && typeof v !== "undefined") {
        if (u < 0 || u > 1) {
          throw new Error("ArgumentOutOfRangeException : u");
        }
        if (v < 0 || v > 1) {
          throw new Error("ArgumentOutOfRangeException : v");
        }
        var iU = Math.max(1, u * this.precision);
        var iV = Math.max(1, v * this.precision);
        var iResult = this.gcdInt(iU, iV);
        var result = iResult / this.precision;
        return result;
      } else {
        var values = u;
        if (values == null) {
          throw new Error("ArgumentNullException : values");
        }
        if (values.length < 1) {
          throw new Error("ArgumentException : Not enough values in the array. - values");
        }
        var gcd = values[0];
        if (values.length > 1) {
          var count = values.length;
          for (var i = 1; i < count; ++i) {
            gcd = this.gcd(values[i], gcd);
            if (gcd === 1 / this.precision) {
              break;
            }
          }
        }
        return gcd;
      }
    };
    PdfBlend2.prototype.gcdInt = function(u, v) {
      if (u <= 0) {
        throw new Error("ArgumentOutOfRangeException" + u + "The arguments cannot be less or equal to zero.");
      }
      if (v <= 0) {
        throw new Error("ArgumentOutOfRangeException" + v + "The arguments cannot be less or equal to zero.");
      }
      if (u === 1 || v === 1) {
        return 1;
      }
      var shift = 0;
      while (this.isEven(u, v)) {
        ++shift;
        u >>= 1;
        v >>= 1;
      }
      while ((u & 1) <= 0) {
        u >>= 1;
      }
      do {
        while ((v & 1) <= 0) {
          v >>= 1;
        }
        if (u > v) {
          var t = v;
          v = u;
          u = t;
        }
        v = v - u;
      } while (v !== 0);
      return u << shift;
    };
    PdfBlend2.prototype.isEven = function(arg1, arg2) {
      if (typeof arg2 === "number" && typeof arg2 !== "undefined") {
        var result = true;
        result = result && (arg1 & 1) <= 0;
        result = result && (arg2 & 1) <= 0;
        return result;
      } else {
        return (arg1 & 1) <= 0;
      }
    };
    PdfBlend2.prototype.interpolate = function(t, color1, color2, colorSpace) {
      if (color1 instanceof PdfColor) {
        var color = new PdfColor();
        switch (colorSpace) {
          case PdfColorSpace.Rgb:
            var red = this.interpolate(t, color1.red, color2.red);
            var green = this.interpolate(t, color1.green, color2.green);
            var blue = this.interpolate(t, color1.blue, color2.blue);
            color = new PdfColor(red, green, blue);
            break;
          case PdfColorSpace.GrayScale:
            var gray = this.interpolate(t, color1.gray, color2.gray);
            color = new PdfColor(gray);
            break;
          case PdfColorSpace.Cmyk:
            var cyan = this.interpolate(t, color1.c, color2.c);
            var magenta = this.interpolate(t, color1.m, color2.m);
            var yellow = this.interpolate(t, color1.y, color2.y);
            var black = this.interpolate(t, color1.k, color2.k);
            color = new PdfColor(cyan, magenta, yellow, black);
            break;
        }
        return color;
      } else {
        var t0 = 0;
        var t1 = 1;
        var result = 0;
        if (t === t0) {
          result = color1;
        } else if (t === t1) {
          result = color2;
        } else {
          result = color1 + (t - t0) * ((color2 - color1) / (t1 - t0));
        }
        return result;
      }
    };
    return PdfBlend2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-color-blend.js
var __extends33 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfColorBlend = (
  /** @class */
  function(_super) {
    __extends33(PdfColorBlend2, _super);
    function PdfColorBlend2(count) {
      var _this = _super.call(this) || this;
      if (typeof count === "number") {
        _this = _super.call(this, count) || this;
      }
      return _this;
    }
    Object.defineProperty(PdfColorBlend2.prototype, "colors", {
      //Properties
      /**
       * Gets or sets the array of colors.
       * @public
       */
      get: function() {
        return this.mcolors;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Colors");
        }
        this.mcolors = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfColorBlend2.prototype.getFunction = function(colorSpace) {
      var domain = [0, 1];
      var colourComponents = this.getColorComponentsCount(colorSpace);
      var maxComponentValue = this.getMaxComponentValue(colorSpace);
      var range = this.setRange(colourComponents, maxComponentValue);
      var func = null;
      if (this.mbrush == null && typeof this.mbrush === "undefined") {
        var sizes = [1];
        var samplesCount = void 0;
        var step = 1;
        if (this.positions.length === 2) {
          samplesCount = 2;
        } else {
          var positions = this.positions;
          var intervals = this.getIntervals(positions);
          var gcd = this.gcd(intervals);
          step = gcd;
          samplesCount = 1 / gcd + 1;
        }
        sizes[0] = samplesCount;
        var samples = this.getSamplesValues(colorSpace, samplesCount, maxComponentValue, step);
        func = new PdfSampledFunction(domain, range, sizes, samples);
        return func;
      }
      return func;
    };
    PdfColorBlend2.prototype.cloneColorBlend = function() {
      var cBlend = this;
      if (this.mcolors != null && typeof this.mcolors !== "undefined") {
        cBlend.colors = this.mcolors;
      }
      if (this.positions != null && typeof this.positions !== "undefined") {
        cBlend.positions = this.positions;
      }
      return cBlend;
    };
    PdfColorBlend2.prototype.setRange = function(colourComponents, maxValue) {
      var range = [colourComponents * 2];
      for (var i = 0; i < colourComponents; ++i) {
        range[i * 2] = 0;
        range[i * 2 + 1] = 1;
      }
      return range;
    };
    PdfColorBlend2.prototype.getColorComponentsCount = function(colorSpace) {
      var count = 0;
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          count = 3;
          break;
        case PdfColorSpace.Cmyk:
          count = 4;
          break;
        case PdfColorSpace.GrayScale:
          count = 1;
          break;
        default:
          throw new Error("ArgumentException - Unsupported color space: " + colorSpace + " colorSpace");
      }
      return count;
    };
    PdfColorBlend2.prototype.getSamplesValues = function(colorSpace, sampleCount, maxComponentValue, step) {
      var values;
      switch (colorSpace) {
        case PdfColorSpace.GrayScale:
          values = this.getGrayscaleSamples(sampleCount, maxComponentValue, step);
          break;
        case PdfColorSpace.Cmyk:
          values = this.getCmykSamples(sampleCount, maxComponentValue, step);
          break;
        case PdfColorSpace.Rgb:
          values = this.getRgbSamples(sampleCount, maxComponentValue, step);
          break;
        default:
          throw new Error("ArgumentException - Unsupported color space: " + colorSpace + " colorSpace");
      }
      return values;
    };
    PdfColorBlend2.prototype.getGrayscaleSamples = function(sampleCount, maxComponentValue, step) {
      var values = [sampleCount * 2];
      for (var i = 0; i < sampleCount; ++i) {
        var color = this.getNextColor(i, step, PdfColorSpace.GrayScale);
        var index = i * 2;
      }
      return values;
    };
    PdfColorBlend2.prototype.getRgbSamples = function(sampleCount, maxComponentValue, step) {
      var values = [sampleCount * 3];
      for (var i = 0; i < sampleCount; ++i) {
        var color = this.getNextColor(i, step, PdfColorSpace.Rgb);
        var index = i * 3;
        values[index] = color.r;
        values[index + 1] = color.g;
        values[index + 2] = color.b;
      }
      return values;
    };
    PdfColorBlend2.prototype.getCmykSamples = function(sampleCount, maxComponentValue, step) {
      var values = [sampleCount * 4];
      for (var i = 0; i < sampleCount; i++) {
        var color = this.getNextColor(i, step, PdfColorSpace.Cmyk);
        var index = i * 4;
        values[index] = color.c * maxComponentValue;
        values[index + 1] = color.m * maxComponentValue;
        values[index + 2] = color.y * maxComponentValue;
        values[index + 3] = color.k * maxComponentValue;
      }
      return values;
    };
    PdfColorBlend2.prototype.getNextColor = function(index, step, colorSpace) {
      var position = step * index;
      var indexHi;
      var indexLow;
      var result = this.getIndices(position, indexLow, indexHi);
      indexLow = result.indexLow;
      indexHi = result.indexHi;
      var color;
      if (indexLow === indexHi) {
        color = this.mcolors[indexLow];
      } else {
        var positionLow = this.positions[indexLow];
        var positionHi = this.positions[indexHi];
        var colorLow = this.mcolors[indexLow];
        var colorHi = this.mcolors[indexHi];
        var t = (position - positionLow) / (positionHi - positionLow);
        color = this.interpolate(t, colorLow, colorHi, colorSpace);
      }
      return color;
    };
    PdfColorBlend2.prototype.getIndices = function(position, indexLow, indexHi) {
      var positions = this.positions;
      indexLow = 0;
      indexHi = 0;
      for (var i = 0; i < this.mcolors.length; ++i) {
        var currPos = positions[i];
        if (currPos === position) {
          indexHi = i;
          indexLow = i;
          break;
        } else if (currPos > position) {
          indexHi = i;
          break;
        }
        indexLow = i;
        indexHi = i;
      }
      return { indexLow, indexHi };
    };
    PdfColorBlend2.prototype.getMaxComponentValue = function(colorSpace) {
      var result = 0;
      switch (colorSpace) {
        case PdfColorSpace.Cmyk:
        case PdfColorSpace.Rgb:
          result = 255;
          break;
        case PdfColorSpace.GrayScale:
          result = 65535;
          break;
        default:
          throw new Error("ArgumentException - Unsupported color space: " + colorSpace + "colorSpace");
      }
      return result;
    };
    PdfColorBlend2.prototype.getIntervals = function(positions) {
      var count = positions.length;
      var intervals = [count - 1];
      var prev = positions[0];
      for (var i = 1; i < count; ++i) {
        var v = positions[i];
        intervals[i - 1] = v - prev;
        prev = v;
      }
      return intervals;
    };
    return PdfColorBlend2;
  }(PdfBlend)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-linear-gradient-brush.js
var __extends34 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfLinearGradientBrush = (
  /** @class */
  function(_super) {
    __extends34(PdfLinearGradientBrush2, _super);
    function PdfLinearGradientBrush2(arg1, arg2, arg3, arg4) {
      var _this = _super.call(this, new PdfDictionary()) || this;
      _this.mDictionaryProperties = new DictionaryProperties();
      if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PdfColor && arg4 instanceof PdfColor) {
        _this.initialize(arg3, arg4);
        _this.mPointStart = arg1;
        _this.mPointEnd = arg2;
        _this.setPoints(_this.mPointStart, _this.mPointEnd);
      } else if (arg1 instanceof Rectangle) {
        _this.initialize(arg2, arg3);
        if (arg4 === PdfLinearGradientMode.BackwardDiagonal || arg4 === PdfLinearGradientMode.ForwardDiagonal || arg4 === PdfLinearGradientMode.Horizontal || arg4 === PdfLinearGradientMode.Vertical) {
          _this.mBoundaries = arg1;
          switch (arg4) {
            case PdfLinearGradientMode.BackwardDiagonal:
              _this.mPointStart = new PointF(arg1.right, arg1.top);
              _this.mPointEnd = new PointF(arg1.left, arg1.bottom);
              break;
            case PdfLinearGradientMode.ForwardDiagonal:
              _this.mPointStart = new PointF(arg1.left, arg1.top);
              _this.mPointEnd = new PointF(arg1.right, arg1.bottom);
              break;
            case PdfLinearGradientMode.Horizontal:
              _this.mPointStart = new PointF(arg1.left, arg1.top);
              _this.mPointEnd = new PointF(arg1.right, arg1.top);
              break;
            case PdfLinearGradientMode.Vertical:
              _this.mPointStart = new PointF(arg1.left, arg1.top);
              _this.mPointEnd = new PointF(arg1.left, arg1.bottom);
              break;
            default:
              throw new Error("ArgumentException -- Unsupported linear gradient mode: " + arg4 + " mode");
          }
          _this.setPoints(_this.mPointStart, _this.mPointEnd);
        } else if (typeof arg4 === "number" && typeof arg4 !== "undefined") {
          _this.mBoundaries = arg1;
          arg4 = arg4 % 360;
          if (arg4 === 0) {
            _this.mPointStart = new PointF(arg1.left, arg1.top);
            _this.mPointEnd = new PointF(arg1.right, arg1.top);
          } else if (arg4 === 90) {
            _this.mPointStart = new PointF(arg1.left, arg1.top);
            _this.mPointEnd = new PointF(arg1.left, arg1.bottom);
          } else if (arg4 === 180) {
            _this.mPointEnd = new PointF(arg1.left, arg1.top);
            _this.mPointStart = new PointF(arg1.right, arg1.top);
          } else if (arg4 === 270) {
            _this.mPointEnd = new PointF(arg1.left, arg1.top);
            _this.mPointStart = new PointF(arg1.left, arg1.bottom);
          } else {
            var d2r = Math.PI / 180;
            var radAngle = arg4 * d2r;
            var k = Math.tan(radAngle);
            var x = _this.mBoundaries.left + (_this.mBoundaries.right - _this.mBoundaries.left) / 2;
            var y = _this.mBoundaries.top + (_this.mBoundaries.bottom - _this.mBoundaries.top) / 2;
            var centre = new PointF(x, y);
            x = _this.mBoundaries.width / (2 * Math.cos(radAngle));
            y = k * x;
            x = x + centre.x;
            y = y + centre.y;
            var p1 = new PointF(x, y);
            var cp1 = _this.subPoints(p1, centre);
            var p = _this.choosePoint(arg4);
            var coef = _this.mulPoints(_this.subPoints(p, centre), cp1) / _this.mulPoints(cp1, cp1);
            _this.mPointEnd = _this.addPoints(centre, _this.mulPoint(cp1, coef));
            _this.mPointStart = _this.addPoints(centre, _this.mulPoint(cp1, coef * -1));
          }
          _this.setPoints(_this.mPointEnd, _this.mPointStart);
        }
      }
      return _this;
    }
    PdfLinearGradientBrush2.prototype.initialize = function(color1, color2) {
      this.mColours = [color1, color2];
      this.mColourBlend = new PdfColorBlend(2);
      this.mColourBlend.positions = [0, 1];
      this.mColourBlend.colors = this.mColours;
      this.initShading();
    };
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "blend", {
      //Properties
      /**
       * Gets or sets a PdfBlend that specifies positions
       * and factors that define a custom falloff for the gradient.
       * @public
       */
      get: function() {
        return this.mBlend;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Blend");
        }
        if (this.mColours == null) {
          throw new Error("NotSupportedException : There is no starting and ending colours specified.");
        }
        this.mBlend = value;
        this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "interpolationColors", {
      /**
       * Gets or sets a ColorBlend that defines a multicolor linear gradient.
       * @public
       */
      get: function() {
        return this.mColourBlend;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : InterpolationColors");
        }
        this.mBlend = null;
        this.mColours = null;
        this.mColourBlend = value;
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "linearColors", {
      /**
       * Gets or sets the starting and ending colors of the gradient.
       * @public
       */
      get: function() {
        return this.mColours;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : LinearColors");
        }
        if (value.length < 2) {
          throw new Error("ArgumentException : The array is too small - LinearColors");
        }
        if (this.mColours == null && typeof this.mColours === "undefined") {
          this.mColours = [value[0], value[1]];
        } else {
          this.mColours[0] = value[0];
          this.mColours[1] = value[1];
        }
        if (this.mBlend == null && typeof this.mBlend === "undefined") {
          this.mColourBlend = new PdfColorBlend(2);
          this.mColourBlend.colors = this.mColours;
          this.mColourBlend.positions = [0, 1];
        } else {
          this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);
        }
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "rectangle", {
      /**
       * Gets a rectangular region that defines the boundaries of the gradient.
       * @public
       */
      get: function() {
        return this.mBoundaries;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "extend", {
      /**
       * Gets or sets the value indicating whether the gradient should extend starting and ending points.
       * @public
       */
      get: function() {
        var result = PdfExtend.None;
        var extend2 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        if (extend2 != null) {
          var extStart = extend2.items(0);
          var extEnd = extend2.items(1);
          if (extStart.value) {
            result = result | PdfExtend.Start;
          }
          if (extEnd.value) {
            result = result | PdfExtend.End;
          }
        }
        return result;
      },
      set: function(value) {
        var extend2 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        var extStart;
        var extEnd;
        if (extend2 == null) {
          extStart = new PdfBoolean(false);
          extEnd = new PdfBoolean(false);
          extend2 = new PdfArray();
          extend2.add(extStart);
          extend2.add(extEnd);
          this.shading.items.setValue(this.mDictionaryProperties.extend, extend2);
        } else {
          extStart = extend2.items(0);
          extEnd = extend2.items(1);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfLinearGradientBrush2.prototype.addPoints = function(point1, point2) {
      var x = point1.x + point2.x;
      var y = point1.y + point2.y;
      var result = new PointF(x, y);
      return result;
    };
    PdfLinearGradientBrush2.prototype.subPoints = function(point1, point2) {
      var x = point1.x - point2.x;
      var y = point1.y - point2.y;
      var result = new PointF(x, y);
      return result;
    };
    PdfLinearGradientBrush2.prototype.mulPoints = function(point1, point2) {
      var result = point1.x * point2.x + point1.y * point2.y;
      return result;
    };
    PdfLinearGradientBrush2.prototype.mulPoint = function(point, value) {
      point.x = point.x * value;
      point.y = point.y * value;
      return point;
    };
    PdfLinearGradientBrush2.prototype.choosePoint = function(angle) {
      var point = new PointF(0, 0);
      if (angle < 90 && angle > 0) {
        point = new PointF(this.mBoundaries.right, this.mBoundaries.bottom);
      } else if (angle < 180 && angle > 90) {
        point = new PointF(this.mBoundaries.left, this.mBoundaries.bottom);
      } else if (angle < 270 && angle > 180) {
        point = new PointF(this.mBoundaries.left, this.mBoundaries.top);
      } else if (angle > 270) {
        point = new PointF(this.mBoundaries.right, this.mBoundaries.top);
      } else {
        throw new Error("PdfException - Internal error.");
      }
      return point;
    };
    PdfLinearGradientBrush2.prototype.setPoints = function(point1, point2) {
      var points = new PdfArray();
      points.add(new PdfNumber(point1.x));
      points.add(new PdfNumber(this.updateY(point1.y)));
      points.add(new PdfNumber(point2.x));
      points.add(new PdfNumber(this.updateY(point2.y)));
      this.shading.items.setValue(this.mDictionaryProperties.coords, points);
    };
    PdfLinearGradientBrush2.prototype.updateY = function(y) {
      if (y !== 0) {
        return -y;
      } else {
        return y;
      }
    };
    PdfLinearGradientBrush2.prototype.initShading = function() {
      this.colorSpace = PdfColorSpace.Rgb;
      this.function = this.mColourBlend.getFunction(this.colorSpace);
      this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Axial));
    };
    PdfLinearGradientBrush2.prototype.clone = function() {
      var brush = this;
      brush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));
      brush.shading = new PdfDictionary();
      brush.initShading();
      brush.setPoints(brush.mPointStart, brush.mPointEnd);
      if (brush !== null && brush instanceof PdfLinearGradientBrush2) {
        if (this.matrix != null && typeof this.matrix !== "undefined") {
          brush.matrix = this.matrix.clone();
        }
      }
      if (this.mColours != null && typeof this.mColours !== "undefined") {
        brush.mColours = this.mColours;
      }
      if (this.blend != null && typeof this.blend !== "undefined") {
        brush.blend = this.blend.clonePdfBlend();
      } else if (this.interpolationColors != null && typeof this.interpolationColors !== "undefined") {
        brush.interpolationColors = this.interpolationColors.cloneColorBlend();
      }
      brush.extend = this.extend;
      this.cloneBackgroundValue(brush);
      this.cloneAntiAliasingValue(brush);
      return brush;
    };
    PdfLinearGradientBrush2.prototype.resetFunction = function() {
      this.function = this.mColourBlend.getFunction(this.colorSpace);
    };
    return PdfLinearGradientBrush2;
  }(PdfGradientBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-radial-gradient-brush.js
var __extends35 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfRadialGradientBrush = (
  /** @class */
  function(_super) {
    __extends35(PdfRadialGradientBrush2, _super);
    function PdfRadialGradientBrush2(centerStart, radiusStart, centerEnd, radiusEnd, colorStart, colorEnd) {
      var _this = _super.call(this, new PdfDictionary()) || this;
      _this.mDictionaryProperties = new DictionaryProperties();
      _this.initialize(colorStart, colorEnd);
      if (radiusStart < 0) {
        throw new Error("ArgumentOutOfRangeException : radiusStart - The radius cannot be less then zero.");
      }
      if (radiusEnd < 0) {
        throw new Error("ArgumentOutOfRangeException : radiusEnd - The radius cannpt be less then zero.");
      }
      _this.mPointEnd = centerEnd;
      _this.mPointStart = centerStart;
      _this.mRadiusStart = radiusStart;
      _this.mRadiusEnd = radiusEnd;
      _this.setPoints(_this.mPointStart, _this.mPointEnd, _this.mRadiusStart, _this.mRadiusEnd);
      return _this;
    }
    PdfRadialGradientBrush2.prototype.initialize = function(color1, color2) {
      this.mColour = [color1, color2];
      this.mColourBlends = new PdfColorBlend(2);
      this.mColourBlends.positions = [0, 1];
      this.mColourBlends.colors = this.mColour;
      this.initShading();
    };
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "blend", {
      //Properties
      /**
       * Gets or sets a PdfBlend that specifies positions and factors that define a custom falloff for the gradient.
       * @public
       */
      get: function() {
        return this.mBlend;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Blend");
        }
        if (this.mColour == null && typeof this.mColour === "undefined") {
          throw new Error("NotSupportedException : There is no starting and ending colours specified.");
        }
        this.mBlend = value;
        this.mColourBlends = this.mBlend.generateColorBlend(this.mColour, this.colorSpace);
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "interpolationColors", {
      /**
       * Gets or sets a ColorBlend that defines a multicolor radial gradient.
       * @public
       */
      get: function() {
        return this.mColourBlends;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : InterpolationColors");
        }
        this.mBlend = null;
        this.mColour = null;
        this.mColourBlends = value;
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "linearColors", {
      /**
       * Gets or sets the starting and ending colors of the radial gradient.
       * @public
       */
      get: function() {
        return this.mColour;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : radial LinearColors");
        }
        if (value.length < 2) {
          throw new Error("ArgumentException : The array is too small LinearColors");
        }
        if (this.mColour == null && typeof this.mColour === "undefined") {
          this.mColour = [value[0], value[1]];
        } else {
          this.mColour[0] = value[0];
          this.mColour[1] = value[1];
        }
        if (this.mBlend == null && typeof this.mBlend === "undefined") {
          this.mColourBlends = new PdfColorBlend(2);
          this.mColourBlends.colors = this.mColour;
          this.mColourBlends.positions = [0, 1];
        } else {
          this.mColourBlends = this.mBlend.generateColorBlend(this.mColour, this.colorSpace);
        }
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "rectangle", {
      /**
       * Gets or sets the rectangle.
       * @public
       */
      get: function() {
        return this.mBoundaries;
      },
      set: function(value) {
        this.mBoundaries = value;
        this.bBox = PdfArray.fromRectangle(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "extend", {
      /**
       * Gets or sets the value indicating whether the gradient
       *  should extend starting and ending points.
       * @public
       */
      get: function() {
        var result1 = PdfExtend.None;
        var extend1 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        if (extend1 !== null && typeof extend1 !== "undefined") {
          var extStart = extend1.items(0);
          var extEnd = extend1.items(1);
          if (extStart.value) {
            result1 = result1 | PdfExtend.Start;
          }
          if (extEnd.value) {
            result1 = result1 | PdfExtend.End;
          }
        }
        return result1;
      },
      set: function(value) {
        var extend2 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        var extStart;
        var extEnd1;
        if (extend2 == null && typeof extend2 === "undefined") {
          extStart = new PdfBoolean(false);
          extEnd1 = new PdfBoolean(false);
          extend2 = new PdfArray();
          extend2.add(extStart);
          extend2.add(extEnd1);
          this.shading.items.setValue(this.mDictionaryProperties.extend, extend2);
        } else {
          extStart = extend2.items(0);
          extEnd1 = extend2.items(1);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfRadialGradientBrush2.prototype.setPoints = function(pointStart, pointEnd, radiusStart, radiusEnd) {
      var points = new PdfArray();
      points.add(new PdfNumber(pointStart.x));
      points.add(new PdfNumber(this.updateY(pointStart.y)));
      points.add(new PdfNumber(radiusStart));
      points.add(new PdfNumber(pointEnd.x));
      points.add(new PdfNumber(this.updateY(pointEnd.y)));
      if (radiusStart !== radiusEnd) {
        points.add(new PdfNumber(radiusEnd));
      } else {
        points.add(new PdfNumber(0));
      }
      this.shading.items.setValue(this.mDictionaryProperties.coords, points);
    };
    PdfRadialGradientBrush2.prototype.updateY = function(y) {
      if (y !== 0) {
        return -y;
      } else {
        return y;
      }
    };
    PdfRadialGradientBrush2.prototype.initShading = function() {
      this.colorSpace = PdfColorSpace.Rgb;
      this.function = this.mColourBlends.getFunction(this.colorSpace);
      this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Radial));
    };
    PdfRadialGradientBrush2.prototype.clone = function() {
      var rBrush = this;
      rBrush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));
      rBrush.shading = new PdfDictionary();
      rBrush.initShading();
      rBrush.setPoints(this.mPointStart, this.mPointEnd, this.mRadiusStart, this.mRadiusEnd);
      if (rBrush instanceof PdfRadialGradientBrush2) {
        if (this.matrix !== null && typeof this.matrix !== "undefined") {
          rBrush.matrix = this.matrix.clone();
        }
      }
      if (this.mColour !== null && typeof this.mColour !== "undefined") {
        rBrush.mColour = this.mColour;
      }
      if (this.blend !== null && typeof this.blend !== "undefined") {
        rBrush.blend = this.blend.clonePdfBlend();
      } else if (this.interpolationColors !== null && typeof this.interpolationColors !== "undefined") {
        rBrush.interpolationColors = this.interpolationColors.cloneColorBlend();
      }
      rBrush.extend = this.extend;
      this.cloneBackgroundValue(rBrush);
      this.cloneAntiAliasingValue(rBrush);
      return rBrush;
    };
    PdfRadialGradientBrush2.prototype.resetFunction = function() {
      this.function = this.mColourBlends.getFunction(this.colorSpace);
    };
    return PdfRadialGradientBrush2;
  }(PdfGradientBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/shape-layouter.js
var __extends36 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ShapeLayouter = (
  /** @class */
  function(_super) {
    __extends36(ShapeLayouter2, _super);
    function ShapeLayouter2(element) {
      var _this = _super.call(this, element) || this;
      _this.olderPdfForm = 0;
      _this.shapeBounds = new RectangleF();
      _this.totalPageSize = 0;
      return _this;
    }
    Object.defineProperty(ShapeLayouter2.prototype, "element", {
      // Properties
      /**
       * Gets shape element.
       * @private
       */
      get: function() {
        return this.elements;
      },
      enumerable: true,
      configurable: true
    });
    ShapeLayouter2.prototype.layoutInternal = function(param) {
      var currentPage = param.page;
      var currentBounds = param.bounds;
      var shapeLayoutBounds = this.element.getBounds();
      shapeLayoutBounds.x = 0;
      shapeLayoutBounds.y = 0;
      var isEmpty = this.shapeBounds.x === this.shapeBounds.y && this.shapeBounds.y === this.shapeBounds.width && this.shapeBounds.width === this.shapeBounds.height && this.shapeBounds.height === 0 ? true : false;
      if (this.isPdfGrid && !isEmpty) {
        shapeLayoutBounds = this.shapeBounds;
      }
      var result = null;
      var pageResult = new ShapeLayoutResult();
      pageResult.page = currentPage;
      while (true) {
        var result1 = this.raiseBeforePageLayout(currentPage, currentBounds);
        currentBounds = result1.currentBounds;
        var endArgs = null;
        if (!result1.cancel) {
          pageResult = this.layoutOnPage(currentPage, currentBounds, shapeLayoutBounds, param);
          endArgs = this.raiseEndPageLayout(pageResult);
          result1.cancel = endArgs === null ? false : endArgs.cancel;
        }
        if (!pageResult.end && !result1.cancel) {
          currentBounds = this.getPaginateBounds(param);
          shapeLayoutBounds = this.getNextShapeBounds(shapeLayoutBounds, pageResult);
          currentPage = endArgs === null || endArgs.nextPage === null ? this.getNextPage(currentPage) : endArgs.nextPage;
          if (this.isPdfGrid) {
            result = this.getLayoutResult(pageResult);
            break;
          }
        } else {
          result = this.getLayoutResult(pageResult);
          break;
        }
      }
      return result;
    };
    ShapeLayouter2.prototype.raiseBeforePageLayout = function(currentPage, currentBounds) {
      var cancel = false;
      if (this.element.raiseBeginPageLayout) {
        var args = new BeginPageLayoutEventArgs(currentBounds, currentPage);
        this.element.onBeginPageLayout(args);
        cancel = args.cancel;
        currentBounds = args.bounds;
      }
      return { currentBounds, cancel };
    };
    ShapeLayouter2.prototype.raiseEndPageLayout = function(pageResult) {
      var args = null;
      if (this.element.raiseEndPageLayout) {
        var res = this.getLayoutResult(pageResult);
        args = new EndPageLayoutEventArgs(res);
        this.element.onEndPageLayout(args);
      }
      return args;
    };
    ShapeLayouter2.prototype.getLayoutResult = function(pageResult) {
      var result = new PdfLayoutResult(pageResult.page, pageResult.bounds);
      return result;
    };
    ShapeLayouter2.prototype.getNextShapeBounds = function(shapeLayoutBounds, pageResult) {
      var layoutedBounds = pageResult.bounds;
      shapeLayoutBounds.y = shapeLayoutBounds.y + layoutedBounds.height;
      shapeLayoutBounds.height = shapeLayoutBounds.height - layoutedBounds.height;
      return shapeLayoutBounds;
    };
    ShapeLayouter2.prototype.layoutOnPage = function(currentPage, curBounds, sBounds, param) {
      var result = new ShapeLayoutResult();
      curBounds = this.checkCorrectCurrentBounds(currentPage, curBounds, param);
      var fitToPage = this.fitsToBounds(curBounds, sBounds);
      var canDraw = !(param.format.break === PdfLayoutBreakType.FitElement && (!fitToPage && currentPage === param.page));
      var shapeFinished = false;
      if (canDraw) {
        var drawRectangle = this.getDrawBounds(curBounds, sBounds);
        this.drawShape(currentPage.graphics, curBounds, drawRectangle);
        result.bounds = this.getPageResultBounds(curBounds, sBounds);
        shapeFinished = curBounds.height >= sBounds.height;
      }
      result.end = shapeFinished || param.format.layout === PdfLayoutType.OnePage;
      result.page = currentPage;
      return result;
    };
    ShapeLayouter2.prototype.getDrawBounds = function(currentBounds, shapeLayoutBounds) {
      var result = currentBounds;
      result.y = result.y - shapeLayoutBounds.y;
      result.height = result.height + shapeLayoutBounds.y;
      return result;
    };
    ShapeLayouter2.prototype.drawShape = function(g, currentBounds, drawRectangle) {
      var gState = g.save();
      try {
        g.setClip(currentBounds);
        this.element.drawGraphicsHelper(g, new PointF(drawRectangle.x, drawRectangle.y));
      } finally {
        g.restore(gState);
      }
    };
    ShapeLayouter2.prototype.checkCorrectCurrentBounds = function(currentPage, curBounds, param) {
      var pageSize = currentPage.graphics.clientSize;
      curBounds.width = curBounds.width > 0 ? curBounds.width : pageSize.width - curBounds.x;
      curBounds.height = curBounds.height > 0 ? curBounds.height : pageSize.height - curBounds.y;
      if (this.isPdfGrid) {
        curBounds.height = curBounds.height - this.bottomCellPadding;
      }
      return curBounds;
    };
    ShapeLayouter2.prototype.getPageResultBounds = function(currentBounds, shapeLayoutBounds) {
      var result = currentBounds;
      result.height = Math.min(result.height, shapeLayoutBounds.height);
      return result;
    };
    ShapeLayouter2.prototype.fitsToBounds = function(currentBounds, shapeLayoutBounds) {
      var fits = shapeLayoutBounds.height <= currentBounds.height;
      return fits;
    };
    ShapeLayouter2.index = 0;
    ShapeLayouter2.splitDiff = 0;
    ShapeLayouter2.last = false;
    ShapeLayouter2.borderWidth = 0;
    return ShapeLayouter2;
  }(ElementLayouter)
);
var ShapeLayoutResult = (
  /** @class */
  function() {
    function ShapeLayoutResult2() {
    }
    return ShapeLayoutResult2;
  }()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/pdf-shape-element.js
var __extends37 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfShapeElement = (
  /** @class */
  function(_super) {
    __extends37(PdfShapeElement2, _super);
    function PdfShapeElement2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PdfShapeElement2.prototype.getBounds = function() {
      var rect = this.getBoundsInternal();
      return rect;
    };
    PdfShapeElement2.prototype.drawGraphicsHelper = function(graphics, location) {
      if (graphics == null) {
        throw new Error("ArgumentNullException :graphics");
      }
      this.drawShapeHelper(graphics, location.x, location.y);
    };
    PdfShapeElement2.prototype.drawShapeHelper = function(graphics, x, y) {
      var bNeedSave = x !== 0.5 || y !== 0.5;
      var gState = null;
      if (bNeedSave) {
        gState = graphics.save();
        graphics.translateTransform(x, y);
      }
      this.drawInternal(graphics);
      if (bNeedSave) {
        graphics.restore(gState);
      }
    };
    PdfShapeElement2.prototype.layout = function(param) {
      var layouter = new ShapeLayouter(this);
      var result = layouter.layout(param);
      return result;
    };
    return PdfShapeElement2;
  }(PdfLayoutElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/draw-element.js
var __extends38 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfDrawElement = (
  /** @class */
  function(_super) {
    __extends38(PdfDrawElement2, _super);
    function PdfDrawElement2(pen) {
      var _this = _super.call(this) || this;
      if (typeof pen !== "undefined") {
        _this.mpen = pen;
      }
      return _this;
    }
    Object.defineProperty(PdfDrawElement2.prototype, "pen", {
      // Properties
      /**
       * Gets or sets a pen that will be used to draw the element.
       * @public
       */
      get: function() {
        return this.mpen;
      },
      set: function(value) {
        this.mpen = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfDrawElement2;
  }(PdfShapeElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/fill-element.js
var __extends39 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfFillElement = (
  /** @class */
  function(_super) {
    __extends39(PdfFillElement2, _super);
    function PdfFillElement2(arg1, arg2) {
      var _this = _super.call(this) || this;
      _this.mbrush = null;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof PdfPen) {
        _this = _super.call(this, arg1) || this;
      } else {
        _this.mbrush = arg2;
      }
      return _this;
    }
    Object.defineProperty(PdfFillElement2.prototype, "brush", {
      // Properties
      /**
       * Gets or sets a brush of the element.
       * @public
       */
      get: function() {
        return this.mbrush;
      },
      set: function(value) {
        this.mbrush = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfFillElement2.prototype.obtainPen = function() {
      return this.mbrush == null && this.pen == null ? new PdfPen(new PdfColor(0, 0, 0)) : this.pen;
    };
    return PdfFillElement2;
  }(PdfDrawElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/path.js
var __extends40 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfPath = (
  /** @class */
  function(_super) {
    __extends40(PdfPath2, _super);
    function PdfPath2(arg1, arg2, arg3, arg4) {
      var _this = _super.call(this) || this;
      _this.mpoints = null;
      _this.mpathTypes = null;
      _this.mStartFigure = true;
      _this.mfillMode = PdfFillMode.Alternate;
      _this.isBeziers3 = false;
      _this.isXps = false;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof PdfPen) {
        _this = _super.call(this, arg1) || this;
        if (arg2 instanceof PdfBrush) {
          _this = _super.call(this, arg1, arg2) || this;
          _this.fillMode = arg3;
        } else if (arg2 !== null && typeof arg2 !== "undefined" && arg3 !== null && typeof arg3 !== "undefined") {
          _this.addPath(arg2, arg3);
        }
      } else if (arg1 instanceof PdfBrush) {
        _this = _super.call(this, arg1) || this;
        if (arg2 !== null && typeof arg2 !== "undefined") {
          _this.fillMode = arg2;
        }
        if (arg3 !== null && typeof arg3 !== "undefined" && arg4 !== null && typeof arg4 !== "undefined") {
          _this.addPath(arg3, arg4);
        }
      } else {
        _this.addPath(arg1, arg2);
      }
      return _this;
    }
    Object.defineProperty(PdfPath2.prototype, "fillMode", {
      // Properties
      /**
       * Gets or sets the fill mode.
       * @public
       */
      get: function() {
        return this.mfillMode;
      },
      set: function(value) {
        this.mfillMode = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "pathPoints", {
      /**
       * Gets the path points.
       * @public
       */
      get: function() {
        return this.points;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "pathTypes", {
      /**
       * Gets the path point types.
       * @public
       */
      get: function() {
        return this.types;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "pointCount", {
      /**
       * Gets the point count.
       * @public
       */
      get: function() {
        var count = 0;
        if (this.mpoints != null) {
          count = this.mpoints.length;
        }
        return count;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "lastPoint", {
      /**
       * Gets the last points.
       * @public
       */
      get: function() {
        return this.getLastPoint();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "points", {
      /**
       * Gets the points list.
       * @private
       */
      get: function() {
        if (this.mpoints == null) {
          this.mpoints = [];
        }
        return this.mpoints;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "types", {
      /**
       * Gets the types.
       * @private
       */
      get: function() {
        if (this.mpathTypes == null) {
          this.mpathTypes = [];
        }
        return this.mpathTypes;
      },
      enumerable: true,
      configurable: true
    });
    PdfPath2.prototype.draw = function(arg1, arg2, arg3, arg4) {
      if (arg2 instanceof PointF && typeof arg2.width === "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2.x, arg2.y);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2, null);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        return this.drawHelper(arg1, arg2, arg3, null);
      } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg1, arg2.x, arg2.y, arg3);
      } else if (typeof arg2 === "number" && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === "number") {
        var widthValue = arg1.graphics.clientSize.width - arg2;
        var layoutRect = new RectangleF(arg2, arg3, widthValue, 0);
        return this.drawHelper(arg1, layoutRect, arg4);
      } else if (arg2 instanceof RectangleF && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg1, arg2, arg3);
      } else {
        return this.drawHelper(arg1, arg2, arg3);
      }
    };
    PdfPath2.prototype.addArc = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof RectangleF) {
        this.addArc(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);
      } else {
        var points = this.getBezierArcPoints(arg1, arg2, arg2 + arg3, arg2 + arg4, arg5, arg6);
        for (var i = 0; i < points.length; i = i + 8) {
          var point = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];
          this.addPoints(point, PathPointType.Bezier3);
        }
      }
    };
    PdfPath2.prototype.addBezier = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF && arg4 instanceof PointF) {
        this.addBezier(arg1.x, arg1.y, arg2.x, arg2.y, arg3.x, arg3.y, arg4.x, arg4.y);
      } else {
        var points = [];
        points.push(arg1);
        points.push(arg2);
        points.push(arg3);
        points.push(arg4);
        points.push(arg5);
        points.push(arg6);
        points.push(arg7);
        points.push(arg8);
        this.addPoints(points, PathPointType.Bezier3);
      }
    };
    PdfPath2.prototype.addEllipse = function(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof RectangleF) {
        this.addEllipse(arg1.x, arg1.y, arg1.width, arg1.height);
      } else {
        this.startFigure();
        this.addArc(arg1, arg2, arg3, arg4, 0, 360);
        this.closeFigure();
      }
    };
    PdfPath2.prototype.addLine = function(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof PointF && arg2 instanceof PointF) {
        this.addLine(arg1.x, arg1.y, arg2.x, arg2.y);
      } else {
        var points = [];
        points.push(arg1);
        points.push(arg2);
        points.push(arg3);
        points.push(arg4);
        this.addPoints(points, PathPointType.Line);
      }
    };
    PdfPath2.prototype.addPath = function(arg1, arg2) {
      if (arg1 instanceof PdfPath2) {
        this.addPath(arg1.pathPoints, arg1.pathTypes);
      } else {
        if (arg1 == null) {
          throw new Error("ArgumentNullException:pathPoints");
        }
        if (arg2 == null) {
          throw new Error("ArgumentNullException:pathTypes");
        }
        var count = arg1.length;
        if (count !== arg2.length) {
          throw new Error("The argument arrays should be of equal length.");
        }
      }
    };
    PdfPath2.prototype.addPie = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof RectangleF) {
        this.addPie(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);
      } else {
        this.startFigure();
        this.addArc(arg1, arg2, arg3, arg4, arg5, arg6);
        this.addPoint(new PointF(arg1 + arg3 / 2, arg2 + arg4 / 2), PathPointType.Line);
        this.closeFigure();
      }
    };
    PdfPath2.prototype.addPolygon = function(points) {
      var count = points.length * 2;
      var p = [];
      this.startFigure();
      for (var i = 0; i < points.length; i++) {
        p.push(points[i].x);
        p.push(points[i].y);
      }
      this.addPoints(p, PathPointType.Line);
      this.closeFigure();
    };
    PdfPath2.prototype.addRectangle = function(arg1, y, width, height) {
      if (arg1 instanceof RectangleF) {
        this.addRectangle(arg1.x, arg1.y, arg1.width, arg1.height);
      } else {
        var points = [];
        this.startFigure();
        points.push(arg1);
        points.push(y);
        points.push(arg1 + width);
        points.push(y);
        points.push(arg1 + width);
        points.push(y + height);
        points.push(arg1);
        points.push(y + height);
        this.addPoints(points, PathPointType.Line);
        this.closeFigure();
      }
    };
    PdfPath2.prototype.startFigure = function() {
      this.mStartFigure = true;
    };
    PdfPath2.prototype.closeAllFigures = function() {
      var startPath = this.pathPoints[0];
      for (var i = 0; i < this.mpathTypes.length; i++) {
        var pt = this.types[i];
        var flag = false;
        if (i !== 0 && pt === PathPointType.Start) {
          this.closeFigure(i - 1);
          flag = true;
        } else if (i === this.mpathTypes.length - 1 && (!flag && this.isXps)) {
          if (startPath.x === this.pathPoints[i].y) {
            this.closeFigure(i);
          }
        }
      }
    };
    PdfPath2.prototype.getLastPoint = function() {
      var lastPoint = new PointF(0, 0);
      var count = this.pointCount;
      if (count > 0 && this.mpoints != null) {
        lastPoint.x = this.mpoints[count - 1].x;
        lastPoint.y = this.mpoints[count - 1].y;
      }
      return lastPoint;
    };
    PdfPath2.prototype.getBezierArcPoints = function(x1, y1, x2, y2, s1, e1) {
      if (x1 > x2) {
        var tmp = void 0;
        tmp = x1;
        x1 = x2;
        x2 = tmp;
      }
      if (y2 > y1) {
        var tmp = void 0;
        tmp = y1;
        y1 = y2;
        y2 = tmp;
      }
      var fragAngle;
      var numFragments;
      if (Math.abs(e1) <= 90) {
        fragAngle = e1;
        numFragments = 1;
      } else {
        numFragments = Math.ceil(Math.abs(e1) / 90);
        fragAngle = e1 / numFragments;
      }
      var xcen = (x1 + x2) / 2;
      var ycen = (y1 + y2) / 2;
      var rx = (x2 - x1) / 2;
      var ry = (y2 - y1) / 2;
      var halfAng = fragAngle * (Math.PI / 360);
      var kappa = Math.abs(4 / 3 * (1 - Math.cos(halfAng)) / Math.sin(halfAng));
      var pointList = [];
      for (var i = 0; i < numFragments; i++) {
        var theta0 = (s1 + i * fragAngle) * (Math.PI / 180);
        var theta1 = (s1 + (i + 1) * fragAngle) * (Math.PI / 180);
        var cos0 = Math.cos(theta0);
        var cos1 = Math.cos(theta1);
        var sin0 = Math.sin(theta0);
        var sin1 = Math.sin(theta1);
        if (fragAngle > 0) {
          pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        } else {
          pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        }
      }
      return pointList;
    };
    PdfPath2.prototype.getBoundsInternal = function() {
      var points = this.pathPoints;
      var bounds = new RectangleF(0, 0, 0, 0);
      if (points.length > 0) {
        var xmin = points[0].x;
        var xmax = points[0].x;
        var ymin = points[0].y;
        var ymax = points[0].y;
        for (var i = 1; i < points.length; i++) {
          var point = points[i];
          xmin = Math.min(point.x, xmin);
          xmax = Math.max(point.x, xmax);
          ymin = Math.min(point.y, ymin);
          ymax = Math.max(point.y, ymax);
        }
        bounds = new RectangleF(xmin, ymin, xmax - xmin, ymax - ymin);
      }
      return bounds;
    };
    PdfPath2.prototype.drawInternal = function(graphics) {
      if (graphics == null) {
        throw new Error("ArgumentNullException :graphics");
      }
      graphics.drawPath(this.obtainPen(), this.brush, this);
    };
    PdfPath2.prototype.addPoints = function(points, pointType, startIndex, endIndex) {
      if (typeof startIndex === "undefined" && typeof endIndex === "undefined") {
        this.addPoints(points, pointType, 0, points.length);
      } else {
        for (var i = startIndex; i < endIndex; i++) {
          var point = new PointF(points[i], points[i + 1]);
          if (i === startIndex) {
            if (this.pointCount <= 0 || this.mStartFigure) {
              this.addPoint(point, PathPointType.Start);
              this.mStartFigure = false;
            } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y && !this.isBeziers3) {
              this.addPoint(point, PathPointType.Line);
            } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y) {
              this.addPoint(point, PathPointType.Bezier3);
            }
          } else {
            this.addPoint(point, pointType);
          }
          i++;
        }
      }
    };
    PdfPath2.prototype.addPoint = function(point, pointType) {
      this.points.push(point);
      this.types.push(pointType);
    };
    PdfPath2.prototype.closeFigure = function(index) {
      if (typeof index === "undefined") {
        if (this.pointCount > 0) {
          this.closeFigure(this.pointCount - 1);
        }
        this.startFigure();
      } else {
        if (index < 0) {
          throw new Error("IndexOutOfRangeException()");
        }
        var pt = this.types[index];
        pt = pt | PathPointType.CloseSubpath;
        this.types[index] = pt;
      }
    };
    return PdfPath2;
  }(PdfFillElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/rectangle-area.js
var __extends41 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfRectangleArea = (
  /** @class */
  function(_super) {
    __extends41(PdfRectangleArea2, _super);
    function PdfRectangleArea2(arg1, arg2, arg3, arg4, arg5, arg6) {
      var _this = _super.call(this) || this;
      _this.bounds = new RectangleF(0, 0, 0, 0);
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof PdfPen) {
        _this = _super.call(this, arg1, arg2) || this;
        if (arg3 instanceof RectangleF) {
          _this.bounds = arg3;
        } else {
          _this.bounds = new RectangleF(arg3, arg4, arg5, arg6);
        }
      } else if (arg1 instanceof RectangleF) {
        _this.bounds = arg1;
      } else {
        _this.bounds = new RectangleF(arg1, arg2, arg3, arg4);
      }
      return _this;
    }
    Object.defineProperty(PdfRectangleArea2.prototype, "x", {
      //Properties
      /**
       * Gets or sets the X co-ordinate of the upper-left corner of this the element.
       * @public
       */
      get: function() {
        return this.bounds.x;
      },
      set: function(value) {
        this.bounds.x = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRectangleArea2.prototype, "y", {
      /**
       * Gets or sets the Y co-ordinate of the upper-left corner of this the element.
       * @public
       */
      get: function() {
        return this.bounds.y;
      },
      set: function(value) {
        this.bounds.y = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRectangleArea2.prototype, "width", {
      /**
       * Gets or sets the width of this element.
       * @public
       */
      get: function() {
        return this.bounds.width;
      },
      set: function(value) {
        this.bounds.width = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRectangleArea2.prototype, "height", {
      /**
       * Gets or sets the height of this element.
       * @public
       */
      get: function() {
        return this.bounds.height;
      },
      set: function(value) {
        this.bounds.height = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfRectangleArea2.prototype.getBoundsInternal = function() {
      return this.bounds;
    };
    return PdfRectangleArea2;
  }(PdfFillElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/ellipse-part.js
var __extends42 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfEllipsePart = (
  /** @class */
  function(_super) {
    __extends42(PdfEllipsePart2, _super);
    function PdfEllipsePart2(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      var _this = _super.call(this) || this;
      _this.startAngle = 0;
      _this.sweepAngle = 0;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof RectangleF && typeof arg2 !== "undefined" && typeof arg3 !== "undefined") {
        _this = _super.call(this, arg1) || this;
        _this.startAngle = arg2;
        _this.sweepAngle = arg3;
      } else if (arg1 instanceof PdfPen) {
        if (arg3 instanceof RectangleF) {
          _this = _super.call(this, arg1, arg2, arg3) || this;
          _this.startAngle = arg4;
          _this.sweepAngle = arg5;
        } else {
          _this = _super.call(this, arg1, arg2, arg3, arg4, arg5, arg6) || this;
          _this.startAngle = arg7;
          _this.sweepAngle = arg8;
        }
      } else {
        _this = _super.call(this, arg1, arg2, arg3, arg4) || this;
        _this.startAngle = arg5;
        _this.sweepAngle = arg6;
      }
      return _this;
    }
    return PdfEllipsePart2;
  }(PdfRectangleArea)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/arc.js
var __extends43 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PdfArc = (
  /** @class */
  function(_super) {
    __extends43(PdfArc2, _super);
    function PdfArc2(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      var _this = this;
      if (typeof arg1 === "undefined") {
        _this = _super.call(this) || this;
      } else if (arg1 instanceof RectangleF) {
        _this = _super.call(this, arg1, arg2, arg3) || this;
      } else if (arg1 instanceof PdfPen) {
        if (arg2 instanceof RectangleF) {
          _this = _super.call(this, arg1, null, arg2, arg3, arg4) || this;
        } else if (typeof arg6 === "undefined" && typeof arg7 === "undefined") {
          _this = _super.call(this, arg1, null, 0, 0, arg2, arg3, arg4, arg5) || this;
        } else if (typeof arg6 !== "undefined" && typeof arg7 !== "undefined") {
          _this = _super.call(this, arg1, null, arg2, arg3, arg4, arg5, arg6, arg7) || this;
        }
      } else if (typeof arg1 !== "undefined" && typeof arg5 === "undefined" && typeof arg6 === "undefined") {
        _this = _super.call(this, 0, 0, arg1, arg2, arg3, arg4) || this;
      } else if (typeof arg1 !== "undefined" && typeof arg5 !== "undefined" && typeof arg6 !== "undefined") {
        _this = _super.call(this, arg1, arg2, arg3, arg4, arg5, arg6) || this;
      }
      return _this;
    }
    PdfArc2.prototype.draw = function(argu1, arg2, arg3, arg4) {
      if (arg2 instanceof PointF && typeof arg2.width === "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(argu1, arg2.x, arg2.y);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(argu1, arg2, null);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        return this.drawHelper(argu1, arg2, arg3, null);
      } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(argu1, arg2.x, arg2.y, arg3);
      } else if (typeof arg2 === "number" && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === "number") {
        var widthValue = argu1.graphics.clientSize.width - arg2;
        var layoutRect = new RectangleF(arg2, arg3, widthValue, 0);
        return this.drawHelper(argu1, layoutRect, arg4);
      } else {
        return this.drawHelper(argu1, arg2, arg3);
      }
    };
    PdfArc2.prototype.drawInternal = function(graphics) {
      if (graphics == null) {
        throw new Error("ArgumentNullException : graphics");
      }
      graphics.drawArc(this.obtainPen(), this.bounds, this.startAngle, this.sweepAngle);
    };
    return PdfArc2;
  }(PdfEllipsePart)
);

// node_modules/@syncfusion/ej2-calendars/src/calendar/calendar.js
var __extends44 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var OTHERMONTH = "e-other-month";
var OTHERDECADE = "e-other-year";
var ROOT = "e-calendar";
var DEVICE = "e-device";
var HEADER = "e-header";
var RTL = "e-rtl";
var CONTENT = "e-content";
var YEAR = "e-year";
var MONTH = "e-month";
var DECADE = "e-decade";
var ICON = "e-icons";
var PREVICON = "e-prev";
var NEXTICON = "e-next";
var PREVSPAN = "e-date-icon-prev";
var NEXTSPAN = "e-date-icon-next ";
var ICONCONTAINER = "e-icon-container";
var DISABLED = "e-disabled";
var OVERLAY = "e-overlay";
var WEEKEND = "e-weekend";
var WEEKNUMBER = "e-week-number";
var SELECTED = "e-selected";
var FOCUSEDDATE = "e-focused-date";
var OTHERMONTHROW = "e-month-hide";
var TODAY = "e-today";
var TITLE = "e-title";
var LINK = "e-day";
var CELL = "e-cell";
var WEEKHEADER = "e-week-header";
var ZOOMIN = "e-zoomin";
var FOOTER = "e-footer-container";
var BTN = "e-btn";
var FLAT = "e-flat";
var CSS = "e-css";
var PRIMARY = "e-primary";
var DAYHEADERLONG = "e-calendar-day-header-lg";
var dayMilliSeconds = 864e5;
var minutesMilliSeconds = 6e4;
var CalendarBase = (
  /** @class */
  function(_super) {
    __extends44(CalendarBase2, _super);
    function CalendarBase2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.effect = "";
      _this.isPopupClicked = false;
      _this.isDateSelected = true;
      _this.isTodayClicked = false;
      _this.preventChange = false;
      _this.isAngular = false;
      return _this;
    }
    CalendarBase2.prototype.render = function() {
      this.rangeValidation(this.min, this.max);
      this.calendarEleCopy = this.element.cloneNode(true);
      if (this.calendarMode === "Islamic") {
        if (+this.min.setSeconds(0) === +new Date(1900, 0, 1, 0, 0, 0)) {
          this.min = new Date(1944, 2, 18);
        }
        if (+this.max === +new Date(2099, 11, 31)) {
          this.max = new Date(2069, 10, 16);
        }
      }
      this.globalize = new Internationalization(this.locale);
      if (isNullOrUndefined(this.firstDayOfWeek) || this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {
        this.setProperties({ firstDayOfWeek: this.globalize.getFirstDayOfWeek() }, true);
      }
      this.todayDisabled = false;
      this.todayDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      if (this.getModuleName() === "calendar") {
        this.element.classList.add(ROOT);
        if (this.enableRtl) {
          this.element.classList.add(RTL);
        }
        if (Browser.isDevice) {
          this.element.classList.add(DEVICE);
        }
        attributes(this.element, {
          "data-role": "calendar"
        });
        this.tabIndex = this.element.hasAttribute("tabindex") ? this.element.getAttribute("tabindex") : "0";
        this.element.setAttribute("tabindex", this.tabIndex);
      } else {
        this.calendarElement = this.createElement("div");
        this.calendarElement.classList.add(ROOT);
        if (this.enableRtl) {
          this.calendarElement.classList.add(RTL);
        }
        if (Browser.isDevice) {
          this.calendarElement.classList.add(DEVICE);
        }
        attributes(this.calendarElement, {
          "role": "calendar"
        });
      }
      this.createHeader();
      this.createContent();
      this.wireEvents();
    };
    CalendarBase2.prototype.rangeValidation = function(min, max) {
      if (isNullOrUndefined(min)) {
        this.setProperties({ min: new Date(1900, 0, 1) }, true);
      }
      if (isNullOrUndefined(max)) {
        this.setProperties({ max: new Date(2099, 11, 31) }, true);
      }
    };
    CalendarBase2.prototype.getDefaultKeyConfig = function() {
      this.defaultKeyConfigs = {
        controlUp: "ctrl+38",
        controlDown: "ctrl+40",
        moveDown: "downarrow",
        moveUp: "uparrow",
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        select: "enter",
        home: "home",
        end: "end",
        pageUp: "pageup",
        pageDown: "pagedown",
        shiftPageUp: "shift+pageup",
        shiftPageDown: "shift+pagedown",
        controlHome: "ctrl+home",
        controlEnd: "ctrl+end",
        altUpArrow: "alt+uparrow",
        spacebar: "space",
        altRightArrow: "alt+rightarrow",
        altLeftArrow: "alt+leftarrow"
      };
      return this.defaultKeyConfigs;
    };
    CalendarBase2.prototype.validateDate = function(value) {
      this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(this.min))) }, true);
      this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(this.max))) }, true);
      this.currentDate = this.currentDate ? this.currentDate : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      if (!isNullOrUndefined(value) && this.min <= this.max && value >= this.min && value <= this.max) {
        this.currentDate = new Date(this.checkValue(value));
      }
    };
    CalendarBase2.prototype.setOverlayIndex = function(popupWrapper, popupElement, modal, isDevice) {
      if (isDevice && !isNullOrUndefined(popupElement) && !isNullOrUndefined(modal) && !isNullOrUndefined(popupWrapper)) {
        var index = parseInt(popupElement.style.zIndex, 10) ? parseInt(popupElement.style.zIndex, 10) : 1e3;
        modal.style.zIndex = (index - 1).toString();
        popupWrapper.style.zIndex = index.toString();
      }
    };
    CalendarBase2.prototype.minMaxUpdate = function(value) {
      if (!(+this.min <= +this.max)) {
        this.setProperties({ min: this.min }, true);
        addClass([this.element], OVERLAY);
      } else {
        removeClass([this.element], OVERLAY);
      }
      this.min = isNullOrUndefined(this.min) || !+this.min ? this.min = new Date(1900, 0, 1) : this.min;
      this.max = isNullOrUndefined(this.max) || !+this.max ? this.max = new Date(2099, 11, 31) : this.max;
      if (+this.min <= +this.max && value && +value <= +this.max && +value >= +this.min) {
        this.currentDate = new Date(this.checkValue(value));
      } else {
        if (+this.min <= +this.max && !value && +this.currentDate > +this.max) {
          this.currentDate = new Date(this.checkValue(this.max));
        } else {
          if (+this.currentDate < +this.min) {
            this.currentDate = new Date(this.checkValue(this.min));
          }
        }
      }
    };
    CalendarBase2.prototype.createHeader = function() {
      var ariaPrevAttrs = {
        "aria-disabled": "false",
        "aria-label": "previous month"
      };
      var ariaNextAttrs = {
        "aria-disabled": "false",
        "aria-label": "next month"
      };
      var ariaTitleAttrs = {
        "aria-atomic": "true",
        "aria-live": "assertive",
        "aria-label": "title"
      };
      this.headerElement = this.createElement("div", { className: HEADER });
      var iconContainer = this.createElement("div", { className: ICONCONTAINER });
      this.previousIcon = this.createElement("button", { className: "" + PREVICON, attrs: { type: "button" } });
      rippleEffect(this.previousIcon, {
        duration: 400,
        selector: ".e-prev",
        isCenterRipple: true
      });
      attributes(this.previousIcon, ariaPrevAttrs);
      this.nextIcon = this.createElement("button", { className: "" + NEXTICON, attrs: { type: "button" } });
      rippleEffect(this.nextIcon, {
        selector: ".e-next",
        duration: 400,
        isCenterRipple: true
      });
      attributes(this.nextIcon, ariaNextAttrs);
      this.headerTitleElement = this.createElement("div", { className: "" + LINK + " " + TITLE });
      attributes(this.headerTitleElement, ariaTitleAttrs);
      this.headerElement.appendChild(this.headerTitleElement);
      this.previousIcon.appendChild(this.createElement("span", { className: "" + PREVSPAN + " " + ICON }));
      this.nextIcon.appendChild(this.createElement("span", { className: "" + NEXTSPAN + " " + ICON }));
      iconContainer.appendChild(this.previousIcon);
      iconContainer.appendChild(this.nextIcon);
      this.headerElement.appendChild(iconContainer);
      if (this.getModuleName() === "calendar") {
        this.element.appendChild(this.headerElement);
      } else {
        this.calendarElement.appendChild(this.headerElement);
      }
      this.adjustLongHeaderSize();
    };
    CalendarBase2.prototype.createContent = function() {
      this.contentElement = this.createElement("div", { className: CONTENT });
      this.table = this.createElement("table", { attrs: { tabIndex: "0", "role": "grid", "aria-activedescendant": "" } });
      if (this.getModuleName() === "calendar") {
        this.element.appendChild(this.contentElement);
      } else {
        this.calendarElement.appendChild(this.contentElement);
      }
      this.contentElement.appendChild(this.table);
      this.createContentHeader();
      this.createContentBody();
      if (this.showTodayButton) {
        this.createContentFooter();
      }
    };
    CalendarBase2.prototype.getCultureValues = function() {
      var culShortNames = [];
      var cldrObj;
      var dayFormat = "days.stand-alone." + this.dayHeaderFormat.toLowerCase();
      if (this.locale === "en" || this.locale === "en-US") {
        cldrObj = getValue(dayFormat, getDefaultDateObject());
      } else {
        cldrObj = this.getCultureObjects(cldrData, "" + this.locale);
      }
      for (var _i = 0, _a = Object.keys(cldrObj); _i < _a.length; _i++) {
        var obj = _a[_i];
        culShortNames.push(getValue(obj, cldrObj));
      }
      return culShortNames;
    };
    CalendarBase2.prototype.toCapitalize = function(text) {
      return !isNullOrUndefined(text) && text.length ? text[0].toUpperCase() + text.slice(1) : text;
    };
    CalendarBase2.prototype.createContentHeader = function() {
      if (this.getModuleName() === "calendar") {
        if (!isNullOrUndefined(this.element.querySelectorAll(".e-content .e-week-header")[0])) {
          detach(this.element.querySelectorAll(".e-content .e-week-header")[0]);
        }
      } else {
        if (!isNullOrUndefined(this.calendarElement.querySelectorAll(".e-content .e-week-header")[0])) {
          detach(this.calendarElement.querySelectorAll(".e-content .e-week-header")[0]);
        }
      }
      var daysCount = 6;
      var html = "";
      if (this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {
        this.setProperties({ firstDayOfWeek: 0 }, true);
      }
      this.tableHeadElement = this.createElement("thead", { className: WEEKHEADER });
      if (this.weekNumber) {
        html += '<th class="e-week-number"></th>';
        if (this.getModuleName() === "calendar") {
          addClass([this.element], "" + WEEKNUMBER);
        } else {
          addClass([this.calendarElement], "" + WEEKNUMBER);
        }
      }
      var shortNames = this.shiftArray(this.getCultureValues().length > 0 && this.getCultureValues(), this.firstDayOfWeek);
      for (var days = 0; days <= daysCount; days++) {
        html += '<th  class="">' + this.toCapitalize(shortNames[days]) + "</th>";
      }
      html = "<tr>" + html + "</tr>";
      this.tableHeadElement.innerHTML = html;
      this.table.appendChild(this.tableHeadElement);
    };
    CalendarBase2.prototype.createContentBody = function() {
      if (this.getModuleName() === "calendar") {
        if (!isNullOrUndefined(this.element.querySelectorAll(".e-content tbody")[0])) {
          detach(this.element.querySelectorAll(".e-content tbody")[0]);
        }
      } else {
        if (!isNullOrUndefined(this.calendarElement.querySelectorAll(".e-content tbody")[0])) {
          detach(this.calendarElement.querySelectorAll(".e-content tbody")[0]);
        }
      }
      switch (this.start) {
        case "Year":
          this.renderYears();
          break;
        case "Decade":
          this.renderDecades();
          break;
        default:
          this.renderMonths();
      }
    };
    CalendarBase2.prototype.updateFooter = function() {
      this.todayElement.textContent = this.l10.getConstant("today");
      this.todayElement.setAttribute("aria-label", this.l10.getConstant("today"));
    };
    CalendarBase2.prototype.createContentFooter = function() {
      if (this.showTodayButton) {
        var minimum = /* @__PURE__ */ new Date(+this.min);
        var maximum = /* @__PURE__ */ new Date(+this.max);
        var l10nLocale = { today: "Today" };
        this.globalize = new Internationalization(this.locale);
        this.l10 = new L10n(this.getModuleName(), l10nLocale, this.locale);
        this.todayElement = this.createElement("button", { attrs: { role: "button" } });
        rippleEffect(this.todayElement);
        this.updateFooter();
        addClass([this.todayElement], [BTN, TODAY, FLAT, PRIMARY, CSS]);
        if (!(+new Date(minimum.setHours(0, 0, 0, 0)) <= +this.todayDate && +this.todayDate <= +new Date(maximum.setHours(0, 0, 0, 0))) || this.todayDisabled) {
          addClass([this.todayElement], DISABLED);
        }
        this.footer = this.createElement("div", { className: FOOTER });
        this.footer.appendChild(this.todayElement);
        if (this.getModuleName() === "calendar") {
          this.element.appendChild(this.footer);
        }
        if (this.getModuleName() === "datepicker") {
          this.calendarElement.appendChild(this.footer);
        }
        if (this.getModuleName() === "datetimepicker") {
          this.calendarElement.appendChild(this.footer);
        }
        if (!this.todayElement.classList.contains(DISABLED)) {
          EventHandler.add(this.todayElement, "click", this.todayButtonClick, this);
        }
      }
    };
    CalendarBase2.prototype.wireEvents = function(id, ref, keyConfig, moduleName) {
      EventHandler.add(this.headerTitleElement, "click", this.navigateTitle, this);
      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
      if (this.getModuleName() === "calendar") {
        this.keyboardModule = new KeyboardEvents(this.element, {
          eventName: "keydown",
          keyAction: this.keyActionHandle.bind(this),
          keyConfigs: this.defaultKeyConfigs
        });
      } else {
        this.keyboardModule = new KeyboardEvents(this.calendarElement, {
          eventName: "keydown",
          keyAction: this.keyActionHandle.bind(this),
          keyConfigs: this.defaultKeyConfigs
        });
      }
    };
    CalendarBase2.prototype.dateWireEvents = function(id, ref, keyConfig, moduleName) {
      this.defaultKeyConfigs = this.getDefaultKeyConfig();
      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, keyConfig);
      this.serverModuleName = moduleName;
    };
    CalendarBase2.prototype.todayButtonClick = function(e, value, isCustomDate) {
      if (this.showTodayButton) {
        if (this.currentView() === this.depth) {
          this.effect = "";
        } else {
          this.effect = "e-zoomin";
        }
        if (this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
          this.navigateTo(this.depth, new Date(this.checkValue(value)), isCustomDate);
        } else {
          this.navigateTo("Month", new Date(this.checkValue(value)), isCustomDate);
        }
      }
    };
    CalendarBase2.prototype.resetCalendar = function() {
      this.calendarElement && detach(this.calendarElement);
      this.tableBodyElement && detach(this.tableBodyElement);
      this.table && detach(this.table);
      this.tableHeadElement && detach(this.tableHeadElement);
      this.nextIcon && detach(this.nextIcon);
      this.previousIcon && detach(this.previousIcon);
      this.footer && detach(this.footer);
      this.todayElement = null;
      this.renderDayCellArgs = null;
      this.calendarElement = this.tableBodyElement = this.footer = this.tableHeadElement = this.nextIcon = this.previousIcon = this.table = null;
    };
    CalendarBase2.prototype.keyActionHandle = function(e, value, multiSelection) {
      var focusedDate = this.tableBodyElement.querySelector("tr td.e-focused-date");
      var selectedDate;
      if (multiSelection) {
        if (!isNullOrUndefined(focusedDate) && +value === parseInt(focusedDate.getAttribute("id").split("_")[0], 10)) {
          selectedDate = focusedDate;
        } else {
          selectedDate = this.tableBodyElement.querySelector("tr td.e-selected");
        }
      } else {
        selectedDate = this.tableBodyElement.querySelector("tr td.e-selected");
      }
      var view = this.getViewNumber(this.currentView());
      var depthValue = this.getViewNumber(this.depth);
      var levelRestrict = view === depthValue && this.getViewNumber(this.start) >= depthValue;
      this.effect = "";
      switch (e.action) {
        case "moveLeft":
          this.keyboardNavigate(-1, view, e, this.max, this.min);
          e.preventDefault();
          break;
        case "moveRight":
          this.keyboardNavigate(1, view, e, this.max, this.min);
          e.preventDefault();
          break;
        case "moveUp":
          if (view === 0) {
            this.keyboardNavigate(-7, view, e, this.max, this.min);
          } else {
            this.keyboardNavigate(-4, view, e, this.max, this.min);
          }
          e.preventDefault();
          break;
        case "moveDown":
          if (view === 0) {
            this.keyboardNavigate(7, view, e, this.max, this.min);
          } else {
            this.keyboardNavigate(4, view, e, this.max, this.min);
          }
          e.preventDefault();
          break;
        case "select":
          if (e.target === this.todayElement) {
            this.todayButtonClick(e, value);
          } else {
            var element = !isNullOrUndefined(focusedDate) ? focusedDate : selectedDate;
            if (!isNullOrUndefined(element) && !element.classList.contains(DISABLED)) {
              if (levelRestrict) {
                var d = new Date(parseInt("" + element.id, 0));
                this.selectDate(e, d, element);
              } else {
                this.contentClick(null, --view, element, value);
              }
            }
          }
          break;
        case "controlUp":
          this.title();
          e.preventDefault();
          break;
        case "controlDown":
          if (!isNullOrUndefined(focusedDate) || !isNullOrUndefined(selectedDate) && !levelRestrict) {
            this.contentClick(null, --view, focusedDate || selectedDate, value);
          }
          e.preventDefault();
          break;
        case "home":
          this.currentDate = this.firstDay(this.currentDate);
          detach(this.tableBodyElement);
          if (view === 0) {
            this.renderMonths(e);
          } else if (view === 1) {
            this.renderYears(e);
          } else {
            this.renderDecades(e);
          }
          e.preventDefault();
          break;
        case "end":
          this.currentDate = this.lastDay(this.currentDate, view);
          detach(this.tableBodyElement);
          if (view === 0) {
            this.renderMonths(e);
          } else if (view === 1) {
            this.renderYears(e);
          } else {
            this.renderDecades(e);
          }
          e.preventDefault();
          break;
        case "pageUp":
          this.addMonths(this.currentDate, -1);
          this.navigateTo("Month", this.currentDate);
          e.preventDefault();
          break;
        case "pageDown":
          this.addMonths(this.currentDate, 1);
          this.navigateTo("Month", this.currentDate);
          e.preventDefault();
          break;
        case "shiftPageUp":
          this.addYears(this.currentDate, -1);
          this.navigateTo("Month", this.currentDate);
          e.preventDefault();
          break;
        case "shiftPageDown":
          this.addYears(this.currentDate, 1);
          this.navigateTo("Month", this.currentDate);
          e.preventDefault();
          break;
        case "controlHome":
          this.navigateTo("Month", new Date(this.currentDate.getFullYear(), 0, 1));
          e.preventDefault();
          break;
        case "controlEnd":
          this.navigateTo("Month", new Date(this.currentDate.getFullYear(), 11, 31));
          e.preventDefault();
          break;
      }
      if (this.getModuleName() === "calendar") {
        this.table.focus();
      }
    };
    CalendarBase2.prototype.keyboardNavigate = function(number, currentView, e, max, min) {
      var date = new Date(this.checkValue(this.currentDate));
      switch (currentView) {
        case 2:
          this.addYears(this.currentDate, number);
          if (this.isMonthYearRange(this.currentDate)) {
            detach(this.tableBodyElement);
            this.renderDecades(e);
          } else {
            this.currentDate = date;
          }
          break;
        case 1:
          this.addMonths(this.currentDate, number);
          if (this.calendarMode === "Gregorian") {
            if (this.isMonthYearRange(this.currentDate)) {
              detach(this.tableBodyElement);
              this.renderYears(e);
            } else {
              this.currentDate = date;
            }
          } else {
            if (this.isMonthYearRange(this.currentDate)) {
              detach(this.tableBodyElement);
              this.renderYears(e);
            } else {
              this.currentDate = date;
            }
          }
          break;
        case 0:
          this.addDay(this.currentDate, number, e, max, min);
          if (this.isMinMaxRange(this.currentDate)) {
            detach(this.tableBodyElement);
            this.renderMonths(e);
          } else {
            this.currentDate = date;
          }
          break;
      }
    };
    CalendarBase2.prototype.preRender = function(value) {
      var _this = this;
      this.navigatePreviousHandler = this.navigatePrevious.bind(this);
      this.navigateNextHandler = this.navigateNext.bind(this);
      this.defaultKeyConfigs = this.getDefaultKeyConfig();
      this.navigateHandler = function(e) {
        _this.triggerNavigate(e);
      };
    };
    CalendarBase2.prototype.minMaxDate = function(localDate) {
      var currentDate = new Date((/* @__PURE__ */ new Date(+localDate)).setHours(0, 0, 0, 0));
      var minDate = new Date((/* @__PURE__ */ new Date(+this.min)).setHours(0, 0, 0, 0));
      var maxDate = new Date((/* @__PURE__ */ new Date(+this.max)).setHours(0, 0, 0, 0));
      if (+currentDate === +minDate || +currentDate === +maxDate) {
        if (+localDate < +this.min) {
          localDate = /* @__PURE__ */ new Date(+this.min);
        }
        if (+localDate > +this.max) {
          localDate = /* @__PURE__ */ new Date(+this.max);
        }
      }
      return localDate;
    };
    CalendarBase2.prototype.renderMonths = function(e, value, isCustomDate) {
      var numCells = this.weekNumber ? 8 : 7;
      var tdEles;
      if (this.calendarMode === "Gregorian") {
        tdEles = this.renderDays(this.currentDate, value, null, null, isCustomDate);
      } else {
        tdEles = this.islamicModule.islamicRenderDays(this.currentDate, value);
      }
      this.createContentHeader();
      if (this.calendarMode === "Gregorian") {
        this.renderTemplate(tdEles, numCells, MONTH, e, value);
      } else {
        this.islamicModule.islamicRenderTemplate(tdEles, numCells, MONTH, e, value);
      }
    };
    CalendarBase2.prototype.renderDays = function(currentDate, value, multiSelection, values, isTodayDate) {
      var tdEles = [];
      var cellsCount = 42;
      var todayDate = isTodayDate ? /* @__PURE__ */ new Date(+currentDate) : this.getDate(/* @__PURE__ */ new Date(), this.timezone);
      var localDate = new Date(this.checkValue(currentDate));
      var minMaxDate;
      var currentMonth = localDate.getMonth();
      this.titleUpdate(currentDate, "days");
      var d = localDate;
      localDate = new Date(d.getFullYear(), d.getMonth(), 0, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
      while (localDate.getDay() !== this.firstDayOfWeek) {
        this.setStartDate(localDate, -1 * dayMilliSeconds);
      }
      for (var day = 0; day < cellsCount; ++day) {
        var weekEle = this.createElement("td", { className: CELL });
        var weekAnchor = this.createElement("span");
        if (day % 7 === 0 && this.weekNumber) {
          var numberOfDays = this.weekRule === "FirstDay" ? 6 : this.weekRule === "FirstFourDayWeek" ? 3 : 0;
          var finalDate = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate() + numberOfDays);
          weekAnchor.textContent = "" + this.getWeek(finalDate);
          weekEle.appendChild(weekAnchor);
          addClass([weekEle], "" + WEEKNUMBER);
          tdEles.push(weekEle);
        }
        minMaxDate = /* @__PURE__ */ new Date(+localDate);
        localDate = this.minMaxDate(localDate);
        var dateFormatOptions = { type: "dateTime", skeleton: "full" };
        var date = this.globalize.parseDate(this.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);
        var tdEle = this.dayCell(localDate);
        var title = this.globalize.formatDate(localDate, { type: "date", skeleton: "full" });
        var dayLink = this.createElement("span");
        dayLink.textContent = this.globalize.formatDate(localDate, { format: "d", type: "date", skeleton: "yMd" });
        var disabled = this.min > localDate || this.max < localDate;
        if (disabled) {
          addClass([tdEle], DISABLED);
          addClass([tdEle], OVERLAY);
        } else {
          dayLink.setAttribute("title", "" + title);
        }
        if (currentMonth !== localDate.getMonth()) {
          addClass([tdEle], OTHERMONTH);
        }
        if (localDate.getDay() === 0 || localDate.getDay() === 6) {
          addClass([tdEle], WEEKEND);
        }
        tdEle.appendChild(dayLink);
        this.renderDayCellArgs = {
          date: localDate,
          isDisabled: false,
          element: tdEle,
          isOutOfRange: disabled
        };
        var argument = this.renderDayCellArgs;
        this.renderDayCellEvent(argument);
        if (argument.isDisabled) {
          var selectDate = new Date(this.checkValue(value));
          var argsDate = new Date(this.checkValue(argument.date));
          if (multiSelection) {
            if (!isNullOrUndefined(values) && values.length > 0) {
              for (var index = 0; index < values.length; index++) {
                var localDateString = +new Date(this.globalize.formatDate(argument.date, { type: "date", skeleton: "yMd" }));
                var tempDateString = +new Date(this.globalize.formatDate(values[index], { type: "date", skeleton: "yMd" }));
                if (localDateString === tempDateString) {
                  values.splice(index, 1);
                  index = -1;
                }
              }
            }
          } else if (selectDate && +selectDate === +argsDate) {
            this.setProperties({ value: null }, true);
          }
        }
        if (this.renderDayCellArgs.isDisabled && !tdEle.classList.contains(SELECTED)) {
          addClass([tdEle], DISABLED);
          addClass([tdEle], OVERLAY);
          if (+this.renderDayCellArgs.date === +this.todayDate) {
            this.todayDisabled = true;
          }
        }
        var otherMnthBool = tdEle.classList.contains(OTHERMONTH);
        var disabledCls = tdEle.classList.contains(DISABLED);
        if (!disabledCls) {
          EventHandler.add(tdEle, "click", this.clickHandler, this);
        }
        if (multiSelection && !isNullOrUndefined(values) && !disabledCls) {
          for (var tempValue = 0; tempValue < values.length; tempValue++) {
            var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
            var formatOptions = { format: null, type: "date", skeleton: "short", calendar: type };
            var localDateString = this.globalize.formatDate(localDate, formatOptions);
            var tempDateString = this.globalize.formatDate(values[tempValue], formatOptions);
            if (localDateString === tempDateString && this.getDateVal(localDate, values[tempValue]) || this.getDateVal(localDate, value)) {
              addClass([tdEle], SELECTED);
            } else {
              this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
            }
          }
          if (values.length <= 0) {
            this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
          }
        } else if (!disabledCls && this.getDateVal(localDate, value)) {
          addClass([tdEle], SELECTED);
        }
        this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
        if (date.getFullYear() === todayDate.getFullYear() && date.getMonth() === todayDate.getMonth() && date.getDate() === todayDate.getDate()) {
          addClass([tdEle], TODAY);
        }
        tdEles.push(this.renderDayCellArgs.element);
        localDate = /* @__PURE__ */ new Date(+minMaxDate);
        this.addDay(localDate, 1, null, this.max, this.min);
      }
      return tdEles;
    };
    CalendarBase2.prototype.updateFocus = function(otherMonth, disabled, localDate, tableElement, currentDate) {
      if (currentDate.getDate() === localDate.getDate() && !otherMonth && !disabled) {
        addClass([tableElement], FOCUSEDDATE);
      } else {
        if (currentDate >= this.max && parseInt(tableElement.id, 0) === +this.max && !otherMonth && !disabled) {
          addClass([tableElement], FOCUSEDDATE);
        }
        if (currentDate <= this.min && parseInt(tableElement.id, 0) === +this.min && !otherMonth && !disabled) {
          addClass([tableElement], FOCUSEDDATE);
        }
      }
    };
    CalendarBase2.prototype.renderYears = function(e, value) {
      this.removeTableHeadElement();
      var numCells = 4;
      var tdEles = [];
      var valueUtil = isNullOrUndefined(value);
      var curDate = new Date(this.checkValue(this.currentDate));
      var mon = curDate.getMonth();
      var yr = curDate.getFullYear();
      var localDate = curDate;
      var curYrs = localDate.getFullYear();
      var minYr = new Date(this.checkValue(this.min)).getFullYear();
      var minMonth = new Date(this.checkValue(this.min)).getMonth();
      var maxYr = new Date(this.checkValue(this.max)).getFullYear();
      var maxMonth = new Date(this.checkValue(this.max)).getMonth();
      localDate.setMonth(0);
      this.titleUpdate(this.currentDate, "months");
      localDate.setDate(1);
      for (var month = 0; month < 12; ++month) {
        var tdEle = this.dayCell(localDate);
        var dayLink = this.createElement("span");
        var localMonth = value && value.getMonth() === localDate.getMonth();
        var select2 = value && value.getFullYear() === yr && localMonth;
        dayLink.textContent = this.toCapitalize(this.globalize.formatDate(localDate, {
          format: null,
          type: "dateTime",
          skeleton: "MMM"
        }));
        if (this.min && (curYrs < minYr || month < minMonth && curYrs === minYr) || this.max && (curYrs > maxYr || month > maxMonth && curYrs >= maxYr)) {
          addClass([tdEle], DISABLED);
        } else if (!valueUtil && select2) {
          addClass([tdEle], SELECTED);
        } else {
          if (localDate.getMonth() === mon && this.currentDate.getMonth() === mon) {
            addClass([tdEle], FOCUSEDDATE);
          }
        }
        localDate.setDate(1);
        localDate.setMonth(localDate.getMonth() + 1);
        if (!tdEle.classList.contains(DISABLED)) {
          EventHandler.add(tdEle, "click", this.clickHandler, this);
        }
        tdEle.appendChild(dayLink);
        tdEles.push(tdEle);
      }
      this.renderTemplate(tdEles, numCells, YEAR, e, value);
    };
    CalendarBase2.prototype.renderDecades = function(e, value) {
      this.removeTableHeadElement();
      var numCells = 4;
      var yearCell = 12;
      var tdEles = [];
      var localDate = new Date(this.checkValue(this.currentDate));
      localDate.setMonth(0);
      localDate.setDate(1);
      var localYr = localDate.getFullYear();
      var startYr = new Date(localDate.setFullYear(localYr - localYr % 10));
      var endYr = new Date(localDate.setFullYear(localYr - localYr % 10 + (10 - 1)));
      var startFullYr = startYr.getFullYear();
      var endFullYr = endYr.getFullYear();
      var startHdrYr = this.globalize.formatDate(startYr, {
        format: null,
        type: "dateTime",
        skeleton: "y"
      });
      var endHdrYr = this.globalize.formatDate(endYr, { format: null, type: "dateTime", skeleton: "y" });
      this.headerTitleElement.textContent = startHdrYr + " - " + endHdrYr;
      var start = new Date(localYr - localYr % 10 - 1, 0, 1);
      var startYear = start.getFullYear();
      for (var rowIterator = 0; rowIterator < yearCell; ++rowIterator) {
        var year = startYear + rowIterator;
        localDate.setFullYear(year);
        var tdEle = this.dayCell(localDate);
        attributes(tdEle, { "role": "gridcell" });
        var dayLink = this.createElement("span");
        dayLink.textContent = this.globalize.formatDate(localDate, {
          format: null,
          type: "dateTime",
          skeleton: "y"
        });
        if (year < startFullYr || year > endFullYr) {
          addClass([tdEle], OTHERDECADE);
          if (!isNullOrUndefined(value) && localDate.getFullYear() === value.getFullYear()) {
            addClass([tdEle], SELECTED);
          }
          if (year < new Date(this.checkValue(this.min)).getFullYear() || year > new Date(this.checkValue(this.max)).getFullYear()) {
            addClass([tdEle], DISABLED);
          }
        } else if (year < new Date(this.checkValue(this.min)).getFullYear() || year > new Date(this.checkValue(this.max)).getFullYear()) {
          addClass([tdEle], DISABLED);
        } else if (!isNullOrUndefined(value) && localDate.getFullYear() === value.getFullYear()) {
          addClass([tdEle], SELECTED);
        } else {
          if (localDate.getFullYear() === this.currentDate.getFullYear() && !tdEle.classList.contains(DISABLED)) {
            addClass([tdEle], FOCUSEDDATE);
          }
        }
        if (!tdEle.classList.contains(DISABLED)) {
          EventHandler.add(tdEle, "click", this.clickHandler, this);
        }
        tdEle.appendChild(dayLink);
        tdEles.push(tdEle);
      }
      this.renderTemplate(tdEles, numCells, "e-decade", e, value);
    };
    CalendarBase2.prototype.dayCell = function(localDate) {
      var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
      var dateFormatOptions = { skeleton: "full", type: "dateTime", calendar: type };
      var date = this.globalize.parseDate(this.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);
      var value = date.valueOf();
      var attrs = {
        className: CELL,
        attrs: { "id": "" + getUniqueID("" + value), "aria-selected": "false", "role": "gridcell" }
      };
      return this.createElement("td", attrs);
    };
    CalendarBase2.prototype.firstDay = function(date) {
      var collection = this.currentView() !== "Decade" ? this.tableBodyElement.querySelectorAll("td:not(." + OTHERMONTH) : this.tableBodyElement.querySelectorAll("td:not(." + OTHERDECADE);
      if (collection.length) {
        for (var i = 0; i < collection.length; i++) {
          if (!collection[i].classList.contains(DISABLED)) {
            date = new Date(parseInt(collection[i].id, 0));
            break;
          }
        }
      }
      return date;
    };
    CalendarBase2.prototype.lastDay = function(date, view) {
      var lastDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
      if (view !== 2) {
        var timeOffset = Math.abs(lastDate.getTimezoneOffset() - this.firstDay(date).getTimezoneOffset());
        if (timeOffset) {
          lastDate.setHours(this.firstDay(date).getHours() + timeOffset / 60);
        }
        return this.findLastDay(lastDate);
      } else {
        return this.findLastDay(this.firstDay(lastDate));
      }
    };
    CalendarBase2.prototype.checkDateValue = function(value) {
      return !isNullOrUndefined(value) && value instanceof Date && !isNaN(+value) ? value : null;
    };
    CalendarBase2.prototype.findLastDay = function(date) {
      var collection = this.currentView() === "Decade" ? this.tableBodyElement.querySelectorAll("td:not(." + OTHERDECADE) : this.tableBodyElement.querySelectorAll("td:not(." + OTHERMONTH);
      if (collection.length) {
        for (var i = collection.length - 1; i >= 0; i--) {
          if (!collection[i].classList.contains(DISABLED)) {
            date = new Date(parseInt(collection[i].id, 0));
            break;
          }
        }
      }
      return date;
    };
    CalendarBase2.prototype.removeTableHeadElement = function() {
      if (this.getModuleName() === "calendar") {
        if (!isNullOrUndefined(this.element.querySelectorAll(".e-content table thead")[0])) {
          detach(this.tableHeadElement);
        }
      } else {
        if (!isNullOrUndefined(this.calendarElement.querySelectorAll(".e-content table thead")[0])) {
          detach(this.tableHeadElement);
        }
      }
    };
    CalendarBase2.prototype.renderTemplate = function(elements, count, classNm, e, value) {
      var view = this.getViewNumber(this.currentView());
      var trEle;
      this.tableBodyElement = this.createElement("tbody");
      this.table.appendChild(this.tableBodyElement);
      removeClass([this.contentElement, this.headerElement], [MONTH, DECADE, YEAR]);
      addClass([this.contentElement, this.headerElement], [classNm]);
      var weekNumCell = 41;
      var numberCell = 35;
      var otherMonthCell = 6;
      var row = count;
      var rowIterator = 0;
      for (var dayCell = 0; dayCell < elements.length / count; ++dayCell) {
        trEle = this.createElement("tr", { attrs: { "role": "row" } });
        for (rowIterator = 0 + rowIterator; rowIterator < row; rowIterator++) {
          if (!elements[rowIterator].classList.contains("e-week-number") && !isNullOrUndefined(elements[rowIterator].children[0])) {
            addClass([elements[rowIterator].children[0]], [LINK]);
            rippleEffect(elements[rowIterator].children[0], {
              duration: 600,
              isCenterRipple: true
            });
          }
          trEle.appendChild(elements[rowIterator]);
          if (this.weekNumber && rowIterator === otherMonthCell + 1 && elements[otherMonthCell + 1].classList.contains(OTHERMONTH)) {
            addClass([trEle], OTHERMONTHROW);
          }
          if (!this.weekNumber && rowIterator === otherMonthCell && elements[otherMonthCell].classList.contains(OTHERMONTH)) {
            addClass([trEle], OTHERMONTHROW);
          }
          if (this.weekNumber) {
            if (rowIterator === weekNumCell && elements[weekNumCell].classList.contains(OTHERMONTH)) {
              addClass([trEle], OTHERMONTHROW);
            }
          } else {
            if (rowIterator === numberCell && elements[numberCell].classList.contains(OTHERMONTH)) {
              addClass([trEle], OTHERMONTHROW);
            }
          }
        }
        row = row + count;
        rowIterator = rowIterator + 0;
        this.tableBodyElement.appendChild(trEle);
      }
      this.table.querySelector("tbody").className = this.effect;
      if (this.calendarMode === "Gregorian") {
        this.iconHandler();
      } else {
        this.islamicModule.islamicIconHandler();
      }
      if (view !== this.getViewNumber(this.currentView()) || view === 0 && view !== this.getViewNumber(this.currentView())) {
        this.navigateHandler(e);
      }
      this.setAriaActiveDescendant();
    };
    CalendarBase2.prototype.clickHandler = function(e, value) {
      this.clickEventEmitter(e);
      var eve = e.currentTarget;
      var view = this.getViewNumber(this.currentView());
      if (eve.classList.contains(OTHERMONTH)) {
        this.contentClick(e, 0, null, value);
      } else if (view === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
        this.contentClick(e, 1, null, value);
      } else if (2 === view) {
        this.contentClick(e, 1, null, value);
      } else if (!eve.classList.contains(OTHERMONTH) && view === 0) {
        this.selectDate(e, this.getIdValue(e, null), null);
      } else {
        this.contentClick(e, 0, eve, value);
      }
      if (this.getModuleName() === "calendar") {
        this.table.focus();
      }
    };
    CalendarBase2.prototype.clickEventEmitter = function(e) {
      e.preventDefault();
    };
    CalendarBase2.prototype.contentClick = function(e, view, element, value) {
      var currentView = this.getViewNumber(this.currentView());
      var d = this.getIdValue(e, element);
      switch (view) {
        case 0:
          if (currentView === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
            detach(this.tableBodyElement);
            this.currentDate = d;
            this.effect = ZOOMIN;
            this.renderMonths(e);
          } else {
            if (this.calendarMode === "Gregorian") {
              this.currentDate.setMonth(d.getMonth());
              if (d.getMonth() > 0 && this.currentDate.getMonth() !== d.getMonth()) {
                this.currentDate.setDate(0);
              }
              this.currentDate.setFullYear(d.getFullYear());
            } else {
              this.currentDate = d;
            }
            this.effect = ZOOMIN;
            detach(this.tableBodyElement);
            this.renderMonths(e);
          }
          break;
        case 1:
          if (currentView === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
            this.selectDate(e, d, null);
          } else {
            if (this.calendarMode === "Gregorian") {
              this.currentDate.setFullYear(d.getFullYear());
            } else {
              var islamicDate = this.islamicModule.getIslamicDate(d);
              this.currentDate = this.islamicModule.toGregorian(islamicDate.year, islamicDate.month, 1);
            }
            this.effect = ZOOMIN;
            detach(this.tableBodyElement);
            this.renderYears(e);
          }
      }
    };
    CalendarBase2.prototype.switchView = function(view, e, multiSelection, isCustomDate) {
      switch (view) {
        case 0:
          detach(this.tableBodyElement);
          this.renderMonths(e, null, isCustomDate);
          if (multiSelection && !isNullOrUndefined(this.tableBodyElement.querySelectorAll("." + FOCUSEDDATE)[0])) {
            this.tableBodyElement.querySelectorAll("." + FOCUSEDDATE)[0].classList.remove(FOCUSEDDATE);
          }
          break;
        case 1:
          detach(this.tableBodyElement);
          this.renderYears(e);
          break;
        case 2:
          detach(this.tableBodyElement);
          this.renderDecades(e);
      }
    };
    CalendarBase2.prototype.getModuleName = function() {
      return "calendar";
    };
    CalendarBase2.prototype.requiredModules = function() {
      var modules = [];
      if (this) {
        modules.push({ args: [this], member: "islamic" });
      }
      return modules;
    };
    CalendarBase2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    CalendarBase2.prototype.onPropertyChanged = function(newProp, oldProp, multiSelection, values) {
      this.effect = "";
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "enableRtl":
            if (newProp.enableRtl) {
              if (this.getModuleName() === "calendar") {
                this.element.classList.add("e-rtl");
              } else {
                this.calendarElement.classList.add("e-rtl");
              }
            } else {
              if (this.getModuleName() === "calendar") {
                this.element.classList.remove("e-rtl");
              } else {
                this.calendarElement.classList.remove("e-rtl");
              }
            }
            break;
          case "dayHeaderFormat":
            this.getCultureValues();
            if (this.getModuleName() !== "datepicker") {
              this.createContentHeader();
            } else if (this.calendarElement) {
              this.createContentHeader();
            }
            this.adjustLongHeaderSize();
            break;
          case "min":
          case "max":
            this.rangeValidation(this.min, this.max);
            if (prop === "min") {
              this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(newProp.min))) }, true);
            } else {
              this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(newProp.max))) }, true);
            }
            this.setProperties({ start: this.currentView() }, true);
            if (this.tableBodyElement) {
              detach(this.tableBodyElement);
            }
            this.minMaxUpdate();
            if (multiSelection) {
              this.validateValues(multiSelection, values);
            }
            if (this.getModuleName() !== "datepicker") {
              this.createContentBody();
            } else if (this.calendarElement) {
              this.createContentBody();
            }
            if ((this.todayDate < this.min || this.max < this.todayDate) && this.footer && this.todayElement) {
              detach(this.todayElement);
              detach(this.footer);
              this.todayElement = this.footer = null;
              this.createContentFooter();
            } else {
              if (this.footer && this.todayElement && this.todayElement.classList.contains("e-disabled")) {
                removeClass([this.todayElement], DISABLED);
                detach(this.todayElement);
                detach(this.footer);
                this.todayElement = this.footer = null;
                this.createContentFooter();
              }
            }
            break;
          case "start":
          case "depth":
          case "weekNumber":
          case "firstDayOfWeek":
          case "weekRule":
            this.checkView();
            if (this.getModuleName() !== "datepicker") {
              this.createContentHeader();
              this.createContentBody();
            } else if (this.calendarElement) {
              this.createContentHeader();
              this.createContentBody();
            }
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            if (this.getModuleName() !== "datepicker") {
              this.createContentHeader();
              this.createContentBody();
            } else if (this.calendarElement) {
              this.createContentHeader();
              this.createContentBody();
            }
            this.l10.setLocale(this.locale);
            this.updateFooter();
            break;
          case "showTodayButton":
            if (newProp.showTodayButton) {
              this.createContentFooter();
            } else {
              if (!isNullOrUndefined(this.todayElement) && !isNullOrUndefined(this.footer)) {
                detach(this.todayElement);
                detach(this.footer);
                this.todayElement = this.footer = void 0;
              }
            }
            this.setProperties({ showTodayButton: newProp.showTodayButton }, true);
            break;
        }
      }
    };
    CalendarBase2.prototype.validateValues = function(multiSelection, values) {
      if (multiSelection && !isNullOrUndefined(values) && values.length > 0) {
        var copyValues = this.copyValues(values);
        for (var skipIndex = 0; skipIndex < copyValues.length; skipIndex++) {
          var tempValue = copyValues[skipIndex];
          var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
          var tempValueString = void 0;
          if (this.calendarMode === "Gregorian") {
            tempValueString = this.globalize.formatDate(tempValue, { type: "date", skeleton: "yMd" });
          } else {
            tempValueString = this.globalize.formatDate(tempValue, { type: "dateTime", skeleton: "full", calendar: "islamic" });
          }
          var minFormatOption = { type: "date", skeleton: "yMd", calendar: type };
          var minStringValue = this.globalize.formatDate(this.min, minFormatOption);
          var minString = minStringValue;
          var maxFormatOption = { type: "date", skeleton: "yMd", calendar: type };
          var maxStringValue = this.globalize.formatDate(this.max, maxFormatOption);
          var maxString = maxStringValue;
          if (+new Date(tempValueString) < +new Date(minString) || +new Date(tempValueString) > +new Date(maxString)) {
            copyValues.splice(skipIndex, 1);
            skipIndex = -1;
          }
        }
        this.setProperties({ values: copyValues }, true);
      }
    };
    CalendarBase2.prototype.setValueUpdate = function() {
      if (!isNullOrUndefined(this.tableBodyElement)) {
        detach(this.tableBodyElement);
        this.setProperties({ start: this.currentView() }, true);
        this.createContentBody();
      }
    };
    CalendarBase2.prototype.copyValues = function(values) {
      var copyValues = [];
      if (!isNullOrUndefined(values) && values.length > 0) {
        for (var index = 0; index < values.length; index++) {
          copyValues.push(/* @__PURE__ */ new Date(+values[index]));
        }
      }
      return copyValues;
    };
    CalendarBase2.prototype.titleUpdate = function(date, view) {
      var globalize = new Internationalization(this.locale);
      var dayFormatOptions;
      var monthFormatOptions;
      var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
      if (this.calendarMode === "Gregorian") {
        dayFormatOptions = globalize.formatDate(date, { type: "dateTime", skeleton: "yMMMM", calendar: type });
        monthFormatOptions = globalize.formatDate(date, {
          format: null,
          type: "dateTime",
          skeleton: "y",
          calendar: type
        });
      } else {
        dayFormatOptions = globalize.formatDate(date, { type: "dateTime", format: "MMMM y", calendar: type });
        monthFormatOptions = globalize.formatDate(date, { type: "dateTime", format: "y", calendar: type });
      }
      switch (view) {
        case "days":
          this.headerTitleElement.textContent = this.toCapitalize(dayFormatOptions);
          break;
        case "months":
          this.headerTitleElement.textContent = monthFormatOptions;
      }
    };
    CalendarBase2.prototype.setActiveDescendant = function() {
      var id;
      var focusedEle = this.tableBodyElement.querySelector("tr td.e-focused-date");
      var selectedEle = this.tableBodyElement.querySelector("tr td.e-selected");
      var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
      var title;
      var view = this.currentView();
      if (view === "Month") {
        title = this.globalize.formatDate(this.currentDate, { type: "date", skeleton: "full", calendar: type });
      } else if (view === "Year") {
        if (type !== "islamic") {
          title = this.globalize.formatDate(this.currentDate, { type: "date", skeleton: "yMMMM", calendar: type });
        } else {
          title = this.globalize.formatDate(this.currentDate, { type: "date", skeleton: "GyMMM", calendar: type });
        }
      } else {
        title = this.globalize.formatDate(this.currentDate, {
          format: null,
          type: "date",
          skeleton: "y",
          calendar: type
        });
      }
      if (selectedEle || focusedEle) {
        if (!isNullOrUndefined(selectedEle)) {
          selectedEle.setAttribute("aria-selected", "true");
        }
        (focusedEle || selectedEle).setAttribute("aria-label", title);
        id = (focusedEle || selectedEle).getAttribute("id");
      }
      return id;
    };
    CalendarBase2.prototype.iconHandler = function() {
      new Date(this.checkValue(this.currentDate)).setDate(1);
      switch (this.currentView()) {
        case "Month":
          this.previousIconHandler(this.compareMonth(new Date(this.checkValue(this.currentDate)), this.min) < 1);
          this.nextIconHandler(this.compareMonth(new Date(this.checkValue(this.currentDate)), this.max) > -1);
          break;
        case "Year":
          this.previousIconHandler(this.compareYear(new Date(this.checkValue(this.currentDate)), this.min) < 1);
          this.nextIconHandler(this.compareYear(new Date(this.checkValue(this.currentDate)), this.max) > -1);
          break;
        case "Decade":
          this.previousIconHandler(this.compareDecade(new Date(this.checkValue(this.currentDate)), this.min) < 1);
          this.nextIconHandler(this.compareDecade(new Date(this.checkValue(this.currentDate)), this.max) > -1);
      }
    };
    CalendarBase2.prototype.destroy = function() {
      if (this.getModuleName() === "calendar" && this.element) {
        removeClass([this.element], [ROOT]);
      } else {
        if (this.calendarElement && this.element) {
          removeClass([this.element], [ROOT]);
        }
      }
      if (this.getModuleName() === "calendar" && this.element) {
        EventHandler.remove(this.headerTitleElement, "click", this.navigateTitle);
        if (this.todayElement) {
          EventHandler.remove(this.todayElement, "click", this.todayButtonClick);
        }
        this.previousIconHandler(true);
        this.nextIconHandler(true);
        this.keyboardModule.destroy();
        this.element.removeAttribute("data-role");
        if (!isNullOrUndefined(this.calendarEleCopy.getAttribute("tabindex"))) {
          this.element.setAttribute("tabindex", this.tabIndex);
        } else {
          this.element.removeAttribute("tabindex");
        }
      }
      if (this.element) {
        this.element.innerHTML = "";
      }
      _super.prototype.destroy.call(this);
    };
    CalendarBase2.prototype.title = function(e) {
      var currentView = this.getViewNumber(this.currentView());
      this.effect = ZOOMIN;
      this.switchView(++currentView, e);
    };
    CalendarBase2.prototype.getViewNumber = function(stringVal) {
      if (stringVal === "Month") {
        return 0;
      } else if (stringVal === "Year") {
        return 1;
      } else {
        return 2;
      }
    };
    CalendarBase2.prototype.navigateTitle = function(e) {
      e.preventDefault();
      this.title(e);
      if (this.getModuleName() === "calendar") {
        this.table.focus();
      }
    };
    CalendarBase2.prototype.previous = function() {
      this.effect = "";
      var currentView = this.getViewNumber(this.currentView());
      switch (this.currentView()) {
        case "Month":
          this.addMonths(this.currentDate, -1);
          this.switchView(currentView);
          break;
        case "Year":
          this.addYears(this.currentDate, -1);
          this.switchView(currentView);
          break;
        case "Decade":
          this.addYears(this.currentDate, -10);
          this.switchView(currentView);
          break;
      }
    };
    CalendarBase2.prototype.navigatePrevious = function(e) {
      e.preventDefault();
      if (this.calendarMode === "Gregorian") {
        this.previous();
      } else {
        this.islamicModule.islamicPrevious();
      }
      this.triggerNavigate(e);
      if (this.getModuleName() === "calendar") {
        this.table.focus();
      }
    };
    CalendarBase2.prototype.next = function() {
      this.effect = "";
      var currentView = this.getViewNumber(this.currentView());
      switch (this.currentView()) {
        case "Month":
          this.addMonths(this.currentDate, 1);
          this.switchView(currentView);
          break;
        case "Year":
          this.addYears(this.currentDate, 1);
          this.switchView(currentView);
          break;
        case "Decade":
          this.addYears(this.currentDate, 10);
          this.switchView(currentView);
          break;
      }
    };
    CalendarBase2.prototype.navigateNext = function(eve) {
      eve.preventDefault();
      if (this.calendarMode === "Gregorian") {
        this.next();
      } else {
        this.islamicModule.islamicNext();
      }
      this.triggerNavigate(eve);
      if (this.getModuleName() === "calendar") {
        this.table.focus();
      }
    };
    CalendarBase2.prototype.navigateTo = function(view, date, isCustomDate) {
      if (+date >= +this.min && +date <= +this.max) {
        this.currentDate = date;
      }
      if (+date <= +this.min) {
        this.currentDate = new Date(this.checkValue(this.min));
      }
      if (+date >= +this.max) {
        this.currentDate = new Date(this.checkValue(this.max));
      }
      if (this.getViewNumber(this.depth) >= this.getViewNumber(view)) {
        if (this.getViewNumber(this.depth) <= this.getViewNumber(this.start) || this.getViewNumber(this.depth) === this.getViewNumber(view)) {
          view = this.depth;
        }
      }
      this.switchView(this.getViewNumber(view), null, null, isCustomDate);
    };
    CalendarBase2.prototype.currentView = function() {
      if (this.contentElement.classList.contains(YEAR)) {
        return "Year";
      } else if (this.contentElement.classList.contains(DECADE)) {
        return "Decade";
      } else {
        return "Month";
      }
    };
    CalendarBase2.prototype.getDateVal = function(date, value) {
      return !isNullOrUndefined(value) && date.getDate() === value.getDate() && date.getMonth() === value.getMonth() && date.getFullYear() === value.getFullYear();
    };
    CalendarBase2.prototype.getCultureObjects = function(ld, c) {
      var gregorianFormat = ".dates.calendars.gregorian.days.format." + this.dayHeaderFormat.toLowerCase();
      var islamicFormat = ".dates.calendars.islamic.days.format." + this.dayHeaderFormat.toLowerCase();
      var mainVal = "main.";
      if (this.calendarMode === "Gregorian") {
        return getValue(mainVal + "" + this.locale + gregorianFormat, ld);
      } else {
        return getValue("main." + this.locale + islamicFormat, ld);
      }
    };
    CalendarBase2.prototype.getWeek = function(d) {
      var currentDate = new Date(this.checkValue(d)).valueOf();
      var date = new Date(d.getFullYear(), 0, 1).valueOf();
      return Math.ceil((currentDate - date + dayMilliSeconds) / dayMilliSeconds / 7);
    };
    CalendarBase2.prototype.setStartDate = function(date, time) {
      var tzOffset = date.getTimezoneOffset();
      var d = new Date(date.getTime() + time);
      var tzOffsetDiff = d.getTimezoneOffset() - tzOffset;
      date.setTime(d.getTime() + tzOffsetDiff * minutesMilliSeconds);
    };
    CalendarBase2.prototype.addMonths = function(date, i) {
      if (this.calendarMode === "Gregorian") {
        var day = date.getDate();
        date.setDate(1);
        date.setMonth(date.getMonth() + i);
        date.setDate(Math.min(day, this.getMaxDays(date)));
      } else {
        var islamicDate = this.islamicModule.getIslamicDate(date);
        this.currentDate = this.islamicModule.toGregorian(islamicDate.year, islamicDate.month + i, 1);
      }
    };
    CalendarBase2.prototype.addYears = function(date, i) {
      if (this.calendarMode === "Gregorian") {
        var day = date.getDate();
        date.setDate(1);
        date.setFullYear(date.getFullYear() + i);
        date.setDate(Math.min(day, this.getMaxDays(date)));
      } else {
        var islamicDate = this.islamicModule.getIslamicDate(date);
        this.currentDate = this.islamicModule.toGregorian(islamicDate.year + i, islamicDate.month, 1);
      }
    };
    CalendarBase2.prototype.getIdValue = function(e, element) {
      var eve;
      if (e) {
        eve = e.currentTarget;
      } else {
        eve = element;
      }
      var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
      var dateFormatOptions = { type: "dateTime", skeleton: "full", calendar: type };
      var dateString = this.globalize.formatDate(new Date(parseInt("" + eve.getAttribute("id"), 0)), dateFormatOptions);
      var date = this.globalize.parseDate(dateString, dateFormatOptions);
      var value = date.valueOf() - date.valueOf() % 1e3;
      return new Date(value);
    };
    CalendarBase2.prototype.adjustLongHeaderSize = function() {
      removeClass([this.element], DAYHEADERLONG);
      if (this.dayHeaderFormat === "Wide") {
        addClass([this.getModuleName() === "calendar" ? this.element : this.calendarElement], DAYHEADERLONG);
      }
    };
    CalendarBase2.prototype.selectDate = function(e, date, node, multiSelection, values) {
      var element = node || e.currentTarget;
      this.isDateSelected = false;
      if (this.currentView() === "Decade") {
        this.setDateDecade(this.currentDate, date.getFullYear());
      } else if (this.currentView() === "Year") {
        this.setDateYear(this.currentDate, date);
      } else {
        if (multiSelection && !this.checkPresentDate(date, values)) {
          var copyValues = this.copyValues(values);
          if (!isNullOrUndefined(values) && copyValues.length > 0) {
            copyValues.push(new Date(this.checkValue(date)));
            this.setProperties({ values: copyValues }, true);
            this.setProperties({ value: values[values.length - 1] }, true);
          } else {
            this.setProperties({ values: [new Date(this.checkValue(date))] }, true);
          }
        } else {
          this.setProperties({ value: new Date(this.checkValue(date)) }, true);
        }
        this.currentDate = new Date(this.checkValue(date));
      }
      var tableBodyElement = closest(element, "." + ROOT);
      if (isNullOrUndefined(tableBodyElement)) {
        tableBodyElement = this.tableBodyElement;
      }
      if (!multiSelection && !isNullOrUndefined(tableBodyElement.querySelector("." + SELECTED))) {
        removeClass([tableBodyElement.querySelector("." + SELECTED)], SELECTED);
      }
      if (!multiSelection && !isNullOrUndefined(tableBodyElement.querySelector("." + FOCUSEDDATE))) {
        removeClass([tableBodyElement.querySelector("." + FOCUSEDDATE)], FOCUSEDDATE);
      }
      if (multiSelection) {
        var copyValues = this.copyValues(values);
        var collection = Array.prototype.slice.call(this.tableBodyElement.querySelectorAll("td"));
        for (var index = 0; index < collection.length; index++) {
          var tempElement = tableBodyElement.querySelectorAll("td." + FOCUSEDDATE)[0];
          var selectedElement = tableBodyElement.querySelectorAll("td." + SELECTED)[0];
          if (collection[index] === tempElement) {
            removeClass([collection[index]], FOCUSEDDATE);
          }
          if (collection[index] === selectedElement && !this.checkPresentDate(new Date(parseInt(selectedElement.getAttribute("id").split("_")[0], 10)), values)) {
            removeClass([collection[index]], SELECTED);
          }
        }
        if (element.classList.contains(SELECTED)) {
          removeClass([element], SELECTED);
          for (var i = 0; i < copyValues.length; i++) {
            var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
            var formatOptions = { format: null, type: "date", skeleton: "short", calendar: type };
            var localDateString = this.globalize.formatDate(date, formatOptions);
            var tempDateString = this.globalize.formatDate(copyValues[i], formatOptions);
            if (localDateString === tempDateString) {
              var index = copyValues.indexOf(copyValues[i]);
              copyValues.splice(index, 1);
              addClass([element], FOCUSEDDATE);
            }
          }
          this.setProperties({ values: copyValues }, true);
        } else {
          addClass([element], SELECTED);
        }
      } else {
        addClass([element], SELECTED);
      }
      this.isDateSelected = true;
    };
    CalendarBase2.prototype.checkPresentDate = function(dates, values) {
      var previousValue = false;
      if (!isNullOrUndefined(values)) {
        for (var checkPrevious = 0; checkPrevious < values.length; checkPrevious++) {
          var type = this.calendarMode === "Gregorian" ? "gregorian" : "islamic";
          var localDateString = this.globalize.formatDate(dates, {
            format: null,
            type: "date",
            skeleton: "short",
            calendar: type
          });
          var tempDateString = this.globalize.formatDate(values[checkPrevious], {
            format: null,
            type: "date",
            skeleton: "short",
            calendar: type
          });
          if (localDateString === tempDateString) {
            previousValue = true;
          }
        }
      }
      return previousValue;
    };
    CalendarBase2.prototype.setAriaActiveDescendant = function() {
      attributes(this.table, {
        "aria-activedescendant": "" + this.setActiveDescendant()
      });
    };
    CalendarBase2.prototype.previousIconHandler = function(disabled) {
      if (disabled) {
        EventHandler.remove(this.previousIcon, "click", this.navigatePreviousHandler);
        addClass([this.previousIcon], "" + DISABLED);
        addClass([this.previousIcon], "" + OVERLAY);
        this.previousIcon.setAttribute("aria-disabled", "true");
      } else {
        EventHandler.add(this.previousIcon, "click", this.navigatePreviousHandler);
        removeClass([this.previousIcon], "" + DISABLED);
        removeClass([this.previousIcon], "" + OVERLAY);
        this.previousIcon.setAttribute("aria-disabled", "false");
      }
    };
    CalendarBase2.prototype.renderDayCellEvent = function(args) {
      extend(this.renderDayCellArgs, { name: "renderDayCell" });
      this.trigger("renderDayCell", args);
    };
    CalendarBase2.prototype.navigatedEvent = function(eve) {
      extend(this.navigatedArgs, { name: "navigated", event: eve });
      this.trigger("navigated", this.navigatedArgs);
    };
    CalendarBase2.prototype.triggerNavigate = function(event) {
      this.navigatedArgs = { view: this.currentView(), date: this.currentDate };
      this.navigatedEvent(event);
    };
    CalendarBase2.prototype.nextIconHandler = function(disabled) {
      if (disabled) {
        EventHandler.remove(this.nextIcon, "click", this.navigateNextHandler);
        addClass([this.nextIcon], DISABLED);
        addClass([this.nextIcon], OVERLAY);
        this.nextIcon.setAttribute("aria-disabled", "true");
      } else {
        EventHandler.add(this.nextIcon, "click", this.navigateNextHandler);
        removeClass([this.nextIcon], DISABLED);
        removeClass([this.nextIcon], OVERLAY);
        this.nextIcon.setAttribute("aria-disabled", "false");
      }
    };
    CalendarBase2.prototype.compare = function(startDate, endDate, modifier) {
      var start = endDate.getFullYear();
      var end;
      var result;
      end = start;
      result = 0;
      if (modifier) {
        start = start - start % modifier;
        end = start - start % modifier + modifier - 1;
      }
      if (startDate.getFullYear() > end) {
        result = 1;
      } else if (startDate.getFullYear() < start) {
        result = -1;
      }
      return result;
    };
    CalendarBase2.prototype.isMinMaxRange = function(date) {
      return +date >= +this.min && +date <= +this.max;
    };
    CalendarBase2.prototype.isMonthYearRange = function(date) {
      if (this.calendarMode === "Gregorian") {
        return date.getMonth() >= this.min.getMonth() && date.getFullYear() >= this.min.getFullYear() && date.getMonth() <= this.max.getMonth() && date.getFullYear() <= this.max.getFullYear();
      } else {
        var islamicDate = this.islamicModule.getIslamicDate(date);
        return islamicDate.month >= this.islamicModule.getIslamicDate(new Date(1944, 1, 18)).month && islamicDate.year >= this.islamicModule.getIslamicDate(new Date(1944, 1, 18)).year && islamicDate.month <= this.islamicModule.getIslamicDate(new Date(2069, 1, 16)).month && islamicDate.year <= this.islamicModule.getIslamicDate(new Date(2069, 1, 16)).year;
      }
    };
    CalendarBase2.prototype.compareYear = function(start, end) {
      return this.compare(start, end, 0);
    };
    CalendarBase2.prototype.compareDecade = function(start, end) {
      return this.compare(start, end, 10);
    };
    CalendarBase2.prototype.shiftArray = function(array, i) {
      return array.slice(i).concat(array.slice(0, i));
    };
    CalendarBase2.prototype.addDay = function(date, i, e, max, min) {
      var column = i;
      var value = /* @__PURE__ */ new Date(+date);
      if (!isNullOrUndefined(this.tableBodyElement) && !isNullOrUndefined(e)) {
        while (this.findNextTD(/* @__PURE__ */ new Date(+date), column, max, min)) {
          column += i;
        }
        var rangeValue = new Date(value.setDate(value.getDate() + column));
        column = +rangeValue > +max || +rangeValue < +min ? column === i ? i - i : i : column;
      }
      date.setDate(date.getDate() + column);
    };
    CalendarBase2.prototype.findNextTD = function(date, column, max, min) {
      var value = new Date(date.setDate(date.getDate() + column));
      var collection = [];
      var isDisabled = false;
      if ((!isNullOrUndefined(value) && value.getMonth()) === (!isNullOrUndefined(this.currentDate) && this.currentDate.getMonth())) {
        var tdEles = void 0;
        if (this.calendarMode === "Gregorian") {
          tdEles = this.renderDays(value);
        } else {
          tdEles = this.islamicModule.islamicRenderDays(this.currentDate, value);
        }
        collection = tdEles.filter(function(element) {
          return element.classList.contains(DISABLED);
        });
      } else {
        collection = this.tableBodyElement.querySelectorAll("td." + DISABLED);
      }
      if (+value <= +max && +value >= +min) {
        if (collection.length) {
          for (var i = 0; i < collection.length; i++) {
            isDisabled = +value === +new Date(parseInt(collection[i].id, 0)) ? true : false;
            if (isDisabled) {
              break;
            }
          }
        }
      }
      return isDisabled;
    };
    CalendarBase2.prototype.getMaxDays = function(d) {
      var date;
      var tmpDate = new Date(this.checkValue(d));
      date = 28;
      var month = tmpDate.getMonth();
      while (tmpDate.getMonth() === month) {
        ++date;
        tmpDate.setDate(date);
      }
      return date - 1;
    };
    CalendarBase2.prototype.setDateDecade = function(date, year) {
      date.setFullYear(year);
      this.setProperties({ value: new Date(this.checkValue(date)) }, true);
    };
    CalendarBase2.prototype.setDateYear = function(date, value) {
      date.setFullYear(value.getFullYear(), value.getMonth(), date.getDate());
      if (value.getMonth() !== date.getMonth()) {
        date.setDate(0);
        this.currentDate = new Date(this.checkValue(value));
      }
      this.setProperties({ value: new Date(this.checkValue(date)) }, true);
    };
    CalendarBase2.prototype.compareMonth = function(start, end) {
      var result;
      if (start.getFullYear() > end.getFullYear()) {
        result = 1;
      } else if (start.getFullYear() < end.getFullYear()) {
        result = -1;
      } else {
        result = start.getMonth() === end.getMonth() ? 0 : start.getMonth() > end.getMonth() ? 1 : -1;
      }
      return result;
    };
    CalendarBase2.prototype.checkValue = function(inValue) {
      if (inValue instanceof Date) {
        return inValue.toUTCString();
      } else {
        return "" + inValue;
      }
    };
    CalendarBase2.prototype.checkView = function() {
      if (this.start !== "Decade" && this.start !== "Year") {
        this.setProperties({ start: "Month" }, true);
      }
      if (this.depth !== "Decade" && this.depth !== "Year") {
        this.setProperties({ depth: "Month" }, true);
      }
      if (this.getViewNumber(this.depth) > this.getViewNumber(this.start)) {
        this.setProperties({ depth: "Month" }, true);
      }
    };
    CalendarBase2.prototype.getDate = function(date, timezone) {
      if (timezone) {
        date = new Date(date.toLocaleString("en-US", { timeZone: timezone }));
      }
      return date;
    };
    __decorate([
      Property(new Date(1900, 0, 1))
    ], CalendarBase2.prototype, "min", void 0);
    __decorate([
      Property(true)
    ], CalendarBase2.prototype, "enabled", void 0);
    __decorate([
      Property(null)
    ], CalendarBase2.prototype, "cssClass", void 0);
    __decorate([
      Property(new Date(2099, 11, 31))
    ], CalendarBase2.prototype, "max", void 0);
    __decorate([
      Property(null)
    ], CalendarBase2.prototype, "firstDayOfWeek", void 0);
    __decorate([
      Property("Gregorian")
    ], CalendarBase2.prototype, "calendarMode", void 0);
    __decorate([
      Property("Month")
    ], CalendarBase2.prototype, "start", void 0);
    __decorate([
      Property("Month")
    ], CalendarBase2.prototype, "depth", void 0);
    __decorate([
      Property(false)
    ], CalendarBase2.prototype, "weekNumber", void 0);
    __decorate([
      Property("FirstDay")
    ], CalendarBase2.prototype, "weekRule", void 0);
    __decorate([
      Property(true)
    ], CalendarBase2.prototype, "showTodayButton", void 0);
    __decorate([
      Property("Short")
    ], CalendarBase2.prototype, "dayHeaderFormat", void 0);
    __decorate([
      Property(false)
    ], CalendarBase2.prototype, "enablePersistence", void 0);
    __decorate([
      Property(null)
    ], CalendarBase2.prototype, "keyConfigs", void 0);
    __decorate([
      Property(null)
    ], CalendarBase2.prototype, "serverTimezoneOffset", void 0);
    __decorate([
      Event()
    ], CalendarBase2.prototype, "created", void 0);
    __decorate([
      Event()
    ], CalendarBase2.prototype, "destroyed", void 0);
    __decorate([
      Event()
    ], CalendarBase2.prototype, "navigated", void 0);
    __decorate([
      Event()
    ], CalendarBase2.prototype, "renderDayCell", void 0);
    CalendarBase2 = __decorate([
      NotifyPropertyChanges
    ], CalendarBase2);
    return CalendarBase2;
  }(Component)
);
var Calendar = (
  /** @class */
  function(_super) {
    __extends44(Calendar2, _super);
    function Calendar2(options, element) {
      return _super.call(this, options, element) || this;
    }
    Calendar2.prototype.render = function() {
      if (this.calendarMode === "Islamic" && this.islamicModule === void 0) {
        throwError("Requires the injectable Islamic modules to render Calendar in Islamic mode");
      }
      if (this.isMultiSelection && typeof this.values === "object" && !isNullOrUndefined(this.values) && this.values.length > 0) {
        var tempValues = [];
        var copyValues = [];
        for (var limit = 0; limit < this.values.length; limit++) {
          if (tempValues.indexOf(+this.values[limit]) === -1) {
            tempValues.push(+this.values[limit]);
            copyValues.push(this.values[limit]);
          }
        }
        this.setProperties({ values: copyValues }, true);
        for (var index = 0; index < this.values.length; index++) {
          if (!this.checkDateValue(this.values[index])) {
            if (typeof this.values[index] === "string" && this.checkDateValue(new Date(this.checkValue(this.values[index])))) {
              var copyDate = new Date(this.checkValue(this.values[index]));
              this.values.splice(index, 1);
              this.values.splice(index, 0, copyDate);
            } else {
              this.values.splice(index, 1);
            }
          }
        }
        this.setProperties({ value: this.values[this.values.length - 1] }, true);
        this.previousValues = this.values.length;
      }
      this.validateDate();
      this.minMaxUpdate();
      if (this.getModuleName() === "calendar") {
        this.setEnable(this.enabled);
        this.setClass(this.cssClass);
      }
      _super.prototype.render.call(this);
      if (this.getModuleName() === "calendar") {
        var form = closest(this.element, "form");
        if (form) {
          EventHandler.add(form, "reset", this.formResetHandler.bind(this));
        }
        this.setTimeZone(this.serverTimezoneOffset);
      }
      this.renderComplete();
    };
    Calendar2.prototype.setEnable = function(enable) {
      if (!enable) {
        addClass([this.element], DISABLED);
      } else {
        removeClass([this.element], DISABLED);
      }
    };
    Calendar2.prototype.setClass = function(newCssClass, oldCssClass) {
      if (!isNullOrUndefined(oldCssClass)) {
        oldCssClass = oldCssClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(newCssClass)) {
        newCssClass = newCssClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(oldCssClass) && oldCssClass !== "") {
        removeClass([this.element], oldCssClass.split(" "));
      }
      if (!isNullOrUndefined(newCssClass)) {
        addClass([this.element], newCssClass.split(" "));
      }
    };
    Calendar2.prototype.isDayLightSaving = function() {
      var secondOffset = new Date(this.value.getFullYear(), 6, 1).getTimezoneOffset();
      var firstOffset = new Date(this.value.getFullYear(), 0, 1).getTimezoneOffset();
      return this.value.getTimezoneOffset() < Math.max(firstOffset, secondOffset);
    };
    Calendar2.prototype.setTimeZone = function(offsetValue) {
      if (!isNullOrUndefined(this.serverTimezoneOffset) && this.value) {
        var serverTimezoneDiff = offsetValue;
        var clientTimeZoneDiff = (/* @__PURE__ */ new Date()).getTimezoneOffset() / 60;
        var timeZoneDiff = serverTimezoneDiff + clientTimeZoneDiff;
        timeZoneDiff = this.isDayLightSaving() ? timeZoneDiff-- : timeZoneDiff;
        this.value = new Date(this.value.getTime() + timeZoneDiff * 60 * 60 * 1e3);
      }
    };
    Calendar2.prototype.formResetHandler = function() {
      this.setProperties({ value: null }, true);
    };
    Calendar2.prototype.validateDate = function() {
      if (typeof this.value === "string") {
        this.setProperties({ value: this.checkDateValue(new Date(this.checkValue(this.value))) }, true);
      }
      _super.prototype.validateDate.call(this, this.value);
      if (!isNullOrUndefined(this.value) && this.min <= this.max && this.value >= this.min && this.value <= this.max) {
        this.currentDate = new Date(this.checkValue(this.value));
      }
      if (isNaN(+this.value)) {
        this.setProperties({ value: null }, true);
      }
    };
    Calendar2.prototype.minMaxUpdate = function() {
      if (this.getModuleName() === "calendar") {
        if (!isNullOrUndefined(this.value) && this.value <= this.min && this.min <= this.max) {
          this.setProperties({ value: this.min }, true);
          this.changedArgs = { value: this.value };
        } else {
          if (!isNullOrUndefined(this.value) && this.value >= this.max && this.min <= this.max) {
            this.setProperties({ value: this.max }, true);
            this.changedArgs = { value: this.value };
          }
        }
      }
      if (this.getModuleName() !== "calendar" && !isNullOrUndefined(this.value)) {
        if (!isNullOrUndefined(this.value) && this.value < this.min && this.min <= this.max) {
          _super.prototype.minMaxUpdate.call(this, this.min);
        } else {
          if (!isNullOrUndefined(this.value) && this.value > this.max && this.min <= this.max) {
            _super.prototype.minMaxUpdate.call(this, this.max);
          }
        }
      } else {
        _super.prototype.minMaxUpdate.call(this, this.value);
      }
    };
    Calendar2.prototype.generateTodayVal = function(value) {
      var tempValue = /* @__PURE__ */ new Date();
      if (!isNullOrUndefined(this.timezone)) {
        tempValue = _super.prototype.getDate.call(this, tempValue, this.timezone);
      }
      if (value && isNullOrUndefined(this.timezone)) {
        tempValue.setHours(value.getHours());
        tempValue.setMinutes(value.getMinutes());
        tempValue.setSeconds(value.getSeconds());
        tempValue.setMilliseconds(value.getMilliseconds());
      } else {
        tempValue = new Date(tempValue.getFullYear(), tempValue.getMonth(), tempValue.getDate(), 0, 0, 0, 0);
      }
      return tempValue;
    };
    Calendar2.prototype.todayButtonClick = function(e) {
      if (this.showTodayButton) {
        var tempValue = this.generateTodayVal(this.value);
        this.setProperties({ value: tempValue }, true);
        this.isTodayClicked = true;
        this.todayButtonEvent = e;
        if (this.isMultiSelection) {
          var copyValues = this.copyValues(this.values);
          if (!_super.prototype.checkPresentDate.call(this, tempValue, this.values)) {
            copyValues.push(tempValue);
            this.setProperties({ values: copyValues });
          }
        }
        _super.prototype.todayButtonClick.call(this, e, /* @__PURE__ */ new Date(+this.value));
      }
    };
    Calendar2.prototype.keyActionHandle = function(e) {
      _super.prototype.keyActionHandle.call(this, e, this.value, this.isMultiSelection);
    };
    Calendar2.prototype.preRender = function() {
      var _this = this;
      this.changeHandler = function(e) {
        _this.triggerChange(e);
      };
      this.checkView();
      _super.prototype.preRender.call(this, this.value);
    };
    Calendar2.prototype.createContent = function() {
      this.previousDate = this.value;
      this.previousDateTime = this.value;
      _super.prototype.createContent.call(this);
    };
    Calendar2.prototype.minMaxDate = function(localDate) {
      return _super.prototype.minMaxDate.call(this, localDate);
    };
    Calendar2.prototype.renderMonths = function(e, value, isCustomDate) {
      _super.prototype.renderMonths.call(this, e, this.value, isCustomDate);
    };
    Calendar2.prototype.renderDays = function(currentDate, value, isMultiSelect, values, isCustomDate) {
      var tempDays = _super.prototype.renderDays.call(this, currentDate, this.value, this.isMultiSelection, this.values, isCustomDate);
      if (this.isMultiSelection) {
        _super.prototype.validateValues.call(this, this.isMultiSelection, this.values);
      }
      return tempDays;
    };
    Calendar2.prototype.renderYears = function(e) {
      if (this.calendarMode === "Gregorian") {
        _super.prototype.renderYears.call(this, e, this.value);
      } else {
        this.islamicModule.islamicRenderYears(e, this.value);
      }
    };
    Calendar2.prototype.renderDecades = function(e) {
      if (this.calendarMode === "Gregorian") {
        _super.prototype.renderDecades.call(this, e, this.value);
      } else {
        this.islamicModule.islamicRenderDecade(e, this.value);
      }
    };
    Calendar2.prototype.renderTemplate = function(elements, count, classNm, e) {
      if (this.calendarMode === "Gregorian") {
        _super.prototype.renderTemplate.call(this, elements, count, classNm, e, this.value);
      } else {
        this.islamicModule.islamicRenderTemplate(elements, count, classNm, e, this.value);
      }
      this.changedArgs = { value: this.value, values: this.values };
      this.changeHandler();
    };
    Calendar2.prototype.clickHandler = function(e) {
      var eve = e.currentTarget;
      this.isPopupClicked = true;
      if (eve.classList.contains(OTHERMONTH)) {
        if (this.isMultiSelection) {
          var copyValues = this.copyValues(this.values);
          copyValues.push(this.getIdValue(e, null));
          this.setProperties({ values: copyValues }, true);
          this.setProperties({ value: this.values[this.values.length - 1] }, true);
        } else {
          this.setProperties({ value: this.getIdValue(e, null) }, true);
        }
      }
      var storeView = this.currentView();
      _super.prototype.clickHandler.call(this, e, this.value);
      if (this.isMultiSelection && this.currentDate !== this.value && !isNullOrUndefined(this.tableBodyElement.querySelectorAll("." + FOCUSEDDATE)[0]) && storeView === "Year") {
        this.tableBodyElement.querySelectorAll("." + FOCUSEDDATE)[0].classList.remove(FOCUSEDDATE);
      }
    };
    Calendar2.prototype.switchView = function(view, e, isMultiSelection, isCustomDate) {
      _super.prototype.switchView.call(this, view, e, this.isMultiSelection, isCustomDate);
    };
    Calendar2.prototype.getModuleName = function() {
      _super.prototype.getModuleName.call(this);
      return "calendar";
    };
    Calendar2.prototype.getPersistData = function() {
      _super.prototype.getPersistData.call(this);
      var keyEntity = ["value", "values"];
      return this.addOnPersist(keyEntity);
    };
    Calendar2.prototype.onPropertyChanged = function(newProp, oldProp) {
      this.effect = "";
      this.rangeValidation(this.min, this.max);
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "value":
            if (this.isDateSelected) {
              if (typeof newProp.value === "string") {
                this.setProperties({ value: new Date(this.checkValue(newProp.value)) }, true);
              } else {
                newProp.value = new Date(this.checkValue(newProp.value));
              }
              if (isNaN(+this.value)) {
                this.setProperties({ value: oldProp.value }, true);
              }
              this.update();
            }
            break;
          case "values":
            if (this.isDateSelected) {
              if (typeof newProp.values === "string" || typeof newProp.values === "number") {
                this.setProperties({ values: null }, true);
              } else {
                var copyValues = this.copyValues(this.values);
                for (var index = 0; index < copyValues.length; index++) {
                  var tempDate = copyValues[index];
                  if (this.checkDateValue(tempDate) && !_super.prototype.checkPresentDate.call(this, tempDate, copyValues)) {
                    copyValues.push(tempDate);
                  }
                }
                this.setProperties({ values: copyValues }, true);
                if (this.values.length > 0) {
                  this.setProperties({ value: newProp.values[newProp.values.length - 1] }, true);
                }
              }
              this.validateValues(this.isMultiSelection, this.values);
              this.update();
            }
            break;
          case "isMultiSelection":
            if (this.isDateSelected) {
              this.setProperties({ isMultiSelection: newProp.isMultiSelection }, true);
              this.update();
            }
            break;
          case "enabled":
            this.setEnable(this.enabled);
            break;
          case "cssClass":
            if (this.getModuleName() === "calendar") {
              this.setClass(newProp.cssClass, oldProp.cssClass);
            }
            break;
          default:
            _super.prototype.onPropertyChanged.call(this, newProp, oldProp, this.isMultiSelection, this.values);
        }
      }
      this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
    };
    Calendar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.getModuleName() === "calendar") {
        var form = closest(this.element, "form");
        if (form) {
          EventHandler.remove(form, "reset", this.formResetHandler.bind(this));
        }
      }
    };
    Calendar2.prototype.navigateTo = function(view, date, isCustomDate) {
      this.minMaxUpdate();
      _super.prototype.navigateTo.call(this, view, date, isCustomDate);
    };
    Calendar2.prototype.currentView = function() {
      return _super.prototype.currentView.call(this);
    };
    Calendar2.prototype.addDate = function(dates) {
      if (typeof dates !== "string" && typeof dates !== "number") {
        var copyValues = this.copyValues(this.values);
        if (typeof dates === "object" && dates.length > 0) {
          var tempDates = dates;
          for (var i = 0; i < tempDates.length; i++) {
            if (this.checkDateValue(tempDates[i]) && !_super.prototype.checkPresentDate.call(this, tempDates[i], copyValues)) {
              if (!isNullOrUndefined(copyValues) && copyValues.length > 0) {
                copyValues.push(tempDates[i]);
              } else {
                copyValues = [/* @__PURE__ */ new Date(+tempDates[i])];
              }
            }
          }
        } else {
          if (this.checkDateValue(dates) && !_super.prototype.checkPresentDate.call(this, dates, copyValues)) {
            if (!isNullOrUndefined(copyValues) && copyValues.length > 0) {
              copyValues.push(dates);
            } else {
              copyValues = [/* @__PURE__ */ new Date(+dates)];
            }
          }
        }
        this.setProperties({ values: copyValues }, true);
        if (this.isMultiSelection) {
          this.setProperties({ value: this.values[this.values.length - 1] }, true);
        }
        this.validateValues(this.isMultiSelection, copyValues);
        this.update();
        this.changedArgs = { value: this.value, values: this.values };
        this.changeHandler();
      }
    };
    Calendar2.prototype.removeDate = function(dates) {
      if (typeof dates !== "string" && typeof dates !== "number" && !isNullOrUndefined(this.values) && this.values.length > 0) {
        var copyValues = this.copyValues(this.values);
        if (typeof dates === "object" && dates.length > 0) {
          var tempDates = dates;
          for (var index = 0; index < tempDates.length; index++) {
            for (var i = 0; i < copyValues.length; i++) {
              if (+copyValues[i] === +tempDates[index]) {
                copyValues.splice(i, 1);
              }
            }
          }
        } else {
          for (var i = 0; i < copyValues.length; i++) {
            if (+copyValues[i] === +dates) {
              copyValues.splice(i, 1);
            }
          }
        }
        this.setProperties({ values: copyValues }, false);
        this.update();
        if (this.isMultiSelection) {
          this.setProperties({ value: this.values[this.values.length - 1] }, true);
        }
        this.changedArgs = { value: this.value, values: this.values };
        this.changeHandler();
      }
    };
    Calendar2.prototype.setTodayDate = function(date) {
      var todayDate = /* @__PURE__ */ new Date(+date);
      this.setProperties({ value: todayDate }, true);
      _super.prototype.todayButtonClick.call(this, null, todayDate, true);
    };
    Calendar2.prototype.update = function() {
      this.validateDate();
      this.minMaxUpdate();
      _super.prototype.setValueUpdate.call(this);
    };
    Calendar2.prototype.selectDate = function(e, date, element) {
      _super.prototype.selectDate.call(this, e, date, element, this.isMultiSelection, this.values);
      if (this.isMultiSelection && !isNullOrUndefined(this.values) && this.values.length > 0) {
        this.setProperties({ value: this.values[this.values.length - 1] }, true);
      }
      this.changedArgs = { value: this.value, values: this.values };
      this.changeHandler(e);
    };
    Calendar2.prototype.changeEvent = function(e) {
      if ((this.value && this.value.valueOf()) !== (this.previousDate && +this.previousDate.valueOf()) || this.isMultiSelection) {
        if (this.isAngular && this.preventChange) {
          this.preventChange = false;
        } else {
          this.trigger("change", this.changedArgs);
        }
        this.previousDate = /* @__PURE__ */ new Date(+this.value);
      }
    };
    Calendar2.prototype.triggerChange = function(e) {
      if (!isNullOrUndefined(this.todayButtonEvent) && this.isTodayClicked) {
        e = this.todayButtonEvent;
        this.isTodayClicked = false;
      }
      this.changedArgs.event = e || null;
      this.changedArgs.isInteracted = !isNullOrUndefined(e);
      if (!isNullOrUndefined(this.value)) {
        this.setProperties({ value: this.value }, true);
      }
      if (!this.isMultiSelection && +this.value !== Number.NaN && (+this.value !== +this.previousDate || this.previousDate == null && !isNaN(+this.value))) {
        this.changeEvent(e);
      } else if (!isNullOrUndefined(this.values) && this.previousValues !== this.values.length) {
        this.changeEvent(e);
        this.previousValues = this.values.length;
      }
    };
    __decorate([
      Property(null)
    ], Calendar2.prototype, "value", void 0);
    __decorate([
      Property(null)
    ], Calendar2.prototype, "values", void 0);
    __decorate([
      Property(false)
    ], Calendar2.prototype, "isMultiSelection", void 0);
    __decorate([
      Event()
    ], Calendar2.prototype, "change", void 0);
    Calendar2 = __decorate([
      NotifyPropertyChanges
    ], Calendar2);
    return Calendar2;
  }(CalendarBase)
);

// node_modules/@syncfusion/ej2-calendars/src/datepicker/datepicker.js
var __extends45 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DATEWRAPPER = "e-date-wrapper";
var ROOT2 = "e-datepicker";
var LIBRARY = "e-lib";
var CONTROL = "e-control";
var POPUPWRAPPER = "e-popup-wrapper";
var INPUTWRAPPER = "e-input-group-icon";
var POPUP = "e-popup";
var INPUTCONTAINER = "e-input-group";
var INPUTFOCUS = "e-input-focus";
var INPUTROOT = "e-input";
var ERROR = "e-error";
var ACTIVE = "e-active";
var OVERFLOW = "e-date-overflow";
var DATEICON = "e-date-icon";
var ICONS = "e-icons";
var OPENDURATION = 300;
var OFFSETVALUE = 4;
var SELECTED2 = "e-selected";
var FOCUSEDDATE2 = "e-focused-date";
var NONEDIT = "e-non-edit";
var containerAttr = ["title", "class", "style"];
var DatePicker = (
  /** @class */
  function(_super) {
    __extends45(DatePicker2, _super);
    function DatePicker2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.previousElementValue = "";
      _this.isDateIconClicked = false;
      _this.isAltKeyPressed = false;
      _this.isInteracted = true;
      _this.invalidValueString = null;
      _this.checkPreviousValue = null;
      _this.maskedDateValue = "";
      _this.isAngular = false;
      _this.preventChange = false;
      _this.isIconClicked = false;
      _this.isDynamicValueChanged = false;
      _this.moduleName = _this.getModuleName();
      _this.datepickerOptions = options;
      return _this;
    }
    DatePicker2.prototype.render = function() {
      this.initialize();
      this.bindEvents();
      this.renderComplete();
      this.setTimeZone(this.serverTimezoneOffset);
    };
    DatePicker2.prototype.setTimeZone = function(offsetValue) {
      if (!isNullOrUndefined(this.serverTimezoneOffset) && this.value) {
        var clientTimeZoneDiff = (/* @__PURE__ */ new Date()).getTimezoneOffset() / 60;
        var serverTimezoneDiff = offsetValue;
        var timeZoneDiff = serverTimezoneDiff + clientTimeZoneDiff;
        timeZoneDiff = this.isDayLightSaving() ? timeZoneDiff-- : timeZoneDiff;
        this.value = new Date(this.value.getTime() + timeZoneDiff * 60 * 60 * 1e3);
        this.updateInput();
      }
    };
    DatePicker2.prototype.isDayLightSaving = function() {
      var firstOffset = new Date(this.value.getFullYear(), 0, 1).getTimezoneOffset();
      var secondOffset = new Date(this.value.getFullYear(), 6, 1).getTimezoneOffset();
      return this.value.getTimezoneOffset() < Math.max(firstOffset, secondOffset);
    };
    DatePicker2.prototype.setAllowEdit = function() {
      if (this.allowEdit) {
        if (!this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
      } else {
        attributes(this.inputElement, { "readonly": "" });
      }
      this.updateIconState();
    };
    DatePicker2.prototype.updateIconState = function() {
      if (!this.allowEdit && this.inputWrapper && !this.readonly) {
        if (this.inputElement.value === "") {
          removeClass([this.inputWrapper.container], [NONEDIT]);
        } else {
          addClass([this.inputWrapper.container], [NONEDIT]);
        }
      } else if (this.inputWrapper) {
        removeClass([this.inputWrapper.container], [NONEDIT]);
      }
    };
    DatePicker2.prototype.initialize = function() {
      this.checkInvalidValue(this.value);
      if (this.enableMask) {
        this.notify("createMask", {
          module: "MaskedDateTime"
        });
      }
      this.createInput();
      this.updateHtmlAttributeToWrapper();
      this.setAllowEdit();
      this.updateInput();
      if (this.enableMask && !this.value && this.maskedDateValue && (this.floatLabelType == "Always" || !this.floatLabelType || !this.placeholder)) {
        this.updateInputValue(this.maskedDateValue);
      }
      this.previousElementValue = this.inputElement.value;
      this.previousDate = !isNullOrUndefined(this.value) ? /* @__PURE__ */ new Date(+this.value) : null;
      this.inputElement.setAttribute("value", this.inputElement.value);
      this.inputValueCopy = this.value;
    };
    DatePicker2.prototype.createInput = function() {
      var ariaAttrs = {
        "aria-live": "assertive",
        "aria-atomic": "true",
        "aria-haspopup": "true",
        "aria-activedescendant": "null",
        "aria-owns": this.element.id + "_options",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off",
        "autocorrect": "off",
        "autocapitalize": "off",
        "spellcheck": "false",
        "aria-invalid": "false"
      };
      if (this.getModuleName() === "datepicker") {
        var l10nLocale = { placeholder: this.placeholder };
        this.globalize = new Internationalization(this.locale);
        this.l10n = new L10n("datepicker", l10nLocale, this.locale);
        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      }
      var updatedCssClassValues = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValues = this.cssClass.replace(/\s+/g, " ").trim();
      }
      var isBindClearAction = this.enableMask ? false : true;
      this.inputWrapper = Input.createInput({
        element: this.inputElement,
        floatLabelType: this.floatLabelType,
        bindClearAction: isBindClearAction,
        properties: {
          readonly: this.readonly,
          placeholder: this.placeholder,
          cssClass: updatedCssClassValues,
          enabled: this.enabled,
          enableRtl: this.enableRtl,
          showClearButton: this.showClearButton
        },
        buttons: [INPUTWRAPPER + " " + DATEICON + " " + ICONS]
      }, this.createElement);
      this.setWidth(this.width);
      if (this.inputElement.name !== "") {
        this.inputElement.setAttribute("name", "" + this.inputElement.getAttribute("name"));
      } else {
        this.inputElement.setAttribute("name", "" + this.element.id);
      }
      attributes(this.inputElement, ariaAttrs);
      if (!this.enabled) {
        this.inputElement.setAttribute("aria-disabled", "true");
        this.inputElement.tabIndex = -1;
      } else {
        this.inputElement.setAttribute("aria-disabled", "false");
        this.inputElement.setAttribute("tabindex", this.tabIndex);
      }
      Input.addAttributes({ "aria-label": "select" }, this.inputWrapper.buttons[0]);
      addClass([this.inputWrapper.container], DATEWRAPPER);
    };
    DatePicker2.prototype.updateInput = function(isDynamic) {
      if (isDynamic === void 0) {
        isDynamic = false;
      }
      var formatOptions;
      if (this.value && !this.isCalendar() && !isDynamic) {
        this.disabledDates();
      }
      if (isNaN(+new Date(this.checkValue(this.value)))) {
        this.setProperties({ value: null }, true);
      }
      if (this.strictMode) {
        _super.prototype.validateDate.call(this);
        this.minMaxUpdates();
        _super.prototype.minMaxUpdate.call(this);
      }
      if (!isNullOrUndefined(this.value)) {
        var dateValue = this.value;
        var dateString = void 0;
        var tempFormat = !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat;
        if (this.getModuleName() === "datetimepicker") {
          if (this.calendarMode === "Gregorian") {
            dateString = this.globalize.formatDate(this.value, {
              format: tempFormat,
              type: "dateTime",
              skeleton: "yMd"
            });
          } else {
            dateString = this.globalize.formatDate(this.value, {
              format: tempFormat,
              type: "dateTime",
              skeleton: "yMd",
              calendar: "islamic"
            });
          }
        } else {
          if (this.calendarMode === "Gregorian") {
            formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd" };
          } else {
            formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
          }
          dateString = this.globalize.formatDate(this.value, formatOptions);
        }
        if (+dateValue <= +this.max && +dateValue >= +this.min) {
          this.updateInputValue(dateString);
        } else {
          var value = +dateValue >= +this.max || !+this.value || (!+this.value || +dateValue <= +this.min);
          if (!this.strictMode && value) {
            this.updateInputValue(dateString);
          }
        }
      }
      if (isNullOrUndefined(this.value) && this.strictMode) {
        if (!this.enableMask) {
          this.updateInputValue("");
        } else {
          this.updateInputValue(this.maskedDateValue);
          this.notify("createMask", {
            module: "MaskedDateTime"
          });
        }
      }
      if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {
        this.updateInputValue(this.invalidValueString);
      }
      this.changedArgs = { value: this.value };
      this.errorClass();
      this.updateIconState();
    };
    DatePicker2.prototype.minMaxUpdates = function() {
      if (!isNullOrUndefined(this.value) && this.value < this.min && this.min <= this.max && this.strictMode) {
        this.setProperties({ value: this.min }, true);
        this.changedArgs = { value: this.value };
      } else {
        if (!isNullOrUndefined(this.value) && this.value > this.max && this.min <= this.max && this.strictMode) {
          this.setProperties({ value: this.max }, true);
          this.changedArgs = { value: this.value };
        }
      }
    };
    DatePicker2.prototype.checkStringValue = function(val) {
      var returnDate = null;
      var formatOptions = null;
      var formatDateTime = null;
      if (this.getModuleName() === "datetimepicker") {
        var culture = new Internationalization(this.locale);
        if (this.calendarMode === "Gregorian") {
          formatOptions = { format: this.dateTimeFormat, type: "dateTime", skeleton: "yMd" };
          formatDateTime = { format: culture.getDatePattern({ skeleton: "yMd" }), type: "dateTime" };
        } else {
          formatOptions = { format: this.dateTimeFormat, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
          formatDateTime = { format: culture.getDatePattern({ skeleton: "yMd" }), type: "dateTime", calendar: "islamic" };
        }
      } else {
        if (this.calendarMode === "Gregorian") {
          formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd" };
        } else {
          formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
        }
      }
      returnDate = this.checkDateValue(this.globalize.parseDate(val, formatOptions));
      if (isNullOrUndefined(returnDate) && this.getModuleName() === "datetimepicker") {
        returnDate = this.checkDateValue(this.globalize.parseDate(val, formatDateTime));
      }
      return returnDate;
    };
    DatePicker2.prototype.checkInvalidValue = function(value) {
      if (!(value instanceof Date) && !isNullOrUndefined(value)) {
        var valueDate = null;
        var valueString = value;
        if (typeof value === "number") {
          valueString = value.toString();
        }
        var formatOptions = null;
        var formatDateTime = null;
        if (this.getModuleName() === "datetimepicker") {
          var culture = new Internationalization(this.locale);
          if (this.calendarMode === "Gregorian") {
            formatOptions = { format: this.dateTimeFormat, type: "dateTime", skeleton: "yMd" };
            formatDateTime = { format: culture.getDatePattern({ skeleton: "yMd" }), type: "dateTime" };
          } else {
            formatOptions = { format: this.dateTimeFormat, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
            formatDateTime = { format: culture.getDatePattern({ skeleton: "yMd" }), type: "dateTime", calendar: "islamic" };
          }
        } else {
          if (this.calendarMode === "Gregorian") {
            formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd" };
          } else {
            formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
          }
        }
        var invalid = false;
        if (typeof valueString !== "string") {
          valueString = null;
          invalid = true;
        } else {
          if (typeof valueString === "string") {
            valueString = valueString.trim();
          }
          valueDate = this.checkStringValue(valueString);
          if (!valueDate) {
            var extISOString = null;
            var basicISOString = null;
            extISOString = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
            basicISOString = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
            if (!extISOString.test(valueString) && !basicISOString.test(valueString) || /^[a-zA-Z0-9- ]*$/.test(valueString) || isNaN(+new Date(this.checkValue(valueString)))) {
              invalid = true;
            } else {
              valueDate = new Date(valueString);
            }
          }
        }
        if (invalid) {
          if (!this.strictMode) {
            this.invalidValueString = valueString;
          }
          this.setProperties({ value: null }, true);
        } else {
          this.setProperties({ value: valueDate }, true);
        }
      }
    };
    DatePicker2.prototype.bindInputEvent = function() {
      if (!isNullOrUndefined(this.formatString) || this.enableMask) {
        if (this.enableMask || this.formatString.indexOf("y") === -1) {
          EventHandler.add(this.inputElement, "input", this.inputHandler, this);
        } else {
          EventHandler.remove(this.inputElement, "input", this.inputHandler);
        }
      }
    };
    DatePicker2.prototype.bindEvents = function() {
      EventHandler.add(this.inputWrapper.buttons[0], "mousedown touchstart", this.dateIconHandler, this);
      EventHandler.add(this.inputElement, "mouseup", this.mouseUpHandler, this);
      EventHandler.add(this.inputElement, "focus", this.inputFocusHandler, this);
      EventHandler.add(this.inputElement, "blur", this.inputBlurHandler, this);
      if (this.enableMask) {
        EventHandler.add(this.inputElement, "keydown", this.keydownHandler, this);
      }
      this.bindInputEvent();
      EventHandler.add(this.inputElement, "change", this.inputChangeHandler, this);
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown touchstart", this.resetHandler, this);
      }
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.resetFormHandler, this);
      }
      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
      this.keyboardModules = new KeyboardEvents(this.inputElement, {
        eventName: "keydown",
        keyAction: this.inputKeyActionHandle.bind(this),
        keyConfigs: this.defaultKeyConfigs
      });
    };
    DatePicker2.prototype.keydownHandler = function(e) {
      switch (e.code) {
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown":
        case "Home":
        case "End":
        case "Delete":
          if (this.enableMask && !this.popupObj && !this.readonly) {
            if (e.code !== "Delete") {
              e.preventDefault();
            }
            this.notify("keyDownHandler", {
              module: "MaskedDateTime",
              e
            });
          }
          break;
        default:
          break;
      }
    };
    DatePicker2.prototype.unBindEvents = function() {
      EventHandler.remove(this.inputWrapper.buttons[0], "mousedown touchstart", this.dateIconHandler);
      EventHandler.remove(this.inputElement, "mouseup", this.mouseUpHandler);
      EventHandler.remove(this.inputElement, "focus", this.inputFocusHandler);
      EventHandler.remove(this.inputElement, "blur", this.inputBlurHandler);
      EventHandler.remove(this.inputElement, "change", this.inputChangeHandler);
      if (this.enableMask) {
        EventHandler.remove(this.inputElement, "keydown", this.keydownHandler);
      }
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.remove(this.inputWrapper.clearButton, "mousedown touchstart", this.resetHandler);
      }
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.resetFormHandler);
      }
    };
    DatePicker2.prototype.resetFormHandler = function() {
      if (!this.enabled) {
        return;
      }
      if (!this.inputElement.disabled) {
        var value = this.inputElement.getAttribute("value");
        if (this.element.tagName === "EJS-DATEPICKER" || this.element.tagName === "EJS-DATETIMEPICKER") {
          value = "";
          this.inputValueCopy = null;
          this.inputElement.setAttribute("value", "");
        }
        this.setProperties({ value: this.inputValueCopy }, true);
        this.restoreValue();
        if (this.inputElement) {
          this.updateInputValue(value);
          this.errorClass();
        }
      }
    };
    DatePicker2.prototype.restoreValue = function() {
      this.currentDate = this.value ? this.value : /* @__PURE__ */ new Date();
      this.previousDate = this.value;
      this.previousElementValue = isNullOrUndefined(this.inputValueCopy) ? "" : this.globalize.formatDate(this.inputValueCopy, {
        format: this.formatString,
        type: "dateTime",
        skeleton: "yMd"
      });
    };
    DatePicker2.prototype.inputChangeHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      e.stopPropagation();
    };
    DatePicker2.prototype.bindClearEvent = function() {
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown touchstart", this.resetHandler, this);
      }
    };
    DatePicker2.prototype.resetHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      e.preventDefault();
      this.clear(e);
    };
    DatePicker2.prototype.mouseUpHandler = function(e) {
      if (this.enableMask) {
        e.preventDefault();
        this.notify("setMaskSelection", {
          module: "MaskedDateTime"
        });
      }
    };
    DatePicker2.prototype.clear = function(event) {
      this.setProperties({ value: null }, true);
      if (!this.enableMask) {
        this.updateInputValue("");
      }
      var clearedArgs = {
        event
      };
      this.trigger("cleared", clearedArgs);
      this.invalidValueString = "";
      this.updateInput();
      this.popupUpdate();
      this.changeEvent(event);
      if (this.enableMask) {
        this.notify("clearHandler", {
          module: "MaskedDateTime"
        });
      }
    };
    DatePicker2.prototype.preventEventBubbling = function(e) {
      e.preventDefault();
      this.interopAdaptor.invokeMethodAsync("OnDateIconClick");
    };
    DatePicker2.prototype.updateInputValue = function(value) {
      Input.setValue(value, this.inputElement, this.floatLabelType, this.showClearButton);
    };
    DatePicker2.prototype.dateIconHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      this.isIconClicked = true;
      if (Browser.isDevice) {
        this.inputElement.setAttribute("readonly", "");
        this.inputElement.blur();
      }
      e.preventDefault();
      if (!this.readonly) {
        if (this.isCalendar()) {
          this.hide(e);
        } else {
          this.isDateIconClicked = true;
          this.show(null, e);
          if (this.getModuleName() === "datetimepicker") {
            this.inputElement.focus();
          }
          this.inputElement.focus();
          addClass([this.inputWrapper.container], [INPUTFOCUS]);
          addClass(this.inputWrapper.buttons, ACTIVE);
        }
      }
      this.isIconClicked = false;
    };
    DatePicker2.prototype.updateHtmlAttributeToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (!isNullOrUndefined(this.htmlAttributes[key])) {
            if (containerAttr.indexOf(key) > -1) {
              if (key === "class") {
                var updatedClassValues = this.htmlAttributes[key].replace(/\s+/g, " ").trim();
                if (updatedClassValues !== "") {
                  addClass([this.inputWrapper.container], updatedClassValues.split(" "));
                }
              } else if (key === "style") {
                var setStyle = this.inputWrapper.container.getAttribute(key);
                if (!isNullOrUndefined(setStyle)) {
                  if (setStyle.charAt(setStyle.length - 1) === ";") {
                    setStyle = setStyle + this.htmlAttributes[key];
                  } else {
                    setStyle = setStyle + ";" + this.htmlAttributes[key];
                  }
                } else {
                  setStyle = this.htmlAttributes[key];
                }
                this.inputWrapper.container.setAttribute(key, setStyle);
              } else {
                this.inputWrapper.container.setAttribute(key, this.htmlAttributes[key]);
              }
            }
          }
        }
      }
    };
    DatePicker2.prototype.updateHtmlAttributeToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (containerAttr.indexOf(key) < 0) {
            this.inputElement.setAttribute(key, this.htmlAttributes[key]);
          }
        }
      }
    };
    DatePicker2.prototype.updateCssClass = function(newCssClass, oldCssClass) {
      if (!isNullOrUndefined(oldCssClass)) {
        oldCssClass = oldCssClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(newCssClass)) {
        newCssClass = newCssClass.replace(/\s+/g, " ").trim();
      }
      Input.setCssClass(newCssClass, [this.inputWrapper.container], oldCssClass);
      if (this.popupWrapper) {
        Input.setCssClass(newCssClass, [this.popupWrapper], oldCssClass);
      }
    };
    DatePicker2.prototype.calendarKeyActionHandle = function(e) {
      switch (e.action) {
        case "escape":
          if (this.isCalendar()) {
            this.hide(e);
          } else {
            this.inputWrapper.container.children[this.index].blur();
          }
          break;
        case "enter":
          if (!this.isCalendar()) {
            this.show(null, e);
          } else {
            if (+this.value !== +this.currentDate && !this.isCalendar()) {
              this.inputWrapper.container.children[this.index].focus();
            }
          }
          if (this.getModuleName() === "datetimepicker") {
            this.inputElement.focus();
          }
          break;
        case "tab":
          this.hide(e);
      }
    };
    DatePicker2.prototype.inputFocusHandler = function() {
      if (!this.enabled) {
        return;
      }
      if (this.enableMask && !this.inputElement.value && this.placeholder) {
        if (this.maskedDateValue && !this.value && (this.floatLabelType == "Auto" || this.floatLabelType == "Never" || this.placeholder)) {
          this.updateInputValue(this.maskedDateValue);
          this.inputElement.selectionStart = 0;
          this.inputElement.selectionEnd = this.inputElement.value.length;
        }
      }
      var focusArguments = {
        model: this
      };
      this.isDateIconClicked = false;
      this.trigger("focus", focusArguments);
      this.updateIconState();
      if (this.openOnFocus && !this.isIconClicked) {
        this.show();
      }
    };
    DatePicker2.prototype.inputHandler = function() {
      this.isPopupClicked = false;
      if (this.enableMask) {
        this.notify("inputHandler", {
          module: "MaskedDateTime"
        });
      }
    };
    DatePicker2.prototype.inputBlurHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      this.strictModeUpdate();
      if (this.inputElement.value === "" && isNullOrUndefined(this.value)) {
        this.invalidValueString = null;
        this.updateInputValue("");
      }
      this.updateInput();
      this.popupUpdate();
      this.changeTrigger(e);
      if (this.enableMask && this.maskedDateValue && this.placeholder && this.floatLabelType !== "Always") {
        if (this.inputElement.value == this.maskedDateValue && !this.value && (this.floatLabelType == "Auto" || this.floatLabelType == "Never" || this.placeholder)) {
          this.updateInputValue("");
        }
      }
      this.errorClass();
      if (this.isCalendar() && document.activeElement === this.inputElement) {
        this.hide(e);
      }
      if (this.getModuleName() === "datepicker") {
        var blurArguments = {
          model: this
        };
        this.trigger("blur", blurArguments);
      }
      if (this.isCalendar()) {
        this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
        this.calendarKeyboardModules = new KeyboardEvents(this.calendarElement.children[1].firstElementChild, {
          eventName: "keydown",
          keyAction: this.calendarKeyActionHandle.bind(this),
          keyConfigs: this.defaultKeyConfigs
        });
      }
      this.isPopupClicked = false;
    };
    DatePicker2.prototype.documentHandler = function(e) {
      if (!isNullOrUndefined(this.popupObj) && (this.inputWrapper.container.contains(e.target) || this.popupObj.element && this.popupObj.element.contains(e.target)) && e.type !== "touchstart") {
        e.preventDefault();
      }
      var target = e.target;
      if (!closest(target, ".e-datepicker.e-popup-wrapper") && !(closest(target, "." + INPUTCONTAINER) === this.inputWrapper.container) && !target.classList.contains("e-day")) {
        this.hide(e);
        this.focusOut();
      } else if (closest(target, ".e-datepicker.e-popup-wrapper")) {
        if (target.classList.contains("e-day") && !isNullOrUndefined(e.target.parentElement) && e.target.parentElement.classList.contains("e-selected") && closest(target, ".e-content") && closest(target, ".e-content").classList.contains("e-" + this.depth.toLowerCase())) {
          this.hide(e);
        } else if (closest(target, ".e-footer-container") && target.classList.contains("e-today") && target.classList.contains("e-btn") && +/* @__PURE__ */ new Date(+this.value) === +_super.prototype.generateTodayVal.call(this, this.value)) {
          this.hide(e);
        }
      }
    };
    DatePicker2.prototype.inputKeyActionHandle = function(e) {
      var clickedView = this.currentView();
      switch (e.action) {
        case "altUpArrow":
          this.isAltKeyPressed = false;
          this.hide(e);
          this.inputElement.focus();
          break;
        case "altDownArrow":
          this.isAltKeyPressed = true;
          this.strictModeUpdate();
          this.updateInput();
          this.changeTrigger(e);
          if (this.getModuleName() === "datepicker") {
            this.show(null, e);
          }
          break;
        case "escape":
          this.hide(e);
          break;
        case "enter":
          this.strictModeUpdate();
          this.updateInput();
          this.popupUpdate();
          this.changeTrigger(e);
          this.errorClass();
          if (!this.isCalendar() && document.activeElement === this.inputElement) {
            this.hide(e);
          }
          if (this.isCalendar()) {
            e.preventDefault();
            e.stopPropagation();
          }
          break;
        case "tab":
        case "shiftTab":
          var start = this.inputElement.selectionStart;
          var end = this.inputElement.selectionEnd;
          if (this.enableMask && !this.popupObj && !this.readonly) {
            var length_1 = this.inputElement.value.length;
            if (start == 0 && end == length_1 || end !== length_1 && e.action == "tab" || start !== 0 && e.action == "shiftTab") {
              e.preventDefault();
            }
            this.notify("keyDownHandler", {
              module: "MaskedDateTime",
              e
            });
            start = this.inputElement.selectionStart;
            end = this.inputElement.selectionEnd;
          }
          this.strictModeUpdate();
          this.updateInput();
          this.popupUpdate();
          this.changeTrigger(e);
          this.errorClass();
          if (this.enableMask) {
            this.inputElement.selectionStart = start;
            this.inputElement.selectionEnd = end;
          }
          this.hide(e);
          break;
        default:
          this.defaultAction(e);
          if (e.action === "select" && clickedView === this.depth) {
            this.hide(e);
          }
      }
    };
    DatePicker2.prototype.defaultAction = function(e) {
      this.previousDate = !isNullOrUndefined(this.value) && /* @__PURE__ */ new Date(+this.value) || null;
      if (this.isCalendar()) {
        _super.prototype.keyActionHandle.call(this, e);
        if (this.isCalendar()) {
          attributes(this.inputElement, {
            "aria-activedescendant": "" + this.setActiveDescendant()
          });
        }
      }
    };
    DatePicker2.prototype.popupUpdate = function() {
      if (isNullOrUndefined(this.value) && !isNullOrUndefined(this.previousDate) || +this.value !== +this.previousDate) {
        if (this.popupObj) {
          if (this.popupObj.element.querySelectorAll("." + SELECTED2).length > 0) {
            removeClass(this.popupObj.element.querySelectorAll("." + SELECTED2), [SELECTED2]);
          }
        }
        if (!isNullOrUndefined(this.value)) {
          if (+this.value >= +this.min && +this.value <= +this.max) {
            var targetdate = new Date(this.checkValue(this.value));
            _super.prototype.navigateTo.call(this, "Month", targetdate);
          }
        }
      }
    };
    DatePicker2.prototype.strictModeUpdate = function() {
      var format;
      var formatOptions;
      if (this.getModuleName() === "datetimepicker") {
        format = !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat;
      } else {
        format = isNullOrUndefined(this.formatString) ? this.formatString : this.formatString.replace("dd", "d");
      }
      if (!isNullOrUndefined(format)) {
        var len = format.split("M").length - 1;
        if (len < 3) {
          format = format.replace("MM", "M");
        }
      }
      var dateOptions;
      if (this.getModuleName() === "datetimepicker") {
        if (this.calendarMode === "Gregorian") {
          dateOptions = {
            format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,
            type: "dateTime",
            skeleton: "yMd"
          };
        } else {
          dateOptions = {
            format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,
            type: "dateTime",
            skeleton: "yMd",
            calendar: "islamic"
          };
        }
      } else {
        if (this.calendarMode === "Gregorian") {
          formatOptions = { format, type: "dateTime", skeleton: "yMd" };
        } else {
          formatOptions = { format, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
        }
        dateOptions = formatOptions;
      }
      var date;
      if (typeof this.inputElement.value === "string") {
        this.inputElement.value = this.inputElement.value.trim();
      }
      if (this.getModuleName() === "datetimepicker") {
        if (this.checkDateValue(this.globalize.parseDate(this.inputElement.value, dateOptions))) {
          date = this.globalize.parseDate(this.inputElement.value, dateOptions);
        } else {
          if (this.calendarMode === "Gregorian") {
            formatOptions = { type: "dateTime", skeleton: "yMd" };
          } else {
            formatOptions = { type: "dateTime", skeleton: "yMd", calendar: "islamic" };
          }
          date = this.globalize.parseDate(this.inputElement.value, formatOptions);
        }
      } else {
        date = this.globalize.parseDate(this.inputElement.value, dateOptions);
        date = !isNullOrUndefined(date) && isNaN(+date) ? null : date;
        if (!isNullOrUndefined(this.formatString) && this.inputElement.value !== "" && this.strictMode) {
          if ((this.isPopupClicked || !this.isPopupClicked && this.inputElement.value === this.previousElementValue) && this.formatString.indexOf("y") === -1) {
            date.setFullYear(this.value.getFullYear());
          }
        }
      }
      if (this.getModuleName() === "datepicker" && (this.value && !isNaN(+this.value)) && date) {
        date.setHours(this.value.getHours(), this.value.getMinutes(), this.value.getSeconds(), this.value.getMilliseconds());
      }
      if (this.strictMode && date) {
        this.updateInputValue(this.globalize.formatDate(date, dateOptions));
        if (this.inputElement.value !== this.previousElementValue) {
          this.setProperties({ value: date }, true);
        }
      } else if (!this.strictMode) {
        if (this.inputElement.value !== this.previousElementValue) {
          this.setProperties({ value: date }, true);
        }
      }
      if (this.strictMode && !date && this.inputElement.value === "") {
        this.setProperties({ value: null }, true);
      }
      if (isNaN(+this.value)) {
        this.setProperties({ value: null }, true);
      }
      if (isNullOrUndefined(this.value)) {
        this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      }
    };
    DatePicker2.prototype.createCalendar = function() {
      var _this = this;
      this.popupWrapper = this.createElement("div", { className: "" + ROOT2 + " " + POPUPWRAPPER });
      if (!isNullOrUndefined(this.cssClass)) {
        this.popupWrapper.className += " " + this.cssClass;
      }
      if (Browser.isDevice) {
        this.modelHeader();
        this.modal = this.createElement("div");
        this.modal.className = "" + ROOT2 + " e-date-modal";
        document.body.className += " " + OVERFLOW;
        this.modal.style.display = "block";
        document.body.appendChild(this.modal);
      }
      this.calendarElement.querySelector("table tbody").className = "";
      this.popupObj = new Popup(this.popupWrapper, {
        content: this.calendarElement,
        relateTo: Browser.isDevice ? document.body : this.inputWrapper.container,
        position: Browser.isDevice ? { X: "center", Y: "center" } : { X: "left", Y: "bottom" },
        offsetY: OFFSETVALUE,
        targetType: "container",
        enableRtl: this.enableRtl,
        zIndex: this.zIndex,
        collision: Browser.isDevice ? { X: "fit", Y: "fit" } : { X: "flip", Y: "flip" },
        open: function() {
          if (_this.getModuleName() !== "datetimepicker") {
            if (document.activeElement !== _this.inputElement) {
              _this.defaultKeyConfigs = extend(_this.defaultKeyConfigs, _this.keyConfigs);
              _this.calendarElement.children[1].firstElementChild.focus();
              _this.calendarKeyboardModules = new KeyboardEvents(_this.calendarElement.children[1].firstElementChild, {
                eventName: "keydown",
                keyAction: _this.calendarKeyActionHandle.bind(_this),
                keyConfigs: _this.defaultKeyConfigs
              });
              _this.calendarKeyboardModules = new KeyboardEvents(_this.inputWrapper.container.children[_this.index], {
                eventName: "keydown",
                keyAction: _this.calendarKeyActionHandle.bind(_this),
                keyConfigs: _this.defaultKeyConfigs
              });
            }
          }
        },
        close: function() {
          if (_this.isDateIconClicked) {
            _this.inputWrapper.container.children[_this.index].focus();
          }
          if (_this.value) {
            _this.disabledDates();
          }
          if (_this.popupObj) {
            _this.popupObj.destroy();
          }
          _this.resetCalendar();
          detach(_this.popupWrapper);
          _this.popupObj = _this.popupWrapper = null;
          _this.preventArgs = null;
          _this.calendarKeyboardModules = null;
          _this.setAriaAttributes();
        },
        targetExitViewport: function() {
          if (!Browser.isDevice) {
            _this.hide();
          }
        }
      });
      this.popupObj.element.className += " " + this.cssClass;
      this.setAriaAttributes();
    };
    DatePicker2.prototype.setAriaDisabled = function() {
      if (!this.enabled) {
        this.inputElement.setAttribute("aria-disabled", "true");
        this.inputElement.tabIndex = -1;
      } else {
        this.inputElement.setAttribute("aria-disabled", "false");
        this.inputElement.setAttribute("tabindex", this.tabIndex);
      }
    };
    DatePicker2.prototype.modelHeader = function() {
      var dateOptions;
      var modelHeader = this.createElement("div", { className: "e-model-header" });
      var yearHeading = this.createElement("h1", { className: "e-model-year" });
      var h2 = this.createElement("div");
      var daySpan = this.createElement("span", { className: "e-model-day" });
      var monthSpan = this.createElement("span", { className: "e-model-month" });
      if (this.calendarMode === "Gregorian") {
        dateOptions = { format: "y", skeleton: "dateTime" };
      } else {
        dateOptions = { format: "y", skeleton: "dateTime", calendar: "islamic" };
      }
      yearHeading.textContent = "" + this.globalize.formatDate(this.value || /* @__PURE__ */ new Date(), dateOptions);
      if (this.calendarMode === "Gregorian") {
        dateOptions = { format: "E", skeleton: "dateTime" };
      } else {
        dateOptions = { format: "E", skeleton: "dateTime", calendar: "islamic" };
      }
      daySpan.textContent = "" + this.globalize.formatDate(this.value || /* @__PURE__ */ new Date(), dateOptions) + ", ";
      if (this.calendarMode === "Gregorian") {
        dateOptions = { format: "MMM d", skeleton: "dateTime" };
      } else {
        dateOptions = { format: "MMM d", skeleton: "dateTime", calendar: "islamic" };
      }
      monthSpan.textContent = "" + this.globalize.formatDate(this.value || /* @__PURE__ */ new Date(), dateOptions);
      modelHeader.appendChild(yearHeading);
      h2.appendChild(daySpan);
      h2.appendChild(monthSpan);
      modelHeader.appendChild(h2);
      this.calendarElement.insertBefore(modelHeader, this.calendarElement.firstElementChild);
    };
    DatePicker2.prototype.changeTrigger = function(event) {
      if (this.inputElement.value !== this.previousElementValue) {
        if ((this.previousDate && this.previousDate.valueOf()) !== (this.value && this.value.valueOf())) {
          if (this.isDynamicValueChanged && this.isCalendar()) {
            this.popupUpdate();
          }
          this.changedArgs.value = this.value;
          this.changedArgs.event = event || null;
          this.changedArgs.element = this.element;
          this.changedArgs.isInteracted = !isNullOrUndefined(event);
          if (this.isAngular && this.preventChange) {
            this.preventChange = false;
          } else {
            this.trigger("change", this.changedArgs);
          }
          this.previousElementValue = this.inputElement.value;
          this.previousDate = !isNaN(+new Date(this.checkValue(this.value))) ? new Date(this.checkValue(this.value)) : null;
          this.isInteracted = true;
        }
      }
    };
    DatePicker2.prototype.navigatedEvent = function() {
      this.trigger("navigated", this.navigatedArgs);
    };
    DatePicker2.prototype.changeEvent = function(event) {
      if ((this.previousDate && this.previousDate.valueOf()) !== (this.value && this.value.valueOf())) {
        this.selectCalendar(event);
        this.changedArgs.event = event ? event : null;
        this.changedArgs.element = this.element;
        this.changedArgs.isInteracted = this.isInteracted;
        if (!this.isDynamicValueChanged) {
          this.trigger("change", this.changedArgs);
        }
        this.previousDate = this.value && /* @__PURE__ */ new Date(+this.value);
        if (!this.isDynamicValueChanged) {
          this.hide(event);
        }
        this.previousElementValue = this.inputElement.value;
        this.errorClass();
      }
    };
    DatePicker2.prototype.requiredModules = function() {
      var modules = [];
      if (this) {
        modules.push({ args: [this], member: "islamic" });
      }
      if (this.enableMask) {
        modules.push({ args: [this], member: "MaskedDateTime" });
      }
      return modules;
    };
    DatePicker2.prototype.selectCalendar = function(e) {
      var date;
      var tempFormat;
      var formatOptions;
      if (this.getModuleName() === "datetimepicker") {
        tempFormat = !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat;
      } else {
        tempFormat = this.formatString;
      }
      if (this.value) {
        if (this.getModuleName() === "datetimepicker") {
          if (this.calendarMode === "Gregorian") {
            formatOptions = { format: tempFormat, type: "dateTime", skeleton: "yMd" };
          } else {
            formatOptions = { format: tempFormat, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
          }
          date = this.globalize.formatDate(this.changedArgs.value, formatOptions);
        } else {
          if (this.calendarMode === "Gregorian") {
            formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd" };
          } else {
            formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
          }
          date = this.globalize.formatDate(this.changedArgs.value, formatOptions);
        }
        if (this.enableMask) {
          this.notify("createMask", {
            module: "MaskedDateTime"
          });
        }
      }
      if (!isNullOrUndefined(date)) {
        this.updateInputValue(date);
        if (this.enableMask) {
          this.notify("setMaskSelection", {
            module: "MaskedDateTime"
          });
        }
      }
    };
    DatePicker2.prototype.isCalendar = function() {
      if (this.popupWrapper && this.popupWrapper.classList.contains("" + POPUPWRAPPER)) {
        return true;
      }
      return false;
    };
    DatePicker2.prototype.setWidth = function(width) {
      if (typeof width === "number") {
        this.inputWrapper.container.style.width = formatUnit(this.width);
      } else if (typeof width === "string") {
        this.inputWrapper.container.style.width = width.match(/px|%|em/) ? this.width : formatUnit(this.width);
      } else {
        this.inputWrapper.container.style.width = "100%";
      }
    };
    DatePicker2.prototype.show = function(type, e) {
      var _this = this;
      if (this.enabled && this.readonly || !this.enabled || this.popupObj) {
        return;
      } else {
        var prevent_1 = true;
        var outOfRange = void 0;
        if (!isNullOrUndefined(this.value) && !(+this.value >= +this.min && +this.value <= +this.max)) {
          outOfRange = new Date(this.checkValue(this.value));
          this.setProperties({ "value": null }, true);
        } else {
          outOfRange = this.value || null;
        }
        if (!this.isCalendar()) {
          _super.prototype.render.call(this);
          this.setProperties({ "value": outOfRange || null }, true);
          this.previousDate = outOfRange;
          this.createCalendar();
        }
        if (Browser.isDevice) {
          this.mobilePopupWrapper = this.createElement("div", { className: "e-datepick-mob-popup-wrap" });
          document.body.appendChild(this.mobilePopupWrapper);
        }
        this.preventArgs = {
          preventDefault: function() {
            prevent_1 = false;
          },
          popup: this.popupObj,
          event: e || null,
          cancel: false,
          appendTo: Browser.isDevice ? this.mobilePopupWrapper : document.body
        };
        var eventArgs = this.preventArgs;
        this.trigger("open", eventArgs, function(eventArgs2) {
          _this.preventArgs = eventArgs2;
          if (prevent_1 && !_this.preventArgs.cancel) {
            addClass(_this.inputWrapper.buttons, ACTIVE);
            _this.preventArgs.appendTo.appendChild(_this.popupWrapper);
            _this.popupObj.refreshPosition(_this.inputElement);
            var openAnimation = {
              name: "FadeIn",
              duration: Browser.isDevice ? 0 : OPENDURATION
            };
            if (_this.zIndex === 1e3) {
              _this.popupObj.show(new Animation(openAnimation), _this.element);
            } else {
              _this.popupObj.show(new Animation(openAnimation), null);
            }
            _super.prototype.setOverlayIndex.call(_this, _this.mobilePopupWrapper, _this.popupObj.element, _this.modal, Browser.isDevice);
            _this.setAriaAttributes();
          } else {
            _this.popupObj.destroy();
            _this.popupWrapper = _this.popupObj = null;
          }
          if (!isNullOrUndefined(_this.inputElement) && _this.inputElement.value === "") {
            if (!isNullOrUndefined(_this.tableBodyElement) && _this.tableBodyElement.querySelectorAll("td.e-selected").length > 0) {
              addClass([_this.tableBodyElement.querySelector("td.e-selected")], FOCUSEDDATE2);
              removeClass(_this.tableBodyElement.querySelectorAll("td.e-selected"), SELECTED2);
            }
          }
          EventHandler.add(document, "mousedown touchstart", _this.documentHandler, _this);
        });
      }
    };
    DatePicker2.prototype.hide = function(event) {
      var _this = this;
      if (!isNullOrUndefined(this.popupWrapper)) {
        var prevent_2 = true;
        this.preventArgs = {
          preventDefault: function() {
            prevent_2 = false;
          },
          popup: this.popupObj,
          event: event || null,
          cancel: false
        };
        removeClass(this.inputWrapper.buttons, ACTIVE);
        removeClass([document.body], OVERFLOW);
        var eventArgs = this.preventArgs;
        if (this.isCalendar()) {
          this.trigger("close", eventArgs, function(eventArgs2) {
            _this.closeEventCallback(prevent_2, eventArgs2);
          });
        } else {
          this.closeEventCallback(prevent_2, eventArgs);
        }
      } else {
        if (Browser.isDevice && this.allowEdit && !this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
        this.setAllowEdit();
      }
    };
    DatePicker2.prototype.closeEventCallback = function(prevent, eventArgs) {
      this.preventArgs = eventArgs;
      if (this.isCalendar() && (prevent && !this.preventArgs.cancel)) {
        this.popupObj.hide();
        this.isAltKeyPressed = false;
        this.keyboardModule.destroy();
        removeClass(this.inputWrapper.buttons, ACTIVE);
      }
      this.setAriaAttributes();
      if (Browser.isDevice && this.modal) {
        this.modal.style.display = "none";
        this.modal.outerHTML = "";
        this.modal = null;
      }
      if (Browser.isDevice) {
        if (!isNullOrUndefined(this.mobilePopupWrapper)) {
          this.mobilePopupWrapper.remove();
          this.mobilePopupWrapper = null;
        }
      }
      EventHandler.remove(document, "mousedown touchstart", this.documentHandler);
      if (Browser.isDevice && this.allowEdit && !this.readonly) {
        this.inputElement.removeAttribute("readonly");
      }
      this.setAllowEdit();
    };
    DatePicker2.prototype.focusIn = function(triggerEvent) {
      if (document.activeElement !== this.inputElement && this.enabled) {
        this.inputElement.focus();
        addClass([this.inputWrapper.container], [INPUTFOCUS]);
      }
    };
    DatePicker2.prototype.focusOut = function() {
      if (document.activeElement === this.inputElement) {
        removeClass([this.inputWrapper.container], [INPUTFOCUS]);
        this.inputElement.blur();
      }
    };
    DatePicker2.prototype.currentView = function() {
      var currentView;
      if (this.calendarElement) {
        currentView = _super.prototype.currentView.call(this);
      }
      return currentView;
    };
    DatePicker2.prototype.navigateTo = function(view, date) {
      if (this.calendarElement) {
        _super.prototype.navigateTo.call(this, view, date);
      }
    };
    DatePicker2.prototype.destroy = function() {
      this.unBindEvents();
      _super.prototype.destroy.call(this);
      this.keyboardModules.destroy();
      if (this.popupObj && this.popupObj.element.classList.contains(POPUP)) {
        _super.prototype.destroy.call(this);
      }
      var ariaAttrs = {
        "aria-live": "assertive",
        "aria-atomic": "true",
        "aria-disabled": "true",
        "aria-haspopup": "true",
        "aria-activedescendant": "null",
        "aria-owns": this.element.id + "_options",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off",
        "autocorrect": "off",
        "autocapitalize": "off",
        "spellcheck": "false"
      };
      if (this.inputElement) {
        Input.removeAttributes(ariaAttrs, this.inputElement);
        if (!isNullOrUndefined(this.inputElementCopy.getAttribute("tabindex"))) {
          this.inputElement.setAttribute("tabindex", this.tabIndex);
        } else {
          this.inputElement.removeAttribute("tabindex");
        }
        EventHandler.remove(this.inputElement, "blur", this.inputBlurHandler);
        EventHandler.remove(this.inputElement, "focus", this.inputFocusHandler);
        this.ensureInputAttribute();
      }
      if (this.isCalendar()) {
        if (this.popupWrapper) {
          detach(this.popupWrapper);
        }
        this.popupObj = this.popupWrapper = null;
        this.keyboardModule.destroy();
      }
      if (this.ngTag === null) {
        if (this.inputElement) {
          this.inputWrapper.container.insertAdjacentElement("afterend", this.inputElement);
          removeClass([this.inputElement], [INPUTROOT]);
        }
        removeClass([this.element], [ROOT2]);
        detach(this.inputWrapper.container);
      }
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.resetFormHandler);
      }
    };
    DatePicker2.prototype.ensureInputAttribute = function() {
      var prop = [];
      for (var i = 0; i < this.inputElement.attributes.length; i++) {
        prop[i] = this.inputElement.attributes[i].name;
      }
      for (var i = 0; i < prop.length; i++) {
        if (isNullOrUndefined(this.inputElementCopy.getAttribute(prop[i]))) {
          if (prop[i].toLowerCase() === "value") {
            this.inputElement.value = "";
          }
          this.inputElement.removeAttribute(prop[i]);
        } else {
          if (prop[i].toLowerCase() === "value") {
            this.inputElement.value = this.inputElementCopy.getAttribute(prop[i]);
          }
          this.inputElement.setAttribute(prop[i], this.inputElementCopy.getAttribute(prop[i]));
        }
      }
    };
    DatePicker2.prototype.preRender = function() {
      this.inputElementCopy = this.element.cloneNode(true);
      removeClass([this.inputElementCopy], [ROOT2, CONTROL, LIBRARY]);
      this.inputElement = this.element;
      this.formElement = closest(this.inputElement, "form");
      this.index = this.showClearButton ? 2 : 1;
      this.ngTag = null;
      if (this.element.tagName === "EJS-DATEPICKER" || this.element.tagName === "EJS-DATETIMEPICKER") {
        this.ngTag = this.element.tagName;
        this.inputElement = this.createElement("input");
        this.element.appendChild(this.inputElement);
      }
      if (this.element.getAttribute("id")) {
        if (this.ngTag !== null) {
          this.inputElement.id = this.element.getAttribute("id") + "_input";
        }
      } else {
        if (this.getModuleName() === "datetimepicker") {
          this.element.id = getUniqueID("ej2-datetimepicker");
          if (this.ngTag !== null) {
            attributes(this.inputElement, { "id": this.element.id + "_input" });
          }
        } else {
          this.element.id = getUniqueID("ej2-datepicker");
          if (this.ngTag !== null) {
            attributes(this.inputElement, { "id": this.element.id + "_input" });
          }
        }
      }
      if (this.ngTag !== null) {
        this.validationAttribute(this.element, this.inputElement);
      }
      this.updateHtmlAttributeToElement();
      this.defaultKeyConfigs = this.getDefaultKeyConfig();
      this.checkHtmlAttributes(false);
      this.tabIndex = this.element.hasAttribute("tabindex") ? this.element.getAttribute("tabindex") : "0";
      this.element.removeAttribute("tabindex");
      _super.prototype.preRender.call(this);
    };
    DatePicker2.prototype.getDefaultKeyConfig = function() {
      this.defaultKeyConfigs = {
        altUpArrow: "alt+uparrow",
        altDownArrow: "alt+downarrow",
        escape: "escape",
        enter: "enter",
        controlUp: "ctrl+38",
        controlDown: "ctrl+40",
        moveDown: "downarrow",
        moveUp: "uparrow",
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        select: "enter",
        home: "home",
        end: "end",
        pageUp: "pageup",
        pageDown: "pagedown",
        shiftPageUp: "shift+pageup",
        shiftPageDown: "shift+pagedown",
        controlHome: "ctrl+home",
        controlEnd: "ctrl+end",
        shiftTab: "shift+tab",
        tab: "tab"
      };
      return this.defaultKeyConfigs;
    };
    DatePicker2.prototype.validationAttribute = function(target, inputElement) {
      var nameAttribute = target.getAttribute("name") ? target.getAttribute("name") : target.getAttribute("id");
      inputElement.setAttribute("name", nameAttribute);
      target.removeAttribute("name");
      var attribute = ["required", "aria-required", "form"];
      for (var i = 0; i < attribute.length; i++) {
        if (isNullOrUndefined(target.getAttribute(attribute[i]))) {
          continue;
        }
        var attr = target.getAttribute(attribute[i]);
        inputElement.setAttribute(attribute[i], attr);
        target.removeAttribute(attribute[i]);
      }
    };
    DatePicker2.prototype.checkFormat = function() {
      var culture = new Internationalization(this.locale);
      if (this.format) {
        if (typeof this.format === "string") {
          this.formatString = this.format;
        } else if (this.format.skeleton !== "" && !isNullOrUndefined(this.format.skeleton)) {
          var skeletonString = this.format.skeleton;
          if (this.getModuleName() === "datetimepicker") {
            this.formatString = culture.getDatePattern({ skeleton: skeletonString, type: "dateTime" });
          } else {
            this.formatString = culture.getDatePattern({ skeleton: skeletonString, type: "date" });
          }
        } else {
          if (this.getModuleName() === "datetimepicker") {
            this.formatString = this.dateTimeFormat;
          } else {
            this.formatString = null;
          }
        }
      } else {
        this.formatString = null;
      }
    };
    DatePicker2.prototype.checkHtmlAttributes = function(dynamic) {
      this.globalize = new Internationalization(this.locale);
      this.checkFormat();
      this.checkView();
      var attributes2 = dynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["value", "min", "max", "disabled", "readonly", "style", "name", "placeholder", "type"];
      var options;
      if (this.getModuleName() === "datetimepicker") {
        if (this.calendarMode === "Gregorian") {
          options = {
            format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,
            type: "dateTime",
            skeleton: "yMd"
          };
        } else {
          options = {
            format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,
            type: "dateTime",
            skeleton: "yMd",
            calendar: "islamic"
          };
        }
      } else {
        if (this.calendarMode === "Gregorian") {
          options = { format: this.formatString, type: "dateTime", skeleton: "yMd" };
        } else {
          options = { format: this.formatString, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
        }
      }
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {
          switch (prop) {
            case "disabled":
              if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions["enabled"] === void 0 || dynamic) {
                var enabled = this.inputElement.getAttribute(prop) === "disabled" || this.inputElement.getAttribute(prop) === "" || this.inputElement.getAttribute(prop) === "true" ? false : true;
                this.setProperties({ enabled }, !dynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions["readonly"] === void 0 || dynamic) {
                var readonly = this.inputElement.getAttribute(prop) === "readonly" || this.inputElement.getAttribute(prop) === "" || this.inputElement.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ readonly }, !dynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions["placeholder"] === void 0 || dynamic) {
                this.setProperties({ placeholder: this.inputElement.getAttribute(prop) }, !dynamic);
              }
              break;
            case "style":
              this.inputElement.setAttribute("style", "" + this.inputElement.getAttribute(prop));
              break;
            case "name":
              this.inputElement.setAttribute("name", "" + this.inputElement.getAttribute(prop));
              break;
            case "value":
              if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions["value"] === void 0 || dynamic) {
                var value = this.inputElement.getAttribute(prop);
                this.setProperties(setValue(prop, this.globalize.parseDate(value, options), {}), !dynamic);
              }
              break;
            case "min":
              if (+this.min === +new Date(1900, 0, 1) || dynamic) {
                var min = this.inputElement.getAttribute(prop);
                this.setProperties(setValue(prop, this.globalize.parseDate(min), {}), !dynamic);
              }
              break;
            case "max":
              if (+this.max === +new Date(2099, 11, 31) || dynamic) {
                var max = this.inputElement.getAttribute(prop);
                this.setProperties(setValue(prop, this.globalize.parseDate(max), {}), !dynamic);
              }
              break;
            case "type":
              if (this.inputElement.getAttribute(prop) !== "text") {
                this.inputElement.setAttribute("type", "text");
              }
              break;
          }
        }
      }
    };
    DatePicker2.prototype.getModuleName = function() {
      return "datepicker";
    };
    DatePicker2.prototype.disabledDates = function() {
      var formatOptions;
      var globalize;
      var valueCopy = this.checkDateValue(this.value) ? /* @__PURE__ */ new Date(+this.value) : new Date(this.checkValue(this.value));
      var previousValCopy = this.previousDate;
      this.minMaxUpdates();
      _super.prototype.render.call(this);
      this.previousDate = previousValCopy;
      var date = valueCopy && +valueCopy;
      var dateIdString = '*[id^="/id"]'.replace("/id", "" + date);
      if (!this.strictMode) {
        if (typeof this.value === "string" || typeof this.value === "object" && +this.value !== +valueCopy) {
          this.setProperties({ value: valueCopy }, true);
        }
      }
      if (!isNullOrUndefined(this.calendarElement.querySelectorAll(dateIdString)[0])) {
        if (this.calendarElement.querySelectorAll(dateIdString)[0].classList.contains("e-disabled")) {
          if (!this.strictMode) {
            this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          }
        }
      }
      var inputVal;
      if (this.getModuleName() === "datetimepicker") {
        if (this.calendarMode === "Gregorian") {
          globalize = this.globalize.formatDate(valueCopy, {
            format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,
            type: "dateTime",
            skeleton: "yMd"
          });
        } else {
          globalize = this.globalize.formatDate(valueCopy, {
            format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,
            type: "dateTime",
            skeleton: "yMd",
            calendar: "islamic"
          });
        }
        inputVal = globalize;
      } else {
        if (this.calendarMode === "Gregorian") {
          formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd" };
        } else {
          formatOptions = { format: this.formatString, type: "dateTime", skeleton: "yMd", calendar: "islamic" };
        }
        inputVal = this.globalize.formatDate(valueCopy, formatOptions);
      }
      if (!this.popupObj) {
        this.updateInputValue(inputVal);
        if (this.enableMask) {
          this.updateInputValue(this.maskedDateValue);
          this.notify("createMask", {
            module: "MaskedDateTime"
          });
        }
      }
    };
    DatePicker2.prototype.setAriaAttributes = function() {
      if (this.isCalendar()) {
        Input.addAttributes({ "aria-expanded": "true" }, this.inputElement);
        attributes(this.inputElement, { "aria-activedescendant": "" + this.setActiveDescendant() });
      } else {
        Input.addAttributes({ "aria-expanded": "false" }, this.inputElement);
        attributes(this.inputElement, { "aria-activedescendant": "null" });
      }
    };
    DatePicker2.prototype.errorClass = function() {
      var dateIdString = '*[id^="/id"]'.replace("/id", "" + +this.value);
      var isDisabledDate = this.calendarElement && this.calendarElement.querySelectorAll(dateIdString)[0] && this.calendarElement.querySelectorAll(dateIdString)[0].classList.contains("e-disabled");
      if (!isNullOrUndefined(this.value) && !(+(/* @__PURE__ */ new Date(+this.value)).setMilliseconds(0) >= +this.min && +(/* @__PURE__ */ new Date(+this.value)).setMilliseconds(0) <= +this.max) || (!this.strictMode && this.inputElement.value !== "" && this.inputElement.value !== this.maskedDateValue && isNullOrUndefined(this.value) || isDisabledDate)) {
        addClass([this.inputWrapper.container], ERROR);
        attributes(this.inputElement, { "aria-invalid": "true" });
      } else {
        removeClass([this.inputWrapper.container], ERROR);
        attributes(this.inputElement, { "aria-invalid": "false" });
      }
    };
    DatePicker2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "value":
            this.isDynamicValueChanged = true;
            this.isInteracted = false;
            this.invalidValueString = null;
            this.checkInvalidValue(newProp.value);
            newProp.value = this.value;
            this.previousElementValue = this.inputElement.value;
            if (isNullOrUndefined(this.value)) {
              this.updateInputValue("");
              this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
            }
            this.updateInput(true);
            if (+this.previousDate !== +this.value) {
              this.changeTrigger(null);
            }
            this.isInteracted = true;
            this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
            }
            break;
          case "format":
            this.checkFormat();
            this.bindInputEvent();
            this.updateInput();
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
              if (!this.value) {
                this.updateInputValue(this.maskedDateValue);
              }
            }
            break;
          case "allowEdit":
            this.setAllowEdit();
            break;
          case "placeholder":
            Input.setPlaceholder(this.placeholder, this.inputElement);
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.inputElement);
            break;
          case "enabled":
            Input.setEnabled(this.enabled, this.inputElement);
            this.setAriaDisabled();
            break;
          case "htmlAttributes":
            this.updateHtmlAttributeToElement();
            this.updateHtmlAttributeToWrapper();
            this.checkHtmlAttributes(true);
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
            Input.setPlaceholder(this.placeholder, this.inputElement);
            this.updateInput();
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
            }
            break;
          case "enableRtl":
            Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);
            break;
          case "start":
          case "depth":
            this.checkView();
            if (this.calendarElement) {
              _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
            }
            break;
          case "zIndex":
            this.setProperties({ zIndex: newProp.zIndex }, true);
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "showClearButton":
            Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);
            this.bindClearEvent();
            this.index = this.showClearButton ? 2 : 1;
            break;
          case "strictMode":
            this.invalidValueString = null;
            this.updateInput();
            break;
          case "width":
            this.setWidth(newProp.width);
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            Input.removeFloating(this.inputWrapper);
            Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);
            break;
          case "enableMask":
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
              this.updateInputValue(this.maskedDateValue);
              this.bindInputEvent();
            } else {
              if (this.inputElement.value === this.maskedDateValue) {
                this.updateInputValue("");
              }
            }
            break;
          default:
            if (this.calendarElement && this.isCalendar()) {
              _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
            }
            break;
        }
        if (!this.isDynamicValueChanged) {
          this.hide(null);
        }
        this.isDynamicValueChanged = false;
      }
    };
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "width", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "value", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "cssClass", void 0);
    __decorate2([
      Property(false)
    ], DatePicker2.prototype, "strictMode", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "format", void 0);
    __decorate2([
      Property(true)
    ], DatePicker2.prototype, "enabled", void 0);
    __decorate2([
      Property({})
    ], DatePicker2.prototype, "htmlAttributes", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "values", void 0);
    __decorate2([
      Property(false)
    ], DatePicker2.prototype, "isMultiSelection", void 0);
    __decorate2([
      Property(true)
    ], DatePicker2.prototype, "showClearButton", void 0);
    __decorate2([
      Property(true)
    ], DatePicker2.prototype, "allowEdit", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "keyConfigs", void 0);
    __decorate2([
      Property(false)
    ], DatePicker2.prototype, "enablePersistence", void 0);
    __decorate2([
      Property(1e3)
    ], DatePicker2.prototype, "zIndex", void 0);
    __decorate2([
      Property(false)
    ], DatePicker2.prototype, "readonly", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "placeholder", void 0);
    __decorate2([
      Property("Never")
    ], DatePicker2.prototype, "floatLabelType", void 0);
    __decorate2([
      Property(null)
    ], DatePicker2.prototype, "serverTimezoneOffset", void 0);
    __decorate2([
      Property(false)
    ], DatePicker2.prototype, "openOnFocus", void 0);
    __decorate2([
      Property(false)
    ], DatePicker2.prototype, "enableMask", void 0);
    __decorate2([
      Property({ day: "day", month: "month", year: "year", hour: "hour", minute: "minute", second: "second", dayOfTheWeek: "day of the week" })
    ], DatePicker2.prototype, "maskPlaceholder", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "open", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "cleared", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "close", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "blur", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "focus", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "created", void 0);
    __decorate2([
      Event()
    ], DatePicker2.prototype, "destroyed", void 0);
    DatePicker2 = __decorate2([
      NotifyPropertyChanges
    ], DatePicker2);
    return DatePicker2;
  }(Calendar)
);

// node_modules/@syncfusion/ej2-calendars/src/daterangepicker/daterangepicker.js
var __extends46 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DATERANGEWRAPPER = "e-date-range-wrapper";
var INPUTCONTAINER2 = "e-input-group";
var DATERANGEICON = "e-input-group-icon e-range-icon e-icons";
var POPUP2 = "e-popup";
var LEFTCALENDER = "e-left-calendar";
var RIGHTCALENDER = "e-right-calendar";
var LEFTCONTAINER = "e-left-container";
var RIGHTCONTAINER = "e-right-container";
var ROOT3 = "e-daterangepicker";
var LIBRARY2 = "e-lib";
var CONTROL2 = "e-control";
var ERROR2 = "e-error";
var ACTIVE2 = "e-active";
var STARTENDCONTAINER = "e-start-end";
var STARTDATE = "e-start-date";
var ENDDATE = "e-end-date";
var STARTBUTTON = "e-start-btn";
var INPUTFOCUS2 = "e-input-focus";
var ENDBUTTON = "e-end-btn";
var RANGEHOVER = "e-range-hover";
var OTHERMONTH2 = "e-other-month";
var STARTLABEL = "e-start-label";
var ENDLABEL = "e-end-label";
var DISABLED2 = "e-disabled";
var SELECTED3 = "e-selected";
var CALENDAR = "e-calendar";
var NEXTICON2 = "e-next";
var PREVICON2 = "e-prev";
var HEADER2 = "e-header";
var TITLE2 = "e-title";
var ICONCONTAINER2 = "e-icon-container";
var RANGECONTAINER = "e-date-range-container";
var RANGEHEADER = "e-range-header";
var PRESETS = "e-presets";
var FOOTER2 = "e-footer";
var RANGEBORDER = "e-range-border";
var TODAY2 = "e-today";
var FOCUSDATE = "e-focused-date";
var CONTENT2 = "e-content";
var DAYSPAN = "e-day-span";
var WEEKNUMBER2 = "e-week-number";
var DATEDISABLED = "e-date-disabled";
var ICONDISABLED = "e-icon-disabled";
var CALENDARCONTAINER = "e-calendar-container";
var SEPARATOR = "e-separator";
var APPLY = "e-apply";
var CANCEL = "e-cancel";
var DEVICE2 = "e-device";
var OVERLAY2 = "e-overlay";
var CHANGEICON = "e-change-icon e-icons";
var LISTCLASS = "e-list-item";
var RTL2 = "e-rtl";
var HOVER = "e-hover";
var OVERFLOW2 = "e-range-overflow";
var OFFSETVALUE2 = 4;
var PRIMARY2 = "e-primary";
var FLAT2 = "e-flat";
var CSS2 = "e-css";
var ZOOMIN2 = "e-zoomin";
var NONEDITABLE = "e-non-edit";
var DAYHEADERLONG2 = "e-daterange-day-header-lg";
var HIDDENELEMENT = "e-daterange-hidden";
var wrapperAttr = ["title", "class", "style"];
var Presets = (
  /** @class */
  function(_super) {
    __extends46(Presets2, _super);
    function Presets2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([
      Property()
    ], Presets2.prototype, "label", void 0);
    __decorate3([
      Property()
    ], Presets2.prototype, "start", void 0);
    __decorate3([
      Property()
    ], Presets2.prototype, "end", void 0);
    return Presets2;
  }(ChildProperty)
);
var DateRangePicker = (
  /** @class */
  function(_super) {
    __extends46(DateRangePicker2, _super);
    function DateRangePicker2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.isCustomRange = false;
      _this.isCustomWindow = false;
      _this.presetsItem = [];
      _this.liCollections = [];
      _this.previousEleValue = "";
      _this.isKeyPopup = false;
      _this.dateDisabled = false;
      _this.isRangeIconClicked = false;
      _this.isMaxDaysClicked = false;
      _this.disabledDays = [];
      _this.preventBlur = false;
      _this.preventFocus = false;
      _this.invalidValueString = null;
      _this.isAngular = false;
      _this.preventChange = false;
      _this.dateRangeOptions = options;
      return _this;
    }
    DateRangePicker2.prototype.render = function() {
      this.initialize();
      this.setProperties({ startDate: this.startValue }, true);
      this.setProperties({ endDate: this.endValue }, true);
      this.setModelValue();
      this.setDataAttribute(false);
      if (this.element.hasAttribute("data-val")) {
        this.element.setAttribute("data-val", "false");
      }
      this.renderComplete();
    };
    DateRangePicker2.prototype.preRender = function() {
      this.keyInputConfigs = {
        altDownArrow: "alt+downarrow",
        escape: "escape",
        enter: "enter",
        tab: "tab",
        altRightArrow: "alt+rightarrow",
        altLeftArrow: "alt+leftarrow",
        moveUp: "uparrow",
        moveDown: "downarrow",
        spacebar: "space"
      };
      this.defaultConstant = {
        placeholder: this.placeholder,
        startLabel: "Start Date",
        endLabel: "End Date",
        customRange: "Custom Range",
        applyText: "Apply",
        cancelText: "Cancel",
        selectedDays: "Selected Days",
        days: "days"
      };
      this.isMobile = window.matchMedia("(max-width:550px)").matches;
      this.inputElement = this.element;
      this.angularTag = null;
      if (this.element.tagName === "EJS-DATERANGEPICKER") {
        this.angularTag = this.element.tagName;
        this.inputElement = this.createElement("input");
        this.element.appendChild(this.inputElement);
      }
      this.cloneElement = this.element.cloneNode(true);
      removeClass([this.cloneElement], [ROOT3, CONTROL2, LIBRARY2]);
      this.updateHtmlAttributeToElement();
      if (this.element.getAttribute("id")) {
        if (this.angularTag !== null) {
          this.inputElement.id = this.element.getAttribute("id") + "_input";
        }
      } else {
        this.element.id = getUniqueID("ej2-datetimepicker");
        if (this.angularTag !== null) {
          attributes(this.inputElement, { "id": this.element.id + "_input" });
        }
      }
      this.checkInvalidRange(this.value);
      if (!this.invalidValueString && typeof this.value === "string") {
        var rangeArray = this.value.split(" " + this.separator + " ");
        this.value = [new Date(rangeArray[0]), new Date(rangeArray[1])];
      }
      this.initProperty();
      this.tabIndex = this.element.hasAttribute("tabindex") ? this.element.getAttribute("tabindex") : "0";
      this.element.removeAttribute("tabindex");
      _super.prototype.preRender.call(this);
      this.navNextFunction = this.navNextMonth.bind(this);
      this.navPrevFunction = this.navPrevMonth.bind(this);
      this.deviceNavNextFunction = this.deviceNavNext.bind(this);
      this.deviceNavPrevFunction = this.deviceNavPrevious.bind(this);
      this.initStartDate = this.checkDateValue(this.startValue);
      this.initEndDate = this.checkDateValue(this.endValue);
      this.formElement = closest(this.element, "form");
    };
    DateRangePicker2.prototype.updateValue = function() {
      if (this.value && this.value.length > 0) {
        if (this.value[0] instanceof Date && !isNaN(+this.value[0])) {
          this.setProperties({ startDate: this.value[0] }, true);
          this.startValue = this.value[0];
        } else if (typeof this.value[0] === "string") {
          if (+this.value[0] === 0 || isNaN(+new Date(this.checkValue(this.value[0])))) {
            this.startValue = null;
            this.setValue();
          } else {
            this.setProperties({ startDate: new Date(this.checkValue(this.value[0])) }, true);
            this.startValue = new Date(this.checkValue(this.value[0]));
          }
        } else {
          this.startValue = null;
          this.setValue();
        }
        if (this.value[1] instanceof Date && !isNaN(+this.value[1])) {
          this.setProperties({ endDate: this.value[1] }, true);
          this.endValue = this.value[1];
        } else if (typeof this.value[1] === "string") {
          if (+this.value[0] === 0 || isNaN(+new Date(this.checkValue(this.value[0])))) {
            this.setProperties({ endDate: null }, true);
            this.endValue = null;
            this.setValue();
          } else {
            this.setProperties({ endDate: new Date(this.checkValue(this.value[1])) }, true);
            this.endValue = new Date(this.checkValue(this.value[1]));
            this.setValue();
          }
        } else {
          this.setProperties({ endDate: null }, true);
          this.endValue = null;
          this.setValue();
        }
      } else if (this.value && this.value.start) {
        if (this.value.start instanceof Date && !isNaN(+this.value.start)) {
          this.setProperties({ startDate: this.value.start }, true);
          this.startValue = this.value.start;
        } else if (typeof this.value.start === "string") {
          this.setProperties({ startDate: new Date(this.checkValue(this.value.start)) }, true);
          this.startValue = new Date(this.checkValue(this.value.start));
        } else {
          this.startValue = null;
          this.setValue();
        }
        if (this.value.end instanceof Date && !isNaN(+this.value.end)) {
          this.setProperties({ endDate: this.value.end }, true);
          this.endValue = this.value.end;
        } else if (typeof this.value.end === "string") {
          this.setProperties({ endDate: new Date(this.checkValue(this.value.end)) }, true);
          this.endValue = new Date(this.checkValue(this.value.end));
          this.setValue();
        } else {
          this.setProperties({ endDate: null }, true);
          this.endValue = null;
          this.setValue();
        }
      } else if (isNullOrUndefined(this.value)) {
        this.endValue = this.checkDateValue(new Date(this.checkValue(this.endDate)));
        this.startValue = this.checkDateValue(new Date(this.checkValue(this.startDate)));
        this.setValue();
      }
    };
    DateRangePicker2.prototype.initProperty = function() {
      this.globalize = new Internationalization(this.locale);
      this.checkFormat();
      this.checkView();
      if (isNullOrUndefined(this.firstDayOfWeek) || this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {
        this.setProperties({ firstDayOfWeek: this.globalize.getFirstDayOfWeek() }, true);
      }
      this.updateValue();
    };
    DateRangePicker2.prototype.checkFormat = function() {
      if (this.format) {
        if (typeof this.format === "string") {
          this.formatString = this.format;
        } else if (this.format.skeleton !== "" && !isNullOrUndefined(this.format.skeleton)) {
          var skeletonString = this.format.skeleton;
          this.formatString = this.globalize.getDatePattern({ skeleton: skeletonString, type: "date" });
        } else {
          this.formatString = null;
        }
      } else {
        this.formatString = null;
      }
    };
    DateRangePicker2.prototype.initialize = function() {
      if (this.angularTag !== null) {
        this.validationAttribute(this.element, this.inputElement);
      }
      this.checkHtmlAttributes(false);
      merge(this.defaultKeyConfigs, { shiftTab: "shift+tab" });
      var start = this.checkDateValue(new Date(this.checkValue(this.startValue)));
      this.setProperties({ startDate: start }, true);
      this.setProperties({ endValue: this.checkDateValue(new Date(this.checkValue(this.endValue))) }, true);
      this.setValue();
      this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(this.min))) }, true);
      this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(this.max))) }, true);
      this.l10n = new L10n("daterangepicker", this.defaultConstant, this.locale);
      this.l10n.setLocale(this.locale);
      this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      this.processPresets();
      this.createInput();
      this.updateHtmlAttributeToWrapper();
      this.setRangeAllowEdit();
      this.bindEvents();
    };
    DateRangePicker2.prototype.setDataAttribute = function(isDynamic) {
      var attributes2 = {};
      if (!isDynamic) {
        for (var i = 0; i < this.element.attributes.length; i++) {
          attributes2[this.element.attributes[i].name] = this.element.getAttribute(this.element.attributes[i].name);
        }
      } else {
        attributes2 = this.htmlAttributes;
      }
      for (var _i = 0, _a = Object.keys(attributes2); _i < _a.length; _i++) {
        var pro = _a[_i];
        if (pro.indexOf("data") === 0) {
          this.firstHiddenChild.setAttribute(pro, attributes2[pro]);
          this.secondHiddenChild.setAttribute(pro, attributes2[pro]);
        }
      }
    };
    DateRangePicker2.prototype.setRangeAllowEdit = function() {
      if (this.allowEdit) {
        if (!this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
      } else {
        attributes(this.inputElement, { "readonly": "" });
      }
      this.updateClearIconState();
    };
    DateRangePicker2.prototype.updateClearIconState = function() {
      if (!this.allowEdit && this.inputWrapper && !this.readonly) {
        if (this.inputElement.value === "") {
          removeClass([this.inputWrapper.container], [NONEDITABLE]);
        } else {
          addClass([this.inputWrapper.container], [NONEDITABLE]);
        }
      } else if (this.inputWrapper) {
        removeClass([this.inputWrapper.container], [NONEDITABLE]);
      }
    };
    DateRangePicker2.prototype.validationAttribute = function(element, input) {
      var name = element.getAttribute("name") ? element.getAttribute("name") : element.getAttribute("id");
      input.setAttribute("name", name);
      element.removeAttribute("name");
      var attributes2 = ["required", "aria-required", "form"];
      for (var i = 0; i < attributes2.length; i++) {
        if (isNullOrUndefined(element.getAttribute(attributes2[i]))) {
          continue;
        }
        var attr = element.getAttribute(attributes2[i]);
        input.setAttribute(attributes2[i], attr);
        element.removeAttribute(attributes2[i]);
      }
    };
    DateRangePicker2.prototype.updateHtmlAttributeToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (wrapperAttr.indexOf(key) > -1) {
            if (key === "class") {
              var updatedClassValue = this.htmlAttributes[key].replace(/\s+/g, " ").trim();
              if (updatedClassValue !== "") {
                addClass([this.inputWrapper.container], updatedClassValue.split(" "));
              }
            } else if (key === "style") {
              var dateRangeStyle = this.inputWrapper.container.getAttribute(key);
              dateRangeStyle = !isNullOrUndefined(dateRangeStyle) ? dateRangeStyle + this.htmlAttributes[key] : this.htmlAttributes[key];
              this.inputWrapper.container.setAttribute(key, dateRangeStyle);
            } else {
              this.inputWrapper.container.setAttribute(key, this.htmlAttributes[key]);
            }
          }
        }
      }
    };
    DateRangePicker2.prototype.updateHtmlAttributeToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (wrapperAttr.indexOf(key) < 0) {
            this.inputElement.setAttribute(key, this.htmlAttributes[key]);
          }
        }
      }
    };
    DateRangePicker2.prototype.updateCssClass = function(cssNewClass, cssOldClass) {
      if (!isNullOrUndefined(cssOldClass)) {
        cssOldClass = cssOldClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(cssNewClass)) {
        cssNewClass = cssNewClass.replace(/\s+/g, " ").trim();
      }
      Input.setCssClass(cssNewClass, [this.inputWrapper.container], cssOldClass);
      if (this.popupWrapper) {
        Input.setCssClass(cssNewClass, [this.popupWrapper], cssOldClass);
      }
    };
    DateRangePicker2.prototype.processPresets = function() {
      this.presetsItem = [];
      var i = 0;
      if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {
        for (var _i = 0, _a = this.presets; _i < _a.length; _i++) {
          var range = _a[_i];
          var id = range.label.replace(/\s+/g, "") + "_" + ++i;
          if (typeof range.end === "string") {
            this.presetsItem.push({
              id,
              text: range.label,
              end: new Date(this.checkValue(range.end)),
              start: new Date(this.checkValue(range.start))
            });
          } else {
            this.presetsItem.push({ id, text: range.label, start: range.start, end: range.end });
          }
        }
        var startDate = isNullOrUndefined(this.startValue) ? null : /* @__PURE__ */ new Date(+this.startValue);
        var endDate = isNullOrUndefined(this.endValue) ? null : /* @__PURE__ */ new Date(+this.endValue);
        this.presetsItem.push({ id: "custom_range", text: this.l10n.getConstant("customRange"), start: startDate, end: endDate });
        if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
          this.isCustomRange = true;
          this.activeIndex = this.presetsItem.length - 1;
        }
      }
    };
    DateRangePicker2.prototype.bindEvents = function() {
      EventHandler.add(this.inputWrapper.buttons[0], "mousedown", this.rangeIconHandler, this);
      EventHandler.add(this.inputElement, "focus", this.inputFocusHandler, this);
      EventHandler.add(this.inputElement, "blur", this.inputBlurHandler, this);
      EventHandler.add(this.inputElement, "change", this.inputChangeHandler, this);
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown", this.resetHandler, this);
      }
      if (!this.isMobile) {
        this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);
        this.inputKeyboardModule = new KeyboardEvents(this.inputElement, {
          eventName: "keydown",
          keyAction: this.inputHandler.bind(this),
          keyConfigs: this.keyInputConfigs
        });
      }
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
      }
      if (this.enabled) {
        this.inputElement.setAttribute("tabindex", this.tabIndex);
      } else {
        this.inputElement.tabIndex = -1;
      }
    };
    DateRangePicker2.prototype.unBindEvents = function() {
      EventHandler.remove(this.inputWrapper.buttons[0], "mousedown", this.rangeIconHandler);
      EventHandler.remove(this.inputElement, "blur", this.inputBlurHandler);
      EventHandler.remove(this.inputElement, "focus", this.inputFocusHandler);
      EventHandler.remove(this.inputElement, "change", this.inputChangeHandler);
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.remove(this.inputWrapper.clearButton, "mousedown touchstart", this.resetHandler);
      }
      if (!this.isMobile) {
        if (!isNullOrUndefined(this.inputKeyboardModule)) {
          this.inputKeyboardModule.destroy();
        }
      }
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
      this.inputElement.tabIndex = -1;
    };
    DateRangePicker2.prototype.updateHiddenInput = function() {
      if (this.firstHiddenChild && this.secondHiddenChild) {
        var format = { type: "datetime", skeleton: "yMd" };
        if (typeof this.startDate === "string") {
          this.startDate = this.globalize.parseDate(this.startDate, format);
        }
        if (typeof this.endDate === "string") {
          this.endDate = this.globalize.parseDate(this.endDate, format);
        }
        this.firstHiddenChild.value = this.startDate && this.globalize.formatDate(this.startDate, format) || this.inputElement.value;
        this.secondHiddenChild.value = this.endDate && this.globalize.formatDate(this.endDate, format) || this.inputElement.value;
        this.dispatchEvent(this.firstHiddenChild, "focusout");
        this.dispatchEvent(this.firstHiddenChild, "change");
      }
    };
    DateRangePicker2.prototype.inputChangeHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      e.stopPropagation();
      this.updateHiddenInput();
    };
    DateRangePicker2.prototype.bindClearEvent = function() {
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown", this.resetHandler, this);
      }
    };
    DateRangePicker2.prototype.resetHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      this.valueType = this.value;
      e.preventDefault();
      this.clear();
      var clearedArgs = {
        event: e
      };
      this.setProperties({ endDate: this.checkDateValue(this.endValue) }, true);
      this.setProperties({ startDate: this.checkDateValue(this.startValue) }, true);
      this.trigger("cleared", clearedArgs);
      this.changeTrigger(e);
      this.clearRange();
      this.hide(e);
    };
    DateRangePicker2.prototype.restoreValue = function() {
      this.previousEleValue = this.inputElement.value;
      this.previousStartValue = this.startValue;
      this.previousEndValue = this.endValue;
      this.valueType = null;
      this.initStartDate = this.checkDateValue(this.startValue);
      this.initEndDate = this.checkDateValue(this.endValue);
      this.setValue();
      this.setModelValue();
    };
    DateRangePicker2.prototype.formResetHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (this.formElement && e.target === this.formElement && !this.inputElement.disabled) {
        var val = this.inputElement.getAttribute("value");
        if (!isNullOrUndefined(this.startCopy)) {
          if (!isNullOrUndefined(this.value) && !isNullOrUndefined(this.value.start)) {
            this.setProperties({ value: { start: this.startCopy, end: this.endCopy } }, true);
            this.startValue = this.value.start;
            this.endValue = this.value.end;
          } else {
            this.setProperties({ value: [this.startCopy, this.endCopy] }, true);
            this.startValue = this.value[0];
            this.endValue = this.value[1];
          }
          this.setProperties({ startDate: this.startValue, endDate: this.endValue }, true);
        } else {
          this.setProperties({ value: null, startDate: null, endDate: null }, true);
          this.startValue = this.endValue = null;
        }
        if (this.element.tagName === "EJS-DATERANGEPICKER") {
          this.setProperties({ value: null, startDate: null, endDate: null }, true);
          val = "";
          this.startValue = this.endValue = null;
          this.inputElement.setAttribute("value", "");
        }
        this.restoreValue();
        if (this.inputElement) {
          Input.setValue(val, this.inputElement, this.floatLabelType, this.showClearButton);
          this.errorClass();
        }
      }
    };
    DateRangePicker2.prototype.clear = function() {
      if (this.startValue !== null) {
        this.startValue = null;
      }
      if (this.endValue !== null) {
        this.endValue = null;
      }
      if (this.value && this.value.start) {
        this.setProperties({ value: { start: null, end: null } }, true);
      }
      if (this.value !== null && this.value.length > 0) {
        this.setProperties({ value: null }, true);
      }
      Input.setValue("", this.inputElement, this.floatLabelType, this.showClearButton);
      if (!isNullOrUndefined(this.applyButton)) {
        this.applyButton.disabled = this.applyButton.element.disabled = true;
      }
      this.removeSelection();
    };
    DateRangePicker2.prototype.rangeIconHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (this.isMobile) {
        this.inputElement.setAttribute("readonly", "");
      }
      e.preventDefault();
      this.targetElement = null;
      if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {
        this.applyFunction(e);
      } else {
        this.isRangeIconClicked = true;
        this.inputWrapper.container.children[0].focus();
        this.show(null, e);
        if (!this.isMobile) {
          if (!isNullOrUndefined(this.leftCalendar)) {
            this.isRangeIconClicked = false;
            this.calendarFocus();
            this.isRangeIconClicked = true;
          }
        }
        addClass([this.inputWrapper.container], [INPUTFOCUS2]);
      }
    };
    DateRangePicker2.prototype.checkHtmlAttributes = function(isDynamic) {
      this.globalize = new Internationalization(this.locale);
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : [
        "startDate",
        "endDate",
        "minDays",
        "maxDays",
        "min",
        "max",
        "disabled",
        "readonly",
        "style",
        "name",
        "placeholder",
        "type",
        "value"
      ];
      var format = { format: this.formatString, type: "date", skeleton: "yMd" };
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {
          switch (prop) {
            case "disabled":
              if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions["enabled"] === void 0 || isDynamic) {
                var disabled = this.inputElement.getAttribute(prop) === "disabled" || this.inputElement.getAttribute(prop) === "" || this.inputElement.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ enabled: !disabled }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions["readonly"] === void 0 || isDynamic) {
                var readonly = this.inputElement.getAttribute(prop) === "readonly" || this.inputElement.getAttribute(prop) === "true" || this.inputElement.getAttribute(prop) === "" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.inputElement.getAttribute(prop) }, !isDynamic);
              }
              break;
            case "value":
              if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions["value"] === void 0 || isDynamic) {
                var value = this.inputElement.getAttribute(prop);
                this.setProperties(setValue(prop, value, {}), !isDynamic);
              }
              break;
            case "style":
              this.inputElement.setAttribute("style", "" + this.inputElement.getAttribute(prop));
              break;
            case "min":
              if (isNullOrUndefined(this.min) || +this.min === +new Date(1900, 0, 1) || isDynamic) {
                var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
                this.setProperties(setValue(prop, dateValue, {}), !isDynamic);
              }
              break;
            case "name":
              this.inputElement.setAttribute("name", "" + this.inputElement.getAttribute(prop));
              break;
            case "max":
              if (isNullOrUndefined(this.max) || +this.max === +new Date(2099, 11, 31) || isDynamic) {
                var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
                this.setProperties(setValue(prop, dateValue, {}), !isDynamic);
              }
              break;
            case "startDate":
              if (isNullOrUndefined(this.startDate)) {
                var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
                this.startValue = dateValue;
                this.setValue();
              }
              break;
            case "endDate":
              if (isNullOrUndefined(this.endDate)) {
                var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
                this.endValue = dateValue;
                this.setValue();
              }
              break;
            case "minDays":
              if (isNullOrUndefined(this.minDays)) {
                this.setProperties(setValue(prop, parseInt(this.inputElement.getAttribute(prop), 10), {}), true);
              }
              break;
            case "maxDays":
              if (isNullOrUndefined(this.maxDays)) {
                this.setProperties(setValue(prop, parseInt(this.inputElement.getAttribute(prop), 10), {}), true);
              }
              break;
            case "type":
              if (this.inputElement.getAttribute(prop) !== "text") {
                this.inputElement.setAttribute("type", "text");
              }
              break;
          }
        }
      }
    };
    DateRangePicker2.prototype.createPopup = function() {
      for (var i = 0; i < this.presetsItem.length; i++) {
        if (i !== this.presetsItem.length - 1 && this.presetsItem[i].id === "custom_range") {
          this.presetsItem.splice(i, 1);
        }
      }
      this.activeIndex = this.presetsItem.length - 1;
      this.isCustomRange = true;
      for (var i = 0; i <= this.presetsItem.length - 2; i++) {
        var startDate = this.presetsItem[i].start;
        var endDate = this.presetsItem[i].end;
        if (this.startValue && this.endValue) {
          if (+new Date(startDate.setHours(0, 0, 0, 0)) === +new Date(this.startValue.setHours(0, 0, 0, 0)) && +new Date(endDate.setHours(0, 0, 0, 0)) === +new Date(this.endValue.setHours(0, 0, 0, 0))) {
            this.activeIndex = i;
            this.isCustomRange = false;
          }
        }
      }
      this.popupWrapper = createElement("div", { id: this.element.id + "_popup", className: ROOT3 + " " + POPUP2 });
      this.adjustLongHeaderWidth();
      var isPreset = !this.isCustomRange || this.isMobile;
      if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && isPreset) {
        this.isCustomWindow = false;
        this.createPresets();
        this.listRippleEffect();
        this.renderPopup();
      } else {
        this.isCustomWindow = true;
        this.renderControl();
      }
    };
    DateRangePicker2.prototype.renderControl = function() {
      this.createControl();
      this.bindCalendarEvents();
      this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
        this.disabledDateRender();
      }
      this.updateHeader();
    };
    DateRangePicker2.prototype.clearCalendarEvents = function() {
      EventHandler.clearEvents(this.leftCalPrevIcon);
      EventHandler.clearEvents(this.leftCalNextIcon);
      EventHandler.clearEvents(this.rightCalPrevIcon);
      EventHandler.clearEvents(this.rightCalNextIcon);
    };
    DateRangePicker2.prototype.updateNavIcons = function() {
      _super.prototype.iconHandler.call(this);
    };
    DateRangePicker2.prototype.calendarIconEvent = function() {
      this.clearCalendarEvents();
      if (this.leftCalPrevIcon && !this.leftCalPrevIcon.classList.contains(DISABLED2)) {
        EventHandler.add(this.leftCalPrevIcon, "mousedown", this.navPrevFunction);
      }
      if (this.leftCalNextIcon && !this.leftCalNextIcon.classList.contains(DISABLED2)) {
        EventHandler.add(this.leftCalNextIcon, "mousedown", this.navNextFunction);
      }
      if (this.rightCalPrevIcon && !this.rightCalPrevIcon.classList.contains(DISABLED2)) {
        EventHandler.add(this.rightCalPrevIcon, "mousedown", this.navPrevFunction);
      }
      if (this.rightCalNextIcon && !this.rightCalNextIcon.classList.contains(DISABLED2)) {
        EventHandler.add(this.rightCalNextIcon, "mousedown", this.navNextFunction);
      }
    };
    DateRangePicker2.prototype.bindCalendarEvents = function() {
      if (!this.isMobile) {
        this.updateNavIcons();
        this.calendarIconEvent();
        this.calendarIconRipple();
        this.headerTitleElement = this.popupObj.element.querySelector("." + RIGHTCALENDER + " ." + HEADER2 + " ." + TITLE2);
        this.headerTitleElement = this.popupObj.element.querySelector("." + LEFTCALENDER + " ." + HEADER2 + " ." + TITLE2);
        this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
        this.leftKeyboardModule = new KeyboardEvents(this.leftCalendar, {
          eventName: "keydown",
          keyAction: this.keyInputHandler.bind(this),
          keyConfigs: this.defaultKeyConfigs
        });
        this.rightKeyboardModule = new KeyboardEvents(this.rightCalendar, {
          eventName: "keydown",
          keyAction: this.keyInputHandler.bind(this),
          keyConfigs: this.defaultKeyConfigs
        });
      } else {
        this.deviceCalendarEvent();
        EventHandler.add(this.startButton.element, "click", this.deviceHeaderClick, this);
        EventHandler.add(this.endButton.element, "click", this.deviceHeaderClick, this);
      }
      if (this.start === this.depth) {
        this.bindCalendarCellEvents();
      }
      this.removeFocusedDate();
    };
    DateRangePicker2.prototype.calendarIconRipple = function() {
      rippleEffect(this.leftCalPrevIcon, { selector: ".e-prev", duration: 400, isCenterRipple: true });
      rippleEffect(this.leftCalNextIcon, { selector: ".e-next", duration: 400, isCenterRipple: true });
      rippleEffect(this.rightCalPrevIcon, { selector: ".e-prev", duration: 400, isCenterRipple: true });
      rippleEffect(this.rightCalNextIcon, { selector: ".e-next", duration: 400, isCenterRipple: true });
    };
    DateRangePicker2.prototype.deviceCalendarEvent = function() {
      EventHandler.clearEvents(this.nextIcon);
      EventHandler.clearEvents(this.previousIcon);
      rippleEffect(this.nextIcon, { selector: ".e-prev", duration: 400, isCenterRipple: true });
      rippleEffect(this.previousIcon, { selector: ".e-next", duration: 400, isCenterRipple: true });
      if (this.nextIcon && !this.nextIcon.classList.contains(DISABLED2)) {
        EventHandler.add(this.nextIcon, "mousedown", this.deviceNavNextFunction);
      }
      if (this.previousIcon && !this.previousIcon.classList.contains(DISABLED2)) {
        EventHandler.add(this.previousIcon, "mousedown", this.deviceNavPrevFunction);
      }
    };
    DateRangePicker2.prototype.deviceNavNext = function(e) {
      var calendar = closest(e.target, "." + CALENDAR);
      this.updateDeviceCalendar(calendar);
      this.navigateNext(e);
      this.deviceNavigation();
    };
    DateRangePicker2.prototype.deviceNavPrevious = function(e) {
      var calendar = closest(e.target, "." + CALENDAR);
      this.updateDeviceCalendar(calendar);
      this.navigatePrevious(e);
      this.deviceNavigation();
    };
    DateRangePicker2.prototype.updateDeviceCalendar = function(calendar) {
      if (calendar) {
        this.previousIcon = calendar.querySelector("." + PREVICON2);
        this.nextIcon = calendar.querySelector("." + NEXTICON2);
        this.calendarElement = calendar;
        this.deviceCalendar = calendar;
        this.contentElement = calendar.querySelector("." + CONTENT2);
        this.tableBodyElement = select("." + CONTENT2 + " tbody", calendar);
        this.table = calendar.querySelector("." + CONTENT2).getElementsByTagName("table")[0];
        this.headerTitleElement = calendar.querySelector("." + HEADER2 + " ." + TITLE2);
        this.headerElement = calendar.querySelector("." + HEADER2);
      }
    };
    DateRangePicker2.prototype.deviceHeaderClick = function(event) {
      var element = event.currentTarget;
      if (element.classList.contains(STARTBUTTON) && !isNullOrUndefined(this.startValue)) {
        this.endButton.element.classList.remove(ACTIVE2);
        this.startButton.element.classList.add(ACTIVE2);
        var calendar = this.popupObj.element.querySelector("." + CALENDAR);
        this.updateDeviceCalendar(calendar);
        if (isNullOrUndefined(this.calendarElement.querySelector("." + STARTDATE + ":not(.e-other-month)"))) {
          this.currentDate = /* @__PURE__ */ new Date(+this.startValue);
          remove(this.tableBodyElement);
          this.createContentBody();
          this.deviceNavigation();
        }
        this.removeClassDisabled();
      } else if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
        this.startButton.element.classList.remove(ACTIVE2);
        this.endButton.element.classList.add(ACTIVE2);
        var calendar = this.popupObj.element.querySelector("." + CALENDAR);
        this.updateDeviceCalendar(calendar);
        if (isNullOrUndefined(this.calendarElement.querySelector("." + ENDDATE + ":not(.e-other-month)"))) {
          this.currentDate = /* @__PURE__ */ new Date(+this.endValue);
          remove(this.tableBodyElement);
          this.createContentBody();
          this.deviceNavigation();
        }
        this.updateMinMaxDays(this.popupObj.element.querySelector("." + CALENDAR));
        this.selectableDates();
      }
    };
    DateRangePicker2.prototype.inputFocusHandler = function() {
      if (!this.enabled) {
        return;
      }
      this.preventBlur = false;
      var focusArguments = {
        model: this
      };
      if (!this.preventFocus) {
        this.trigger("focus", focusArguments);
      }
      this.updateClearIconState();
      this.updateHiddenInput();
      if (this.openOnFocus && !this.preventFocus) {
        this.preventFocus = true;
        this.show();
      } else {
        this.preventFocus = true;
      }
    };
    DateRangePicker2.prototype.inputBlurHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (!this.preventBlur) {
        var value = this.inputElement.value;
        if (!isNullOrUndefined(this.presetsItem)) {
          if (this.presetsItem.length > 0 && this.previousEleValue !== this.inputElement.value) {
            this.activeIndex = this.presetsItem.length - 1;
            this.isCustomRange = true;
          }
        }
        if (!isNullOrUndefined(value) && value.trim() !== "") {
          var range = value.split(" " + this.separator + " ");
          if (range.length > 1) {
            this.invalidValueString = null;
            var dateOptions = { format: this.formatString, type: "date", skeleton: "yMd" };
            var startDate = this.globalize.parseDate(range[0].trim(), dateOptions);
            var endDate = this.globalize.parseDate(range[1].trim(), dateOptions);
            if (!isNullOrUndefined(startDate) && !isNaN(+startDate) && !isNullOrUndefined(endDate) && !isNaN(+endDate)) {
              var prevStartVal = this.startValue;
              this.startValue = startDate;
              var prevEndVal = this.endValue;
              this.endValue = endDate;
              this.setValue();
              this.refreshControl();
              if (value !== this.previousEleValue) {
                this.changeTrigger(e);
              }
              if (!this.preventBlur && document.activeElement !== this.inputElement) {
                this.preventFocus = false;
                var blurArguments = {
                  model: this
                };
                this.trigger("blur", blurArguments);
              }
              this.updateHiddenInput();
              if (this.isMobile && this.isPopupOpen()) {
                this.startValue = prevStartVal;
                this.endValue = prevEndVal;
              }
              return;
            } else {
              if (!this.strictMode) {
                this.startValue = null;
                this.endValue = null;
                this.setValue();
              }
            }
          } else {
            if (!this.strictMode) {
              this.startValue = null;
              this.endValue = null;
              this.setValue();
            }
          }
        }
        if (!this.strictMode) {
          if (isNullOrUndefined(this.popupObj)) {
            this.currentDate = null;
          }
          this.previousStartValue = this.previousEndValue = null;
          this.startValue = null;
          this.endValue = null;
          this.setValue();
        } else {
          if (!isNullOrUndefined(value) && value.trim() === "") {
            this.startValue = null;
            this.endValue = null;
          }
          Input.setValue("", this.inputElement, this.floatLabelType, this.showClearButton);
          this.updateInput();
        }
        this.errorClass();
        this.changeTrigger(e);
        if (!this.preventBlur && document.activeElement !== this.inputElement) {
          this.preventFocus = false;
          var blurArguments = {
            model: this
          };
          this.trigger("blur", blurArguments);
        }
      }
      this.updateHiddenInput();
    };
    DateRangePicker2.prototype.clearRange = function() {
      this.previousStartValue = this.previousEndValue = null;
      this.currentDate = null;
    };
    DateRangePicker2.prototype.errorClass = function() {
      var inputStr = this.inputElement.value.trim();
      if ((isNullOrUndefined(this.endValue) && isNullOrUndefined(this.startValue) && inputStr !== "" || (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max) || (this.startValue && this.isDateDisabled(this.startValue) || this.endValue && this.isDateDisabled(this.endValue))) && inputStr !== "") {
        addClass([this.inputWrapper.container], ERROR2);
        attributes(this.inputElement, { "aria-invalid": "true" });
      } else {
        if (this.inputWrapper) {
          removeClass([this.inputWrapper.container], ERROR2);
          attributes(this.inputElement, { "aria-invalid": "false" });
        }
      }
    };
    DateRangePicker2.prototype.keyCalendarUpdate = function(isLeftCalendar, ele) {
      this.removeFocusedDate();
      if (isLeftCalendar) {
        this.leftCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
        ele = this.leftCalendar;
      } else {
        this.rightCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
        ele = this.rightCalendar;
      }
      this.updateCalendarElement(ele);
      this.table.focus();
      return ele;
    };
    DateRangePicker2.prototype.navInCalendar = function(e, isLeftCalendar, leftLimit, rightLimit, ele) {
      var view = this.getViewNumber(this.currentView());
      var date;
      var min = this.min;
      var max;
      if (!isNullOrUndefined(this.maxDays) && this.isMaxDaysClicked && !isNullOrUndefined(this.startValue)) {
        max = new Date((/* @__PURE__ */ new Date(+this.startValue)).setDate(this.startValue.getDate() + (this.maxDays - 1)));
      } else {
        max = this.max;
      }
      switch (e.action) {
        case "moveRight":
          date = /* @__PURE__ */ new Date(+this.currentDate);
          this.addDay(date, 1, e, max, min);
          if (isLeftCalendar && +date === +rightLimit) {
            ele = this.keyCalendarUpdate(false, ele);
          }
          this.keyboardNavigate(1, view, e, max, min);
          this.keyNavigation(ele, e);
          break;
        case "moveLeft":
          date = /* @__PURE__ */ new Date(+this.currentDate);
          this.addDay(date, -1, e, max, min);
          if (!isLeftCalendar) {
            if (+date === +leftLimit) {
              ele = this.keyCalendarUpdate(true, ele);
            }
          }
          this.keyboardNavigate(-1, view, e, max, min);
          this.keyNavigation(ele, e);
          break;
        case "moveUp":
          if (view === 0) {
            date = /* @__PURE__ */ new Date(+this.currentDate);
            this.addDay(date, -7, e, max, min);
            if (+date <= +leftLimit && !isLeftCalendar) {
              ele = this.keyCalendarUpdate(true, ele);
            }
            this.keyboardNavigate(-7, view, e, max, min);
          } else {
            this.keyboardNavigate(-4, view, e, this.max, this.min);
          }
          this.keyNavigation(ele, e);
          break;
        case "moveDown":
          if (view === 0) {
            date = /* @__PURE__ */ new Date(+this.currentDate);
            this.addDay(date, 7, e, max, min);
            if (isLeftCalendar && +date >= +rightLimit) {
              ele = this.keyCalendarUpdate(false, ele);
            }
            this.keyboardNavigate(7, view, e, max, min);
          } else {
            this.keyboardNavigate(4, view, e, this.max, this.min);
          }
          this.keyNavigation(ele, e);
          break;
        case "home":
          this.currentDate = this.firstDay(this.currentDate);
          remove(this.tableBodyElement);
          if (view === 0) {
            this.renderMonths(e);
          } else if (view === 1) {
            this.renderYears(e);
          } else {
            this.renderDecades(e);
          }
          this.keyNavigation(ele, e);
          break;
        case "end":
          this.currentDate = this.lastDay(this.currentDate, view);
          remove(this.tableBodyElement);
          if (view === 0) {
            this.renderMonths(e);
          } else if (view === 1) {
            this.renderYears(e);
          } else {
            this.renderDecades(e);
          }
          this.keyNavigation(ele, e);
          break;
      }
    };
    DateRangePicker2.prototype.keyInputHandler = function(e, value) {
      var date;
      var view = this.getViewNumber(this.currentView());
      var rightDateLimit = new Date(this.rightCalCurrentDate.getFullYear(), this.rightCalCurrentDate.getMonth(), 1);
      var leftDateLimit = new Date(this.leftCalCurrentDate.getFullYear(), this.leftCalCurrentDate.getMonth() + 1, 0);
      var ele = closest(e.target, "." + RIGHTCALENDER);
      ele = isNullOrUndefined(ele) ? this.leftCalendar : ele;
      var isLeftCalendar = ele.classList.contains(LEFTCALENDER);
      this.updateCalendarElement(ele);
      var selectedDate = this.tableBodyElement.querySelector("tr td.e-selected");
      var focusedDate = ele.querySelector("tr td." + FOCUSDATE);
      var startDate = ele.querySelector("tr td." + STARTDATE);
      var endDate = ele.querySelector("tr td." + ENDDATE);
      var depthValue = this.getViewNumber(this.depth);
      var levelRestrict = view === depthValue && this.getViewNumber(this.start) >= depthValue;
      var leftCalendar = closest(e.target, "." + LEFTCALENDER);
      var rightCalendar = closest(e.target, "." + RIGHTCALENDER);
      var presetElement = closest(e.target, "." + PRESETS);
      if (!isNullOrUndefined(focusedDate)) {
        this.currentDate = this.currentDate;
      } else if (!isNullOrUndefined(endDate) && !this.dateDisabled) {
        this.currentDate = /* @__PURE__ */ new Date(+this.endValue);
      } else if (!isNullOrUndefined(startDate) && !this.dateDisabled) {
        this.currentDate = /* @__PURE__ */ new Date(+this.startValue);
      } else if (!this.dateDisabled) {
        this.currentDate.setDate(1);
      }
      this.effect = "";
      switch (e.action) {
        case "altUpArrow":
          if (this.isPopupOpen()) {
            this.hide(e);
            this.preventFocus = true;
            this.inputElement.focus();
            addClass([this.inputWrapper.container], [INPUTFOCUS2]);
          }
          break;
        case "select":
          if (levelRestrict) {
            var element = !isNullOrUndefined(focusedDate) ? focusedDate : startDate;
            if (!isNullOrUndefined(element) && !element.classList.contains(DISABLED2)) {
              this.selectRange(null, element);
            }
          } else {
            if (!isNullOrUndefined(selectedDate) && !levelRestrict || !isNullOrUndefined(focusedDate)) {
              if (!isNullOrUndefined(this.value)) {
                if (this.calendarElement.classList.contains(LEFTCALENDER)) {
                  value = this.startDate;
                } else {
                  value = this.endDate;
                }
              }
              this.controlDown = e;
              this.contentClick(null, --view, focusedDate || selectedDate, value);
            }
          }
          e.preventDefault();
          break;
        case "controlHome":
          {
            var yearDate = new Date(this.currentDate.getFullYear(), 0, 1);
            if (!isLeftCalendar && +yearDate < +leftDateLimit) {
              ele = this.keyCalendarUpdate(true, ele);
            }
            _super.prototype.navigateTo.call(this, "Month", new Date(this.currentDate.getFullYear(), 0, 1));
            this.keyNavigation(ele, e);
          }
          break;
        case "altRightArrow":
          if (!isNullOrUndefined(leftCalendar)) {
            this.rightCalendar.children[1].firstElementChild.focus();
          } else if (!isNullOrUndefined(rightCalendar)) {
            if (!isNullOrUndefined(this.presetElement)) {
              this.presetElement.focus();
              this.removeFocusedDate();
            } else {
              this.cancelButton.element.focus();
            }
          } else {
            if (!isNullOrUndefined(presetElement)) {
              this.cancelButton.element.focus();
            }
          }
          e.preventDefault();
          break;
        case "altLeftArrow":
          if (!isNullOrUndefined(leftCalendar)) {
            if (this.applyButton.element.disabled !== true) {
              this.applyButton.element.focus();
            } else {
              this.cancelButton.element.focus();
            }
          } else {
            if (!isNullOrUndefined(rightCalendar)) {
              this.leftCalendar.children[1].firstElementChild.focus();
            }
          }
          e.preventDefault();
          break;
        case "controlUp":
          if (this.calendarElement.classList.contains(LEFTCALENDER)) {
            this.calendarNavigation(e, this.calendarElement);
          } else {
            this.calendarNavigation(e, this.calendarElement);
          }
          e.preventDefault();
          break;
        case "controlDown":
          if ((!isNullOrUndefined(selectedDate) || !isNullOrUndefined(focusedDate)) && !levelRestrict) {
            if (!isNullOrUndefined(this.value)) {
              if (this.calendarElement.classList.contains(LEFTCALENDER)) {
                value = this.startDate;
              } else {
                value = this.endDate;
              }
            }
            this.controlDown = e;
            this.contentClick(null, --view, selectedDate || focusedDate, value);
          }
          e.preventDefault();
          break;
        case "controlEnd":
          {
            var yearDate = new Date(this.currentDate.getFullYear(), 11, 31);
            if (isLeftCalendar && +yearDate > +rightDateLimit) {
              ele = this.keyCalendarUpdate(false, ele);
            }
            _super.prototype.navigateTo.call(this, "Month", new Date(this.currentDate.getFullYear(), 11, 31));
            this.keyNavigation(ele, e);
          }
          break;
        case "pageUp":
          date = /* @__PURE__ */ new Date(+this.currentDate);
          this.addMonths(date, -1);
          if (!isLeftCalendar && +date <= +leftDateLimit) {
            ele = this.keyCalendarUpdate(true, ele);
          }
          this.addMonths(this.currentDate, -1);
          _super.prototype.navigateTo.call(this, "Month", this.currentDate);
          this.keyNavigation(ele, e);
          break;
        case "pageDown":
          date = /* @__PURE__ */ new Date(+this.currentDate);
          this.addMonths(date, 1);
          if (isLeftCalendar && +date >= +rightDateLimit) {
            ele = this.keyCalendarUpdate(false, ele);
          }
          this.addMonths(this.currentDate, 1);
          _super.prototype.navigateTo.call(this, "Month", this.currentDate);
          this.keyNavigation(ele, e);
          break;
        case "shiftPageUp":
          date = /* @__PURE__ */ new Date(+this.currentDate);
          this.addYears(date, -1);
          if (!isLeftCalendar && +date <= +leftDateLimit) {
            ele = this.keyCalendarUpdate(true, ele);
          }
          this.addYears(this.currentDate, -1);
          _super.prototype.navigateTo.call(this, "Month", this.currentDate);
          this.keyNavigation(ele, e);
          break;
        case "shiftPageDown":
          date = /* @__PURE__ */ new Date(+this.currentDate);
          this.addYears(date, 1);
          if (isLeftCalendar && +date >= +rightDateLimit) {
            ele = this.keyCalendarUpdate(false, ele);
          }
          this.addYears(this.currentDate, 1);
          _super.prototype.navigateTo.call(this, "Month", this.currentDate);
          this.keyNavigation(ele, e);
          break;
        case "shiftTab":
          if (!isNullOrUndefined(this.presetElement)) {
            this.presetElement.setAttribute("tabindex", "0");
            this.presetElement.focus();
            this.removeFocusedDate();
          }
          e.preventDefault();
          break;
        case "spacebar":
          if (this.applyButton && !this.applyButton.disabled) {
            this.applyFunction(e);
          }
          break;
        default:
          this.navInCalendar(e, isLeftCalendar, leftDateLimit, rightDateLimit, ele);
          this.checkMinMaxDays();
      }
      this.presetHeight();
    };
    DateRangePicker2.prototype.keyNavigation = function(calendar, e) {
      this.bindCalendarCellEvents(calendar);
      if (calendar.classList.contains(LEFTCALENDER)) {
        this.leftCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
      } else {
        this.rightCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
      }
      this.updateNavIcons();
      this.calendarIconEvent();
      this.updateRange([calendar]);
      this.dateDisabled = this.isDateDisabled(this.currentDate);
      e.preventDefault();
    };
    DateRangePicker2.prototype.inputHandler = function(e) {
      switch (e.action) {
        case "altDownArrow":
          if (!this.isPopupOpen()) {
            if (this.inputElement.value === "") {
              this.clear();
              this.changeTrigger(e);
              this.clearRange();
            }
            this.show(null, e);
            this.isRangeIconClicked = false;
            if (!this.isMobile) {
              if (!isNullOrUndefined(this.leftCalendar)) {
                this.calendarFocus();
              }
            }
            this.isKeyPopup = true;
          }
          break;
        case "escape":
          if (this.isPopupOpen()) {
            this.hide(e);
          }
          break;
        case "enter":
          if (document.activeElement === this.inputElement) {
            this.inputBlurHandler(e);
            this.hide(e);
          }
          break;
        case "tab":
          if (document.activeElement === this.inputElement && this.isPopupOpen()) {
            this.hide(e);
            e.preventDefault();
          }
          break;
      }
    };
    DateRangePicker2.prototype.bindCalendarCellEvents = function(calendar) {
      var tdCells;
      if (calendar) {
        tdCells = calendar.querySelectorAll("." + CALENDAR + " td");
      } else {
        tdCells = this.popupObj.element.querySelectorAll("." + CALENDAR + " td");
      }
      for (var _i = 0, tdCells_1 = tdCells; _i < tdCells_1.length; _i++) {
        var cell = tdCells_1[_i];
        EventHandler.clearEvents(cell);
        var disabledCell = cell.classList.contains(DISABLED2) || cell.classList.contains(DATEDISABLED);
        if (!disabledCell && !cell.classList.contains(WEEKNUMBER2)) {
          if (!this.isMobile) {
            EventHandler.add(cell, "mouseover", this.hoverSelection, this);
          }
          EventHandler.add(cell, "mousedown", this.selectRange, this);
        }
      }
    };
    DateRangePicker2.prototype.removeFocusedDate = function() {
      var isDate = !isNullOrUndefined(this.startValue) || !isNullOrUndefined(this.endValue);
      var focusedDate = this.popupObj.element.querySelectorAll("." + CALENDAR + " ." + FOCUSDATE);
      for (var _i = 0, focusedDate_1 = focusedDate; _i < focusedDate_1.length; _i++) {
        var ele = focusedDate_1[_i];
        var today = /* @__PURE__ */ new Date();
        var eleDate = this.getIdValue(null, ele);
        if (this.depth === "Month" && this.currentView() === "Month" && (!ele.classList.contains(TODAY2) || ele.classList.contains(TODAY2) && isDate) || this.depth === "Year" && this.currentView() === "Year" && (!this.isSameMonth(today, eleDate) && !this.isSameYear(today, eleDate) || isDate) || this.depth === "Decade" && this.currentView() === "Decade" && (!this.isSameYear(today, eleDate) || isDate)) {
          ele.classList.remove(FOCUSDATE);
          if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(ENDDATE)) {
            ele.removeAttribute("aria-label");
          }
        }
      }
    };
    DateRangePicker2.prototype.hoverSelection = function(event, element) {
      var currentElement = element || event.currentTarget;
      var currentDate = this.getIdValue(null, currentElement);
      if (!isNullOrUndefined(this.startValue) && +this.startValue >= +this.min && +this.startValue <= +this.max) {
        if (!this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue) && isNullOrUndefined(this.endValue) && isNullOrUndefined(this.startValue) || !isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
          var tdCells = this.popupObj.element.querySelectorAll("." + CALENDAR + " td");
          for (var _i = 0, tdCells_2 = tdCells; _i < tdCells_2.length; _i++) {
            var ele = tdCells_2[_i];
            var isDisabledCell = !ele.classList.contains(DISABLED2) || ele.classList.contains(DATEDISABLED);
            if (!ele.classList.contains(WEEKNUMBER2) && isDisabledCell) {
              var eleDate = this.getIdValue(null, ele);
              var startDateValue = /* @__PURE__ */ new Date(+this.startValue);
              var eleDateValue = /* @__PURE__ */ new Date(+eleDate);
              if (eleDateValue.setHours(0, 0, 0, 0) >= startDateValue.setHours(0, 0, 0, 0) && +eleDate <= +currentDate) {
                addClass([ele], RANGEHOVER);
              } else {
                removeClass([ele], [RANGEHOVER]);
              }
            }
          }
        }
      }
    };
    DateRangePicker2.prototype.isSameStartEnd = function(startVal, endVal) {
      var isSame = false;
      if (this.depth === "Month") {
        if (startVal.setHours(0, 0, 0, 0) === endVal.setHours(0, 0, 0, 0)) {
          isSame = true;
        }
      } else if (this.depth === "Year") {
        if (startVal.getFullYear() === endVal.getFullYear() && startVal.getMonth() === endVal.getMonth()) {
          isSame = true;
        }
      } else if (this.depth === "Decade") {
        if (startVal.getFullYear() === endVal.getFullYear()) {
          isSame = true;
        }
      }
      return isSame;
    };
    DateRangePicker2.prototype.updateRange = function(elementCollection) {
      if (!isNullOrUndefined(this.startValue)) {
        for (var _i = 0, elementCollection_1 = elementCollection; _i < elementCollection_1.length; _i++) {
          var calendar = elementCollection_1[_i];
          var tdCells = calendar.querySelectorAll("." + CALENDAR + " td");
          for (var _a = 0, tdCells_3 = tdCells; _a < tdCells_3.length; _a++) {
            var ele = tdCells_3[_a];
            if (!ele.classList.contains(WEEKNUMBER2) && !ele.classList.contains(DISABLED2)) {
              var eleDate = this.getIdValue(null, ele);
              var eleDateValue = this.getIdValue(null, ele);
              if (!isNullOrUndefined(this.endValue)) {
                if (this.currentView() === this.depth && +eleDateValue.setHours(0, 0, 0, 0) >= +(/* @__PURE__ */ new Date(+this.startValue)).setHours(0, 0, 0, 0) && +eleDateValue.setHours(0, 0, 0, 0) <= +(/* @__PURE__ */ new Date(+this.endValue)).setHours(0, 0, 0, 0) && !this.isSameStartEnd(/* @__PURE__ */ new Date(+this.startValue), /* @__PURE__ */ new Date(+this.endValue)) && +(/* @__PURE__ */ new Date(+this.startValue)).setHours(0, 0, 0, 0) >= +this.min && +(/* @__PURE__ */ new Date(+this.endValue)).setHours(0, 0, 0, 0) <= +this.max && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {
                  addClass([ele], RANGEHOVER);
                }
              } else {
                removeClass([ele], [RANGEHOVER]);
              }
              if (ele.classList.contains(SELECTED3) && ele.classList.contains(ENDDATE) && +eleDateValue !== +this.endValue) {
                removeClass([ele], [SELECTED3]);
                removeClass([ele], [ENDDATE]);
              }
              if (ele.classList.contains(RANGEHOVER) && +eleDateValue > +this.endValue) {
                removeClass([ele], [RANGEHOVER]);
              }
              if (!ele.classList.contains(OTHERMONTH2)) {
                var startDateValue = /* @__PURE__ */ new Date(+this.startValue);
                var eleDateValue_1 = /* @__PURE__ */ new Date(+eleDate);
                if (this.currentView() === this.depth && +eleDateValue_1.setHours(0, 0, 0, 0) === +startDateValue.setHours(0, 0, 0, 0) && +eleDateValue_1.setHours(0, 0, 0, 0) >= +startDateValue.setHours(0, 0, 0, 0) && +this.startValue >= +this.min && !this.inputWrapper.container.classList.contains("e-error") && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {
                  addClass([ele], [STARTDATE, SELECTED3]);
                  this.addSelectedAttributes(ele, this.startValue, true);
                }
                var endDateValue = /* @__PURE__ */ new Date(+this.endValue);
                if (this.currentView() === "Year") {
                  eleDateValue_1 = new Date(eleDateValue_1.getFullYear(), eleDateValue_1.getMonth() + 1, 0);
                } else if (this.currentView() === "Decade") {
                  eleDateValue_1 = new Date(eleDateValue_1.getFullYear(), 11, 31);
                }
                if (this.currentView() === this.depth && !isNullOrUndefined(this.endValue) && +eleDateValue_1.setHours(0, 0, 0, 0) === +endDateValue.setHours(0, 0, 0, 0) && +eleDateValue_1.setHours(0, 0, 0, 0) <= +endDateValue.setHours(0, 0, 0, 0) && +this.startValue >= +this.min && !this.inputWrapper.container.classList.contains("e-error") && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {
                  addClass([ele], [ENDDATE, SELECTED3]);
                  this.addSelectedAttributes(ele, this.startValue, false);
                }
                if (+eleDate === +this.startValue && !isNullOrUndefined(this.endValue) && +eleDate === +this.endValue) {
                  this.addSelectedAttributes(ele, this.endValue, false, true);
                }
              }
            }
          }
        }
      }
    };
    DateRangePicker2.prototype.checkMinMaxDays = function() {
      if (!isNullOrUndefined(this.minDays) && this.minDays > 0 || !isNullOrUndefined(this.maxDays) && this.maxDays > 0) {
        if (!this.isMobile) {
          this.updateMinMaxDays(this.popupObj.element.querySelector("." + LEFTCALENDER));
          this.updateMinMaxDays(this.popupObj.element.querySelector("." + RIGHTCALENDER));
        } else {
          this.updateMinMaxDays(this.popupObj.element.querySelector("." + CALENDAR));
        }
      }
    };
    DateRangePicker2.prototype.rangeArgs = function(e) {
      var inputValue;
      var range;
      var startDate = !isNullOrUndefined(this.startValue) ? this.globalize.formatDate(this.startValue, {
        format: this.formatString,
        type: "date",
        skeleton: "yMd"
      }) : null;
      var endDate = !isNullOrUndefined(this.endValue) ? this.globalize.formatDate(this.endValue, {
        format: this.formatString,
        type: "date",
        skeleton: "yMd"
      }) : null;
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
        inputValue = startDate + " " + this.separator + " " + endDate;
        range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1e3 * 60 * 60 * 24))) + 1;
      } else {
        inputValue = "";
        range = 0;
      }
      var args = {
        value: this.value,
        startDate: this.startValue,
        endDate: this.endValue,
        daySpan: range,
        event: e || null,
        element: this.element,
        isInteracted: !isNullOrUndefined(e),
        text: inputValue
      };
      return args;
    };
    DateRangePicker2.prototype.otherMonthSelect = function(ele, isStartDate, sameDate) {
      var value = +this.getIdValue(null, ele);
      var dateIdString = '*[id^="/id"]:not(.e-other-month)'.replace("/id", "" + value);
      var tdCell = this.popupObj && this.popupObj.element.querySelector(dateIdString);
      if (!isNullOrUndefined(tdCell)) {
        if (isStartDate) {
          addClass([tdCell], [STARTDATE, SELECTED3]);
          this.addSelectedAttributes(tdCell, this.startValue, true);
        } else {
          addClass([tdCell], [ENDDATE, SELECTED3]);
          this.addSelectedAttributes(tdCell, this.endValue, true);
        }
        if (sameDate) {
          this.addSelectedAttributes(ele, this.endValue, false, true);
        }
      }
    };
    DateRangePicker2.prototype.selectRange = function(event, element) {
      var leftCalendar;
      var rightCalendar;
      if (event) {
        event.preventDefault();
      }
      var date = isNullOrUndefined(event) ? this.getIdValue(null, element) : this.getIdValue(event, null);
      var y = date.getFullYear();
      var m = date.getMonth();
      var firstDay = new Date(y, m, 1);
      var lastDay = new Date(y, m + 1, 0);
      var firstMonth = new Date(y, 0, 1);
      var lastMonth = new Date(y, 11, 31);
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
        if (!this.isMobile || this.isMobile && !this.endButton.element.classList.contains(ACTIVE2)) {
          this.removeSelection();
        }
      } else if (this.isMobile && this.startButton.element.classList.contains(ACTIVE2)) {
        this.removeSelection();
      }
      var ele = element || event.currentTarget;
      if (isNullOrUndefined(this.startValue)) {
        if (!isNullOrUndefined(this.previousStartValue)) {
          date.setHours(this.previousStartValue.getHours());
          date.setMinutes(this.previousStartValue.getMinutes());
          date.setSeconds(this.previousStartValue.getSeconds());
        }
        this.startValue = this.depth === "Month" ? new Date(this.checkValue(date)) : this.depth === "Year" ? firstDay : firstMonth;
        this.endValue = null;
        this.setValue();
        addClass([ele], STARTDATE);
        this.addSelectedAttributes(ele, this.startValue, true);
        if (ele.classList.contains(OTHERMONTH2)) {
          this.otherMonthSelect(ele, true);
        }
        this.checkMinMaxDays();
        this.applyButton.disabled = true;
        this.applyButton.element.disabled = true;
        if (this.isMobile) {
          this.endButton.element.classList.add(ACTIVE2);
          this.startButton.element.classList.remove(ACTIVE2);
          this.endButton.element.removeAttribute("disabled");
          this.selectableDates();
        }
        this.trigger("select", this.rangeArgs(event));
      } else {
        if (+date === +this.startValue || +date > +this.startValue) {
          if (+date === +this.startValue && !isNullOrUndefined(this.minDays) && this.minDays > 1) {
            return;
          }
          this.endValue = null;
          this.setValue();
          if (this.isMobile || element) {
            this.hoverSelection(event, element);
          }
          if (!isNullOrUndefined(this.previousEndValue)) {
            date.setHours(this.previousEndValue.getHours());
            date.setMinutes(this.previousEndValue.getMinutes());
            date.setSeconds(this.previousEndValue.getSeconds());
          }
          this.endValue = this.depth === "Month" ? new Date(this.checkValue(date)) : this.depth === "Year" ? lastDay : lastMonth;
          this.setValue();
          var endEle = this.popupObj.element.querySelectorAll("." + ENDDATE);
          if (this.isMobile) {
            this.startButton.element.classList.remove(ACTIVE2);
            this.endButton.element.classList.add(ACTIVE2);
            for (var _i = 0, endEle_1 = endEle; _i < endEle_1.length; _i++) {
              var ele_1 = endEle_1[_i];
              ele_1.removeAttribute("aria-label");
              if (!ele_1.classList.contains(STARTDATE)) {
                ele_1.setAttribute("aria-selected", "false");
                removeClass([ele_1], [ENDDATE, SELECTED3]);
              } else {
                this.addSelectedAttributes(ele_1, this.startValue, true);
                removeClass([ele_1], [ENDDATE]);
              }
            }
          }
          addClass([ele], ENDDATE);
          if (+this.endValue === +this.startValue) {
            this.addSelectedAttributes(ele, this.endValue, false, true);
          } else {
            this.addSelectedAttributes(ele, this.endValue, false);
          }
          if (ele.classList.contains(OTHERMONTH2)) {
            if (+this.endValue === +this.startValue) {
              this.otherMonthSelect(ele, false, true);
            } else {
              this.otherMonthSelect(ele, false);
            }
          }
          endEle = this.popupObj.element.querySelectorAll("." + ENDDATE);
          for (var _a = 0, endEle_2 = endEle; _a < endEle_2.length; _a++) {
            var ele_2 = endEle_2[_a];
            if (ele_2.classList.contains(STARTDATE)) {
              removeClass([ele_2], [RANGEHOVER]);
            }
          }
          this.applyButton.disabled = false;
          this.applyButton.element.disabled = false;
          if (!this.isMobile) {
            this.removeClassDisabled();
          }
          this.disabledDateRender();
          this.trigger("select", this.rangeArgs(event));
        } else if (+date < +this.startValue) {
          this.removeClassDisabled();
          this.startValue = this.depth === "Month" ? new Date(this.checkValue(date)) : this.depth === "Year" ? firstDay : firstMonth;
          this.setValue();
          this.removeSelectedAttributes();
          removeClass(this.popupObj.element.querySelectorAll("." + STARTDATE), [STARTDATE, SELECTED3]);
          addClass([ele], STARTDATE);
          this.addSelectedAttributes(ele, this.startValue, true);
          if (ele.classList.contains(OTHERMONTH2)) {
            this.otherMonthSelect(ele, true);
          }
          this.checkMinMaxDays();
        }
      }
      if (event) {
        leftCalendar = closest(event.target, "." + LEFTCALENDER);
      }
      if (!isNullOrUndefined(leftCalendar)) {
        this.leftCalendar.children[1].firstElementChild.focus();
      } else {
        if (event) {
          rightCalendar = event && closest(event.target, "." + RIGHTCALENDER);
        }
        if (!isNullOrUndefined(rightCalendar)) {
          this.rightCalendar.children[1].firstElementChild.focus();
        }
      }
      addClass([ele], SELECTED3);
      this.updateHeader();
      this.removeFocusedDate();
    };
    DateRangePicker2.prototype.selectableDates = function() {
      if (!isNullOrUndefined(this.startValue)) {
        var tdCells = this.calendarElement.querySelectorAll("." + CALENDAR + " td");
        var isStartDate = false;
        if (this.currentView() === this.depth) {
          for (var _i = 0, tdCells_4 = tdCells; _i < tdCells_4.length; _i++) {
            var ele = tdCells_4[_i];
            if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(WEEKNUMBER2)) {
              if (!ele.classList.contains(DISABLED2)) {
                var eleDate = this.getIdValue(null, ele);
                if (+eleDate < +this.startValue) {
                  addClass([ele], [DATEDISABLED, DISABLED2, OVERLAY2]);
                  EventHandler.clearEvents(ele);
                  continue;
                } else {
                  break;
                }
              }
            }
            if (ele.classList.contains(STARTDATE) && !ele.classList.contains(OTHERMONTH2)) {
              isStartDate = true;
              break;
            }
          }
          if (isStartDate) {
            if (!this.previousIcon.classList.contains(DISABLED2)) {
              addClass([this.previousIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
            }
          }
        } else {
          for (var _a = 0, tdCells_5 = tdCells; _a < tdCells_5.length; _a++) {
            var ele = tdCells_5[_a];
            var startMonth = this.startValue.getMonth();
            var startYear = this.startValue.getFullYear();
            var element = this.getIdValue(null, ele);
            if (!this.startButton.element.classList.contains(ACTIVE2) && (this.currentView() === "Year" && element.getMonth() < startMonth && element.getFullYear() <= startYear || this.currentView() === "Decade" && element.getMonth() <= startMonth && element.getFullYear() < startYear)) {
              addClass([ele], [DISABLED2]);
            } else {
              break;
            }
          }
          if (tdCells[0].classList.contains(DISABLED2)) {
            this.previousIconHandler(true);
          } else if (tdCells[tdCells.length - 1].classList.contains(DISABLED2)) {
            this.nextIconHandler(true);
          }
        }
      }
    };
    DateRangePicker2.prototype.updateMinMaxDays = function(calendar) {
      if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue) || this.isMobile && this.endButton.element.classList.contains(ACTIVE2)) {
        if (!isNullOrUndefined(this.minDays) && this.minDays > 0 || !isNullOrUndefined(this.maxDays) && this.maxDays > 0) {
          var startValueSelected = this.removeTimeValueFromDate(this.startValue);
          var minDate = new Date((/* @__PURE__ */ new Date(+startValueSelected)).setDate(startValueSelected.getDate() + (this.minDays - 1)));
          var maxDate = new Date((/* @__PURE__ */ new Date(+startValueSelected)).setDate(startValueSelected.getDate() + (this.maxDays - 1)));
          minDate = !isNullOrUndefined(this.minDays) && this.minDays > 0 ? minDate : null;
          maxDate = !isNullOrUndefined(this.maxDays) && this.maxDays > 0 ? maxDate : null;
          if (this.currentView() === "Year") {
            minDate = isNullOrUndefined(minDate) ? null : new Date(minDate.getFullYear(), minDate.getMonth(), 0);
            maxDate = isNullOrUndefined(maxDate) ? null : new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);
          } else if (this.currentView() === "Decade") {
            minDate = isNullOrUndefined(minDate) ? null : new Date(minDate.getFullYear() - 1, 11, 1);
            maxDate = isNullOrUndefined(maxDate) ? null : new Date(maxDate.getFullYear(), 0, 1);
          }
          var tdCells = calendar.querySelectorAll("." + CALENDAR + " td");
          var maxEle = void 0;
          for (var _i = 0, tdCells_6 = tdCells; _i < tdCells_6.length; _i++) {
            var ele = tdCells_6[_i];
            if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(WEEKNUMBER2)) {
              var eleDate = this.getIdValue(null, ele);
              eleDate = this.removeTimeValueFromDate(eleDate);
              if (!isNullOrUndefined(minDate) && +eleDate === +minDate && ele.classList.contains(DISABLED2)) {
                minDate.setDate(minDate.getDate() + 1);
              }
              if (!ele.classList.contains(DISABLED2)) {
                if (+eleDate <= +startValueSelected) {
                  continue;
                }
                if (!isNullOrUndefined(minDate) && +eleDate < +minDate) {
                  addClass([ele], [DATEDISABLED, DISABLED2, OVERLAY2]);
                  EventHandler.clearEvents(ele);
                }
                if (!isNullOrUndefined(maxDate) && +eleDate > +maxDate) {
                  addClass([ele], [DATEDISABLED, DISABLED2, OVERLAY2]);
                  this.isMaxDaysClicked = true;
                  EventHandler.clearEvents(ele);
                  if (isNullOrUndefined(maxEle) && !ele.classList.contains(OTHERMONTH2)) {
                    maxEle = ele;
                  }
                }
              }
            }
          }
          if (!isNullOrUndefined(maxEle)) {
            if (this.isMobile) {
              if (!this.nextIcon.classList.contains(DISABLED2)) {
                addClass([this.nextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
              }
            } else {
              var calendar_1 = closest(maxEle, "." + RIGHTCALENDER);
              calendar_1 = isNullOrUndefined(calendar_1) ? this.leftCalendar : calendar_1;
              var isLeftCalendar = calendar_1.classList.contains(LEFTCALENDER);
              if (!isLeftCalendar) {
                if (!this.rightCalNextIcon.classList.contains(DISABLED2)) {
                  addClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
                }
              } else {
                if (!this.rightCalNextIcon.classList.contains(DISABLED2)) {
                  addClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
                }
                if (!this.leftCalNextIcon.classList.contains(DISABLED2)) {
                  addClass([this.leftCalNextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
                }
                if (!this.rightCalPrevIcon.classList.contains(DISABLED2)) {
                  addClass([this.rightCalPrevIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
                }
              }
            }
          }
        }
      } else {
        this.isMaxDaysClicked = false;
      }
    };
    DateRangePicker2.prototype.removeTimeValueFromDate = function(value) {
      var dateValue = new Date(value.getFullYear(), value.getMonth(), value.getDate());
      return dateValue;
    };
    DateRangePicker2.prototype.removeClassDisabled = function() {
      var tdCells = this.popupObj.element.querySelectorAll("." + CALENDAR + " td." + DATEDISABLED);
      for (var _i = 0, tdCells_7 = tdCells; _i < tdCells_7.length; _i++) {
        var ele = tdCells_7[_i];
        if (ele.classList.contains(DATEDISABLED)) {
          removeClass([ele], [DATEDISABLED, DISABLED2, OVERLAY2]);
          EventHandler.add(ele, "click", this.selectRange, this);
          if (!this.isMobile) {
            EventHandler.add(ele, "mouseover", this.hoverSelection, this);
          }
        }
      }
      if (this.isMobile) {
        if (this.nextIcon.classList.contains(ICONDISABLED)) {
          removeClass([this.nextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
        }
        if (this.previousIcon.classList.contains(ICONDISABLED)) {
          removeClass([this.previousIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
        }
      } else {
        if (this.rightCalNextIcon.classList.contains(ICONDISABLED)) {
          removeClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
        }
        if (this.rightCalPrevIcon.classList.contains(ICONDISABLED)) {
          removeClass([this.rightCalPrevIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
        }
        if (this.leftCalNextIcon.classList.contains(ICONDISABLED)) {
          removeClass([this.leftCalNextIcon], [ICONDISABLED, DISABLED2, OVERLAY2]);
        }
      }
    };
    DateRangePicker2.prototype.updateHeader = function() {
      var format = { type: "date", skeleton: "yMMMd" };
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
        var range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1e3 * 60 * 60 * 24))) + 1;
        if (!isNullOrUndefined(this.disabledDayCnt)) {
          range = range - this.disabledDayCnt;
          this.disabledDayCnt = null;
        }
        this.popupObj.element.querySelector("." + DAYSPAN).textContent = range.toString() + " " + this.l10n.getConstant("days");
      } else {
        this.popupObj.element.querySelector("." + DAYSPAN).textContent = this.l10n.getConstant("selectedDays");
      }
      if (!this.isMobile) {
        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
          this.popupObj.element.querySelector("." + ENDLABEL).textContent = this.globalize.formatDate(this.endValue, format);
        } else {
          this.popupObj.element.querySelector("." + ENDLABEL).textContent = this.l10n.getConstant("endLabel");
        }
        if (!isNullOrUndefined(this.startValue)) {
          this.popupObj.element.querySelector("." + STARTLABEL).textContent = this.globalize.formatDate(this.startValue, format);
        } else {
          this.popupObj.element.querySelector("." + STARTLABEL).textContent = this.l10n.getConstant("startLabel");
        }
      } else {
        if (!isNullOrUndefined(this.startValue)) {
          this.startButton.element.textContent = this.globalize.formatDate(this.startValue, format);
        } else {
          this.startButton.element.textContent = this.l10n.getConstant("startLabel");
        }
        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
          this.endButton.element.textContent = this.globalize.formatDate(this.endValue, format);
        } else {
          this.endButton.element.textContent = this.l10n.getConstant("endLabel");
        }
      }
      if (this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue) || (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue)) {
        if (!this.isMobile) {
          this.popupObj.element.querySelector("." + DAYSPAN).textContent = this.l10n.getConstant("selectedDays");
          this.popupObj.element.querySelector("." + STARTLABEL).textContent = this.l10n.getConstant("startLabel");
          this.popupObj.element.querySelector("." + ENDLABEL).textContent = this.l10n.getConstant("endLabel");
        } else {
          this.startButton.element.textContent = this.l10n.getConstant("startLabel");
          this.endButton.element.textContent = this.l10n.getConstant("endLabel");
          this.popupObj.element.querySelector("." + DAYSPAN).textContent = this.l10n.getConstant("selectedDays");
        }
      }
      if (this.popupObj.element.querySelector("#custom_range")) {
        this.popupObj.element.querySelector("#custom_range").textContent = this.l10n.getConstant("customRange") !== "" ? this.l10n.getConstant("customRange") : "Custom Range";
      }
    };
    DateRangePicker2.prototype.removeSelection = function() {
      this.startValue = null;
      this.endValue = null;
      this.setValue();
      this.removeSelectedAttributes();
      if (this.popupObj) {
        if (this.popupObj.element.querySelectorAll("." + SELECTED3).length > 0) {
          removeClass(this.popupObj.element.querySelectorAll("." + SELECTED3), [STARTDATE, ENDDATE, SELECTED3]);
        }
        if (this.popupObj.element.querySelectorAll("." + FOCUSDATE).length > 0) {
          removeClass(this.popupObj.element.querySelectorAll("." + FOCUSDATE), FOCUSDATE);
        }
        if (this.popupObj.element.querySelectorAll("." + RANGEHOVER).length > 0) {
          removeClass(this.popupObj.element.querySelectorAll("." + RANGEHOVER), [RANGEHOVER]);
        }
      }
    };
    DateRangePicker2.prototype.addSelectedAttributes = function(ele, date, isStartDate, sameDate) {
      if (ele) {
        var title = this.globalize.formatDate(date, { type: "date", skeleton: "full" });
        if (!isNullOrUndefined(sameDate) && sameDate) {
          ele.setAttribute("aria-label", "The current start and end date is " + title);
        } else {
          ele.setAttribute("aria-label", "The current " + (isStartDate ? "start" : "end") + " date is " + title);
        }
        ele.setAttribute("aria-selected", "true");
      }
    };
    DateRangePicker2.prototype.removeSelectedAttributes = function() {
      if (this.popupObj) {
        var start = this.popupObj.element.querySelectorAll("." + STARTDATE);
        for (var _i = 0, start_1 = start; _i < start_1.length; _i++) {
          var ele = start_1[_i];
          ele.setAttribute("aria-selected", "false");
          ele.removeAttribute("aria-label");
        }
        var end = this.popupObj.element.querySelectorAll("." + ENDDATE);
        for (var _a = 0, end_1 = end; _a < end_1.length; _a++) {
          var ele = end_1[_a];
          ele.setAttribute("aria-selected", "false");
          ele.removeAttribute("aria-label");
        }
      }
    };
    DateRangePicker2.prototype.updateCalendarElement = function(calendar) {
      if (calendar.classList.contains(LEFTCALENDER)) {
        this.calendarElement = this.leftCalendar;
        this.currentDate = this.leftCalCurrentDate;
        this.previousIcon = this.leftCalPrevIcon;
        this.nextIcon = this.leftCalNextIcon;
      } else {
        this.calendarElement = this.rightCalendar;
        this.currentDate = this.rightCalCurrentDate;
        this.previousIcon = this.rightCalPrevIcon;
        this.nextIcon = this.rightCalNextIcon;
      }
      this.contentElement = calendar.querySelector("." + CONTENT2);
      this.tableBodyElement = select("." + CONTENT2 + " tbody", calendar);
      this.table = calendar.querySelector("." + CONTENT2).getElementsByTagName("table")[0];
      this.headerTitleElement = calendar.querySelector("." + HEADER2 + " ." + TITLE2);
      this.headerElement = calendar.querySelector("." + HEADER2);
    };
    DateRangePicker2.prototype.navPrevMonth = function(e) {
      e.preventDefault();
      var ele = closest(e.target, "." + LEFTCALENDER);
      ele = isNullOrUndefined(ele) ? closest(e.target, "." + RIGHTCALENDER) : ele;
      this.updateCalendarElement(ele);
      this.navigatePrevious(e);
      if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
        this.updateMinMaxDays(ele);
      }
      this.updateControl(ele);
    };
    DateRangePicker2.prototype.deviceNavigation = function(ele) {
      this.deviceCalendarEvent();
      this.updateRange([this.popupObj.element.querySelector("." + CALENDAR)]);
      if (this.endButton.element.classList.contains(ACTIVE2)) {
        this.updateMinMaxDays(this.popupObj.element.querySelector("." + CALENDAR));
      }
      if (this.endButton.element.classList.contains(ACTIVE2)) {
        this.selectableDates();
      }
      if (this.currentView() === this.depth) {
        this.bindCalendarCellEvents();
      }
      this.removeFocusedDate();
    };
    DateRangePicker2.prototype.updateControl = function(calendar) {
      if (calendar.classList.contains(RIGHTCALENDER)) {
        this.rightCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
      } else {
        this.leftCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
      }
      this.calendarIconEvent();
      if (this.depth === "Month" && this.leftCalendar.querySelector(".e-content").classList.contains("e-month") && this.rightCalendar.querySelector(".e-content").classList.contains("e-month") || this.depth === "Year" && this.leftCalendar.querySelector(".e-content").classList.contains("e-year") && this.rightCalendar.querySelector(".e-content").classList.contains("e-year") || this.depth === "Decade" && this.leftCalendar.querySelector(".e-content").classList.contains("e-decade") && this.rightCalendar.querySelector(".e-content").classList.contains("e-decade") || this.isMobile) {
        this.bindCalendarCellEvents();
      }
      this.removeFocusedDate();
      this.updateRange([calendar]);
    };
    DateRangePicker2.prototype.navNextMonth = function(event) {
      event.preventDefault();
      var ele = closest(event.target, "." + LEFTCALENDER);
      ele = isNullOrUndefined(ele) ? closest(event.target, "." + RIGHTCALENDER) : ele;
      this.updateCalendarElement(ele);
      this.navigateNext(event);
      if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
        this.updateMinMaxDays(ele);
      }
      this.updateControl(ele);
    };
    DateRangePicker2.prototype.isPopupOpen = function() {
      if (!isNullOrUndefined(this.popupObj) && this.popupObj.element.classList.contains(POPUP2)) {
        return true;
      }
      return false;
    };
    DateRangePicker2.prototype.createRangeHeader = function() {
      var labelContainer = this.createElement("div", { className: STARTENDCONTAINER });
      if (!this.isMobile) {
        var startLabel = this.createElement("a", { className: STARTLABEL });
        var endLabel = this.createElement("a", { className: ENDLABEL });
        var changeIcon = this.createElement("span", { className: CHANGEICON });
        attributes(startLabel, { "aria-atomic": "true", "aria-live": "assertive", "aria-label": "Start Date", "role": "button" });
        attributes(endLabel, { "aria-atomic": "true", "aria-live": "assertive", "aria-label": "End Date", "role": "button" });
        labelContainer.appendChild(startLabel);
        labelContainer.appendChild(changeIcon);
        labelContainer.appendChild(endLabel);
        startLabel.textContent = this.l10n.getConstant("startLabel");
        endLabel.textContent = this.l10n.getConstant("endLabel");
      } else {
        var endBtn = this.createElement("button", { className: ENDBUTTON });
        var startBtn = this.createElement("button", { className: STARTBUTTON });
        this.startButton = new Button({ content: this.l10n.getConstant("startLabel") }, startBtn);
        this.endButton = new Button({ content: this.l10n.getConstant("endLabel") }, endBtn);
        labelContainer.appendChild(startBtn);
        labelContainer.appendChild(endBtn);
      }
      return labelContainer;
    };
    DateRangePicker2.prototype.disableInput = function() {
      if (this.strictMode) {
        if (!isNullOrUndefined(this.previousStartValue) && !isNullOrUndefined(this.previousEndValue)) {
          this.startValue = this.previousStartValue;
          this.endValue = this.previousEndValue;
          this.setValue();
          this.updateInput();
        }
      } else {
        this.updateInput();
        this.clearRange();
        this.setProperties({ startDate: null }, true);
        this.setProperties({ endDate: null }, true);
        this.startValue = null;
        this.endValue = null;
        this.setValue();
        this.errorClass();
      }
      this.setProperties({ enabled: false }, true);
      Input.setEnabled(this.enabled, this.inputElement);
      this.bindEvents();
    };
    DateRangePicker2.prototype.validateMinMax = function() {
      this.min = isNullOrUndefined(this.min) || !+this.min ? this.min = new Date(1900, 0, 1) : this.min;
      this.max = isNullOrUndefined(this.max) || !+this.max ? this.max = new Date(2099, 11, 31) : this.max;
      if (!(this.min <= this.max)) {
        this.disableInput();
        return;
      }
      if (!isNullOrUndefined(this.minDays) && !isNullOrUndefined(this.maxDays)) {
        if (this.maxDays > 0 && this.minDays > 0 && this.minDays > this.maxDays) {
          this.maxDays = null;
        }
      }
      if (!isNullOrUndefined(this.minDays) && this.minDays < 0) {
        this.minDays = null;
      }
      if (!isNullOrUndefined(this.maxDays) && this.maxDays < 0) {
        this.maxDays = null;
      }
    };
    DateRangePicker2.prototype.validateRangeStrict = function() {
      if (!isNullOrUndefined(this.startValue)) {
        if (+this.startValue <= +this.min) {
          this.startValue = this.min;
          this.setValue();
        } else if (+this.startValue >= +this.min && +this.startValue >= +this.max) {
          this.startValue = this.max;
        }
      }
      if (!isNullOrUndefined(this.endValue)) {
        if (+this.endValue > +this.max) {
          this.endValue = this.max;
          this.setValue();
        } else if (+this.endValue < +this.min) {
          this.endValue = this.min;
          this.setValue();
        }
      }
      this.validateMinMaxDays();
    };
    DateRangePicker2.prototype.validateRange = function() {
      this.validateMinMaxDays();
    };
    DateRangePicker2.prototype.validateMinMaxDays = function() {
      if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
        var range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1e3 * 60 * 60 * 24))) + 1;
        if (!isNullOrUndefined(this.minDays) && this.minDays > 0 && !(range >= this.minDays)) {
          if (this.strictMode) {
            var date = /* @__PURE__ */ new Date(+this.startValue);
            date.setDate(date.getDate() + (this.minDays - 1));
            if (+date > +this.max) {
              this.endValue = this.max;
              this.setValue();
            } else {
              this.endValue = date;
              this.setValue();
            }
          } else {
            this.startValue = null;
            this.endValue = null;
            this.setValue();
          }
        }
        if (!isNullOrUndefined(this.maxDays) && this.maxDays > 0 && !(range <= this.maxDays)) {
          if (this.strictMode) {
            this.endValue = /* @__PURE__ */ new Date(+this.startValue);
            this.endValue.setDate(this.endValue.getDate() + (this.maxDays - 1));
            this.setValue();
          } else {
            this.startValue = null;
            this.endValue = null;
            this.setValue();
          }
        }
      }
    };
    DateRangePicker2.prototype.renderCalendar = function() {
      this.calendarElement = this.createElement("div");
      this.calendarElement.classList.add(CALENDAR);
      if (this.enableRtl) {
        this.calendarElement.classList.add(RTL2);
      }
      attributes(this.calendarElement, { "role": "calendar" });
      _super.prototype.createHeader.call(this);
      _super.prototype.createContent.call(this);
    };
    DateRangePicker2.prototype.isSameMonth = function(start, end) {
      if (start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear()) {
        return true;
      }
      return false;
    };
    DateRangePicker2.prototype.isSameYear = function(start, end) {
      if (start.getFullYear() === end.getFullYear()) {
        return true;
      }
      return false;
    };
    DateRangePicker2.prototype.isSameDecade = function(start, end) {
      var startYear = start.getFullYear();
      var endYear = end.getFullYear();
      if (startYear - startYear % 10 === endYear - endYear % 10) {
        return true;
      }
      return false;
    };
    DateRangePicker2.prototype.startMonthCurrentDate = function() {
      if (this.isSameMonth(this.min, this.max) || +this.currentDate > +this.max || this.isSameMonth(this.currentDate, this.max)) {
        this.currentDate = /* @__PURE__ */ new Date(+this.max);
        this.currentDate.setDate(1);
        this.currentDate.setMonth(this.currentDate.getMonth() - 1);
      } else if (this.currentDate < this.min) {
        this.currentDate = new Date(this.checkValue(this.min));
      }
    };
    DateRangePicker2.prototype.selectNextMonth = function() {
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameMonth(this.endValue, this.currentDate) && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {
        this.currentDate = /* @__PURE__ */ new Date(+this.endValue);
      } else {
        this.currentDate.setDate(1);
        this.currentDate.setMonth(this.currentDate.getMonth() + 1);
        return;
      }
      if (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue) {
        this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        this.currentDate.setDate(1);
        var month = this.currentDate.getMonth() + 1;
        this.currentDate.setMonth(month);
      }
    };
    DateRangePicker2.prototype.selectNextYear = function() {
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameYear(this.endValue, this.currentDate) && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {
        this.currentDate = /* @__PURE__ */ new Date(+this.endValue);
      } else {
        this.currentDate.setMonth(0);
        var yr = this.currentDate.getFullYear() + 1;
        this.currentDate.setFullYear(yr);
        return;
      }
      if (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min) {
        this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        this.currentDate.setMonth(0);
        this.currentDate.setFullYear(this.currentDate.getFullYear() + 1);
      }
    };
    DateRangePicker2.prototype.selectNextDecade = function() {
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameDecade(this.endValue, this.currentDate) && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {
        this.currentDate = /* @__PURE__ */ new Date(+this.endValue);
      } else {
        var decyr = this.currentDate.getFullYear() + 10;
        this.currentDate.setFullYear(decyr);
        return;
      }
      if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min) {
        this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        this.currentDate.setFullYear(this.currentDate.getFullYear() + 10);
      }
    };
    DateRangePicker2.prototype.selectStartMonth = function() {
      if (!isNullOrUndefined(this.startValue)) {
        if (!isNullOrUndefined(this.max) && this.isSameMonth(this.startValue, this.max)) {
          this.currentDate = /* @__PURE__ */ new Date(+this.max);
          this.currentDate.setDate(1);
          this.currentDate.setMonth(this.currentDate.getMonth() - 1);
        } else if (!(this.startValue >= this.min && this.startValue <= this.max) || this.isDateDisabled(this.startValue)) {
          this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        } else {
          this.currentDate = /* @__PURE__ */ new Date(+this.startValue);
        }
      } else {
        this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        this.startMonthCurrentDate();
      }
      if (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue) {
        this.currentDate = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      }
      this.startMonthCurrentDate();
    };
    DateRangePicker2.prototype.createCalendar = function() {
      var calendarContainer = this.createElement("div", { className: CALENDARCONTAINER });
      if (!this.isMobile) {
        this.selectStartMonth();
        this.renderCalendar();
        this.leftCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
        this.calendarElement.classList.add(LEFTCALENDER);
        this.leftCalPrevIcon = this.calendarElement.querySelector("." + LEFTCALENDER + " ." + PREVICON2);
        this.leftCalNextIcon = this.calendarElement.querySelector("." + LEFTCALENDER + " ." + NEXTICON2);
        this.leftTitle = this.calendarElement.querySelector("." + LEFTCALENDER + " ." + TITLE2);
        remove(this.calendarElement.querySelector("." + LEFTCALENDER + " ." + ICONCONTAINER2));
        this.calendarElement.querySelector("." + LEFTCALENDER + " ." + HEADER2).appendChild(this.leftCalNextIcon);
        this.calendarElement.querySelector("." + LEFTCALENDER + " ." + HEADER2).appendChild(this.leftCalPrevIcon);
        prepend([this.leftCalPrevIcon], this.calendarElement.querySelector("." + LEFTCALENDER + " ." + HEADER2));
        this.leftCalendar = this.calendarElement;
        var leftContainer = this.createElement("div", { className: LEFTCONTAINER });
        var rightContainer = this.createElement("div", { className: RIGHTCONTAINER });
        leftContainer.appendChild(this.leftCalendar);
        calendarContainer.appendChild(leftContainer);
        if (!this.isMobile) {
          EventHandler.add(this.leftTitle, "click", this.leftNavTitle, this);
        }
        if (this.start === "Month") {
          this.selectNextMonth();
        }
        if (this.start === "Year") {
          this.selectNextYear();
        }
        if (this.start === "Decade") {
          this.selectNextDecade();
        }
        this.renderCalendar();
        this.rightCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
        addClass([this.calendarElement], RIGHTCALENDER);
        this.rightCalendar = this.calendarElement;
        removeClass([this.leftCalendar && this.leftCalendar.querySelector(".e-content tbody")], "e-zoomin");
        removeClass([this.rightCalendar && this.rightCalendar.querySelector(".e-content tbody")], "e-zoomin");
        this.rightCalPrevIcon = this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + PREVICON2);
        this.rightCalNextIcon = this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + NEXTICON2);
        this.rightTitle = this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + TITLE2);
        remove(this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + ICONCONTAINER2));
        this.calendarElement.querySelector("table").setAttribute("tabindex", "-1");
        this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + HEADER2).appendChild(this.rightCalNextIcon);
        this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + HEADER2).appendChild(this.rightCalPrevIcon);
        prepend([this.rightCalPrevIcon], this.calendarElement.querySelector("." + RIGHTCALENDER + " ." + HEADER2));
        rightContainer.appendChild(this.rightCalendar);
        calendarContainer.appendChild(rightContainer);
        if (!this.isMobile) {
          EventHandler.add(this.rightTitle, "click", this.rightNavTitle, this);
        }
      } else {
        if (!isNullOrUndefined(this.startValue)) {
          this.currentDate = /* @__PURE__ */ new Date(+this.startValue);
        }
        _super.prototype.validateDate.call(this);
        _super.prototype.minMaxUpdate.call(this);
        _super.prototype.render.call(this);
        var prevIcon = this.calendarElement.querySelector("." + CALENDAR + " ." + PREVICON2);
        var nextIcon = this.calendarElement.querySelector("." + CALENDAR + " ." + NEXTICON2);
        remove(this.calendarElement.querySelector("." + CALENDAR + " ." + ICONCONTAINER2));
        this.calendarElement.querySelector("." + CALENDAR + " ." + HEADER2).appendChild(nextIcon);
        this.calendarElement.querySelector("." + CALENDAR + " ." + HEADER2).appendChild(prevIcon);
        prepend([prevIcon], this.calendarElement.querySelector("." + CALENDAR + " ." + HEADER2));
        this.deviceCalendar = this.calendarElement;
        calendarContainer.appendChild(this.calendarElement);
        this.headerTitleElement = this.calendarElement.querySelector("." + CALENDAR + " ." + HEADER2 + " ." + TITLE2);
      }
      return calendarContainer;
    };
    DateRangePicker2.prototype.leftNavTitle = function(e) {
      if (this.isPopupOpen()) {
        this.calendarElement = this.leftCalendar;
        this.calendarNavigation(e, this.calendarElement);
      }
    };
    DateRangePicker2.prototype.calendarNavigation = function(e, element) {
      this.table = element.querySelector("table");
      this.headerTitleElement = element.querySelector(".e-title");
      this.tableBodyElement = element.querySelector("tbody");
      this.tableHeadElement = element.querySelector("thead");
      this.contentElement = element.querySelector(".e-content");
      this.updateCalendarElement(element);
      _super.prototype.navigateTitle.call(this, e);
      this.updateNavIcons();
    };
    DateRangePicker2.prototype.rightNavTitle = function(e) {
      if (this.isPopupOpen()) {
        this.calendarElement = this.rightCalendar;
        this.calendarNavigation(e, this.calendarElement);
      }
    };
    DateRangePicker2.prototype.clickEventEmitter = function(e) {
      if (!this.isMobile) {
        if (closest(e.target, ".e-calendar.e-left-calendar")) {
          this.calendarElement = this.leftCalendar;
          this.updateCalendarElement(this.leftCalendar);
        } else {
          this.calendarElement = this.rightCalendar;
          this.updateCalendarElement(this.rightCalendar);
        }
      }
    };
    DateRangePicker2.prototype.currentView = function() {
      return _super.prototype.currentView.call(this);
    };
    DateRangePicker2.prototype.getCalendarView = function(view) {
      if (view === "Year") {
        return "Year";
      } else if (view === "Decade") {
        return "Decade";
      } else {
        return "Month";
      }
    };
    DateRangePicker2.prototype.navigatedEvent = function(e) {
      this.trigger("navigated", this.navigatedArgs);
      if (!isNullOrUndefined(this.popupObj)) {
        var element = void 0;
        var view = this.getCalendarView(this.currentView());
        if (this.isMobile) {
          if (view === this.depth) {
            this.bindCalendarCellEvents();
            this.deviceNavigation();
            this.removeFocusedDate();
            this.checkMinMaxDays();
          } else {
            this.selectableDates();
          }
        } else {
          if (!this.isMobile && view === this.depth) {
            element = this.calendarElement.classList.contains("e-left-calendar") ? this.leftCalendar : this.rightCalendar;
            if (element === this.leftCalendar && (e && !e.currentTarget.children[0].classList.contains("e-icons") || !isNullOrUndefined(this.controlDown))) {
              this.leftCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
              this.effect = "";
              this.currentDate = this.leftCalCurrentDate;
              this.updateCalendarElement(this.leftCalendar);
              this.updateControl(this.leftCalendar);
              this.updateCalendarElement(this.rightCalendar);
              _super.prototype.navigateTo.call(this, view, this.rightCalCurrentDate);
              this.updateControl(this.rightCalendar);
              this.updateNavIcons();
              this.calendarIconEvent();
              this.calendarIconRipple();
              this.controlDown = null;
            } else if (e && !e.currentTarget.children[0].classList.contains("e-icons") || !isNullOrUndefined(this.controlDown)) {
              this.rightCalCurrentDate = /* @__PURE__ */ new Date(+this.currentDate);
              this.effect = "";
              this.currentDate = this.rightCalCurrentDate;
              this.updateCalendarElement(this.rightCalendar);
              this.updateControl(this.rightCalendar);
              this.updateCalendarElement(this.leftCalendar);
              if (this.startValue && isNullOrUndefined(this.endValue)) {
                if (view === "Month" && this.startValue.getMonth() < this.rightCalCurrentDate.getMonth() && this.startValue.getFullYear() <= this.rightCalCurrentDate.getFullYear()) {
                  _super.prototype.navigateTo.call(this, view, /* @__PURE__ */ new Date(+this.startValue));
                } else if (view === "Year" && this.startValue.getFullYear() < this.rightCalCurrentDate.getFullYear()) {
                  _super.prototype.navigateTo.call(this, view, /* @__PURE__ */ new Date(+this.startValue));
                } else {
                  _super.prototype.navigateTo.call(this, view, this.leftCalCurrentDate);
                }
              } else {
                _super.prototype.navigateTo.call(this, view, this.leftCalCurrentDate);
              }
              this.updateControl(this.leftCalendar);
              this.updateNavIcons();
              this.calendarIconEvent();
              this.calendarIconRipple();
              this.controlDown = null;
            }
            this.checkMinMaxDays();
          } else {
            this.updateNavIcons();
            this.calendarIconEvent();
          }
        }
      }
    };
    DateRangePicker2.prototype.createControl = function() {
      var controlContainer = this.createElement("div", { className: RANGECONTAINER });
      var headerContainer = this.createElement("div", { className: RANGEHEADER });
      var labelContainer = this.createRangeHeader();
      headerContainer.appendChild(labelContainer);
      var daySpan = this.createElement("div", { className: DAYSPAN });
      attributes(daySpan, { "aria-label": "Selected Days" });
      daySpan.textContent = this.l10n.getConstant("selectedDays");
      headerContainer.appendChild(daySpan);
      var separator = this.createElement("div", { className: SEPARATOR });
      var calendarContainer = this.createCalendar();
      controlContainer.appendChild(headerContainer);
      controlContainer.appendChild(separator);
      controlContainer.appendChild(calendarContainer);
      var footerSection = this.createElement("div", { className: FOOTER2 });
      var cancelBtn = this.createElement("button", { className: CANCEL + " " + FLAT2 + " " + CSS2 });
      var applyBtn = this.createElement("button");
      addClass([applyBtn], [APPLY, FLAT2, PRIMARY2, CSS2]);
      footerSection.appendChild(applyBtn);
      footerSection.appendChild(cancelBtn);
      var enable = !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue);
      this.cancelButton = new Button({ content: this.l10n.getConstant("cancelText") }, cancelBtn);
      this.applyButton = new Button({ content: this.l10n.getConstant("applyText"), disabled: !enable }, applyBtn);
      EventHandler.add(applyBtn, "click", this.applyFunction, this);
      EventHandler.add(cancelBtn, "click", this.cancelFunction, this);
      this.popupWrapper.appendChild(controlContainer);
      if (!this.isMobile) {
        if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {
          this.createPresets();
          this.listRippleEffect();
          addClass([controlContainer], RANGEBORDER);
          addClass([this.popupWrapper], "e-preset-wrapper");
          var presets = this.popupWrapper.querySelector("." + PRESETS);
          presets.style.height = this.popupWrapper.querySelector("." + RANGECONTAINER).getBoundingClientRect().height + "px";
        }
      }
      this.popupWrapper.appendChild(footerSection);
      if (this.isMobile) {
        this.deviceHeaderUpdate();
      }
      this.renderPopup();
    };
    DateRangePicker2.prototype.cancelFunction = function(eve) {
      if (document.activeElement !== this.inputElement) {
        this.preventFocus = true;
        this.inputElement.focus();
        addClass([this.inputWrapper.container], [INPUTFOCUS2]);
      }
      eve.preventDefault();
      if (this.isKeyPopup) {
        this.inputElement.focus();
        this.isKeyPopup = false;
      }
      this.startValue = null;
      this.endValue = null;
      this.removeSelection();
      this.hide(eve);
    };
    DateRangePicker2.prototype.deviceHeaderUpdate = function() {
      if (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
        this.endButton.element.setAttribute("disabled", "");
        this.startButton.element.classList.add(ACTIVE2);
      } else if (!isNullOrUndefined(this.startValue)) {
        this.startButton.element.classList.add(ACTIVE2);
      }
    };
    DateRangePicker2.prototype.applyFunction = function(eve) {
      var isValueChanged = false;
      if (eve.type !== "touchstart") {
        eve.preventDefault();
      }
      if (this.closeEventArgs && this.closeEventArgs.cancel) {
        this.startValue = this.popupWrapper.querySelector(".e-start-date") && this.getIdValue(null, this.popupWrapper.querySelector(".e-start-date"));
        this.endValue = this.popupWrapper.querySelector(".e-end-date") && this.getIdValue(null, this.popupWrapper.querySelector(".e-end-date"));
        this.setValue();
      }
      if (document.activeElement !== this.inputElement) {
        this.preventFocus = true;
        this.inputElement.focus();
        addClass([this.inputWrapper.container], [INPUTFOCUS2]);
      }
      if (eve.type !== "touchstart" && this.closeEventArgs && !this.closeEventArgs.cancel) {
        eve.preventDefault();
      }
      if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
        this.previousStartValue = /* @__PURE__ */ new Date(+this.startValue);
        this.previousEndValue = /* @__PURE__ */ new Date(+this.endValue);
        this.previousEleValue = this.inputElement.value;
        Input.setValue(this.rangeArgs(eve).text, this.inputElement, this.floatLabelType, this.showClearButton);
        if (+this.initStartDate !== +this.startValue || +this.initEndDate !== +this.endValue) {
          isValueChanged = true;
        }
        this.changeTrigger(eve);
        this.hide(eve ? eve : null);
        this.errorClass();
        isValueChanged = true;
      } else {
        this.hide(eve ? eve : null);
      }
      if (!closest(eve.target, "." + INPUTCONTAINER2) && !isValueChanged) {
        this.focusOut();
      }
      if (!this.isMobile) {
        this.isKeyPopup = false;
        if (this.isRangeIconClicked) {
          this.inputWrapper.container.children[1].focus();
          this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);
          this.popupKeyboardModule = new KeyboardEvents(this.inputWrapper.container.children[1], {
            eventName: "keydown",
            keyConfigs: this.keyInputConfigs,
            keyAction: this.popupKeyActionHandle.bind(this)
          });
        }
      }
    };
    DateRangePicker2.prototype.onMouseClick = function(event, item) {
      if (event.type === "touchstart") {
        return;
      }
      var target = item || event.target;
      var li = closest(target, "." + LISTCLASS);
      var isClick = li && li.classList.contains(ACTIVE2);
      if (li && li.classList.contains(LISTCLASS)) {
        this.setListSelection(li, event);
      }
      this.preventFocus = true;
      this.inputElement.focus();
      if (!this.isMobile) {
        this.preventFocus = true;
        if (li && li.classList.contains(LISTCLASS) && li.getAttribute("id") === "custom_range") {
          this.leftCalendar.children[1].firstElementChild.focus();
        } else {
          if (!isClick && event.type === "keydown") {
            this.inputElement.focus();
          }
        }
      }
    };
    DateRangePicker2.prototype.onMouseOver = function(event) {
      var li = closest(event.target, "." + LISTCLASS);
      if (li && li.classList.contains(LISTCLASS) && !li.classList.contains(HOVER)) {
        addClass([li], HOVER);
      }
    };
    DateRangePicker2.prototype.onMouseLeave = function(event) {
      var item = closest(event.target, "." + HOVER);
      if (!isNullOrUndefined(item)) {
        removeClass([item], HOVER);
      }
    };
    DateRangePicker2.prototype.setListSelection = function(li, event) {
      if (li && (!li.classList.contains(ACTIVE2) || this.isMobile && li.classList.contains(ACTIVE2))) {
        if (this.isMobile && li.classList.contains(ACTIVE2)) {
          this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);
          var values_1 = this.presetsItem[this.activeIndex];
          if (values_1.id === "custom_range") {
            this.renderCustomPopup();
            return;
          }
          return;
        }
        this.removeListSelection();
        this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);
        addClass([li], ACTIVE2);
        li.setAttribute("aria-selected", "true");
        var values = this.presetsItem[this.activeIndex];
        if (values.id === "custom_range") {
          this.renderCustomPopup();
        } else {
          this.applyPresetRange(values, event);
        }
      }
    };
    DateRangePicker2.prototype.removeListSelection = function() {
      var item = this.presetElement.querySelector("." + ACTIVE2);
      if (!isNullOrUndefined(item)) {
        removeClass([item], ACTIVE2);
        item.removeAttribute("aria-selected");
      }
    };
    DateRangePicker2.prototype.setValue = function() {
      this.modelValue = [this.startValue, this.endValue];
    };
    DateRangePicker2.prototype.applyPresetRange = function(values, e) {
      this.hide(null);
      this.presetsItem[this.presetsItem.length - 1].start = null;
      this.presetsItem[this.presetsItem.length - 1].end = null;
      this.startValue = values.start;
      this.endValue = values.end;
      this.setValue();
      this.refreshControl();
      this.trigger("select", this.rangeArgs(e));
      this.changeTrigger(e);
      this.previousEleValue = this.inputElement.value;
      this.isCustomRange = false;
      this.leftCalendar = this.rightCalendar = null;
      if (this.isKeyPopup) {
        this.isRangeIconClicked = false;
        this.inputElement.focus();
      }
    };
    DateRangePicker2.prototype.showPopup = function(element, event) {
      this.presetHeight();
      if (this.zIndex === 1e3) {
        this.popupObj.show(null, this.element);
      } else {
        this.popupObj.show(null, null);
      }
      if (this.isMobile) {
        this.popupObj.refreshPosition();
      }
    };
    DateRangePicker2.prototype.renderCustomPopup = function() {
      this.isCustomWindow = true;
      this.popupObj.hide();
      this.popupWrapper = this.createElement("div", { id: this.element.id + "_popup", className: ROOT3 + " " + POPUP2 });
      this.renderControl();
      this.openEventArgs.appendTo.appendChild(this.popupWrapper);
      this.showPopup();
      this.isCustomRange = true;
      if (!this.isMobile) {
        this.calendarFocus();
      }
    };
    DateRangePicker2.prototype.listRippleEffect = function() {
      for (var _i = 0, _a = this.liCollections; _i < _a.length; _i++) {
        var li = _a[_i];
        rippleEffect(li);
      }
    };
    DateRangePicker2.prototype.createPresets = function() {
      if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {
        this.presetElement = this.createElement("div", { className: PRESETS, attrs: { "tabindex": "0" } });
        var listTag = ListBase.createList(this.createElement, this.presetsItem, null, true);
        attributes(listTag, { "role": "listbox", "aria-hidden": "false", "id": this.element.id + "_options" });
        this.presetElement.appendChild(listTag);
        this.popupWrapper.appendChild(this.presetElement);
        var customElement = this.presetElement.querySelector("#custom_range");
        if (!isNullOrUndefined(customElement)) {
          customElement.textContent = this.l10n.getConstant("customRange") !== "" ? this.l10n.getConstant("customRange") : "Custom Range";
        }
        this.liCollections = this.presetElement.querySelectorAll("." + LISTCLASS);
        this.wireListEvents();
        if (this.isMobile) {
          this.presetElement.style.width = this.inputWrapper.container.getBoundingClientRect().width + "px";
        }
        if (!isNullOrUndefined(this.activeIndex) && this.activeIndex > -1) {
          addClass([this.liCollections[this.activeIndex]], ACTIVE2);
        }
      }
    };
    DateRangePicker2.prototype.wireListEvents = function() {
      EventHandler.add(this.presetElement, "click", this.onMouseClick, this);
      if (!this.isMobile) {
        EventHandler.add(this.presetElement, "mouseover", this.onMouseOver, this);
        EventHandler.add(this.presetElement, "mouseout", this.onMouseLeave, this);
      }
    };
    DateRangePicker2.prototype.unWireListEvents = function() {
      if (!isNullOrUndefined(this.presetElement)) {
        EventHandler.remove(this.presetElement, "click touchstart", this.onMouseClick);
        if (!this.isMobile) {
          EventHandler.remove(this.presetElement, "mouseover", this.onMouseOver);
          EventHandler.remove(this.presetElement, "mouseout", this.onMouseLeave);
        }
      }
    };
    DateRangePicker2.prototype.renderPopup = function() {
      var _this = this;
      this.popupWrapper.classList.add("e-control");
      var popupWidth = this.popupWrapper.getBoundingClientRect().width;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass.trim() !== "") {
        this.popupWrapper.className += " " + this.cssClass;
      }
      if (this.isMobile && this.isCustomWindow) {
        this.modal = this.createElement("div");
        document.body.appendChild(this.modal);
      }
      this.popupObj = new Popup(this.popupWrapper, {
        relateTo: this.isMobile && this.isCustomWindow ? document.body : !isNullOrUndefined(this.targetElement) ? this.targetElement : this.inputWrapper.container,
        position: this.isMobile ? !isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && !this.isCustomWindow ? { X: "left", Y: "bottom" } : { X: "center", Y: "center" } : this.enableRtl ? { X: "left", Y: "bottom" } : { X: "right", Y: "bottom" },
        offsetX: this.isMobile || this.enableRtl ? 0 : -popupWidth,
        offsetY: OFFSETVALUE2,
        collision: this.isMobile ? !isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && !this.isCustomWindow ? { X: "fit" } : { X: "fit", Y: "fit" } : { X: "fit", Y: "flip" },
        targetType: this.isMobile && this.isCustomWindow ? "container" : "relative",
        enableRtl: this.enableRtl,
        zIndex: this.zIndex,
        open: function() {
          attributes(_this.inputElement, { "aria-expanded": "true" });
          addClass([_this.inputWrapper.buttons[0]], ACTIVE2);
          if (!_this.isMobile) {
            if (_this.cancelButton) {
              _this.btnKeyboardModule = new KeyboardEvents(_this.cancelButton.element, {
                eventName: "keydown",
                keyAction: _this.popupKeyActionHandle.bind(_this),
                keyConfigs: { tab: "tab", altRightArrow: "alt+rightarrow", altLeftArrow: "alt+leftarrow" }
              });
              _this.btnKeyboardModule = new KeyboardEvents(_this.applyButton.element, {
                eventName: "keydown",
                keyAction: _this.popupKeyActionHandle.bind(_this),
                keyConfigs: { altRightArrow: "alt+rightarrow", altLeftArrow: "alt+leftarrow" }
              });
            }
            if (!isNullOrUndefined(_this.leftCalendar)) {
              if (!_this.isRangeIconClicked) {
                _this.calendarFocus();
              }
            }
            if (!isNullOrUndefined(_this.presetElement)) {
              _this.keyInputConfigs = extend(_this.keyInputConfigs, _this.keyConfigs);
              _this.presetKeyboardModule = new KeyboardEvents(_this.presetElement, {
                eventName: "keydown",
                keyAction: _this.presetKeyActionHandler.bind(_this),
                keyConfigs: _this.keyInputConfigs
              });
              _this.presetKeyboardModule = new KeyboardEvents(_this.presetElement, {
                eventName: "keydown",
                keyAction: _this.popupKeyActionHandle.bind(_this),
                keyConfigs: { altRightArrow: "alt+rightarrow", altLeftArrow: "alt+leftarrow" }
              });
              if (isNullOrUndefined(_this.leftCalendar)) {
                _this.preventBlur = true;
                _this.presetElement.focus();
              } else {
                _this.presetElement.setAttribute("tabindex", "-1");
              }
            }
            _this.popupKeyBoardHandler();
          }
          if (_this.isMobile && !Browser.isDevice) {
            EventHandler.add(document, "keydown", _this.popupCloseHandler, _this);
          }
        },
        close: function() {
          attributes(_this.inputElement, { "aria-expanded": "false" });
          removeClass([_this.inputWrapper.buttons[0]], ACTIVE2);
          if (_this.isRangeIconClicked) {
            _this.inputWrapper.container.children[1].focus();
          }
          if (!isUndefined(_this.presets[0].start && _this.presets[0].end && _this.presets[0].label)) {
            _this.unWireListEvents();
          }
          if (!isNullOrUndefined(_this.popupObj)) {
            if (!isNullOrUndefined(_this.popupObj.element.parentElement)) {
              detach(_this.popupObj.element);
            }
            _this.popupObj.destroy();
            _this.popupObj = null;
          }
          if (_this.isMobile && !Browser.isDevice) {
            EventHandler.remove(document, "keydown", _this.popupCloseHandler);
          }
        },
        targetExitViewport: function() {
          if (!Browser.isDevice) {
            _this.hide();
          }
        }
      });
      if (this.isMobile) {
        this.popupObj.element.classList.add(DEVICE2);
        if (!this.isMobile) {
          this.popupObj.element.classList.add("e-bigger");
        }
      }
      if (this.isMobile && this.isCustomWindow) {
        addClass([this.modal], [DEVICE2, ROOT3, "e-range-modal"]);
        document.body.className += " " + OVERFLOW2;
        this.modal.style.display = "block";
      }
      EventHandler.add(document, "mousedown touchstart", this.documentHandler, this);
    };
    DateRangePicker2.prototype.popupCloseHandler = function(e) {
      switch (e.keyCode) {
        case 27:
          this.hide(e);
          break;
      }
    };
    DateRangePicker2.prototype.calendarFocus = function() {
      var startDate = this.popupObj && this.popupObj.element.querySelector("." + STARTDATE);
      if (startDate) {
        var ele = closest(startDate, "." + RIGHTCALENDER);
        ele = isNullOrUndefined(ele) ? this.leftCalendar : ele;
        if (this.isRangeIconClicked) {
          this.inputWrapper.container.focus();
        } else {
          this.preventBlur = true;
          ele.children[1].firstElementChild.focus();
        }
        addClass([startDate], FOCUSDATE);
      } else {
        if (this.isRangeIconClicked) {
          this.inputWrapper.container.focus();
        } else {
          this.preventBlur = true;
          this.leftCalendar.children[1].firstElementChild.focus();
        }
      }
    };
    DateRangePicker2.prototype.presetHeight = function() {
      var presets = this.popupObj && this.popupObj.element.querySelector("." + PRESETS);
      var rangeContainer = this.popupObj && this.popupObj.element.querySelector("." + RANGECONTAINER);
      if (!isNullOrUndefined(presets) && !isNullOrUndefined(rangeContainer)) {
        presets.style.height = rangeContainer.getBoundingClientRect().height + "px";
      }
    };
    DateRangePicker2.prototype.presetKeyActionHandler = function(e) {
      switch (e.action) {
        case "moveDown":
          this.listMoveDown(e);
          this.setScrollPosition();
          e.preventDefault();
          break;
        case "moveUp":
          this.listMoveUp(e);
          this.setScrollPosition();
          e.preventDefault();
          break;
        case "enter":
          {
            var hvrItem = this.getHoverLI();
            var actItem = this.getActiveLI();
            if (!isNullOrUndefined(this.leftCalendar) && !isNullOrUndefined(actItem)) {
              if (isNullOrUndefined(hvrItem) || !isNullOrUndefined(actItem) && actItem === hvrItem) {
                this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(actItem);
                var values = this.presetsItem[this.activeIndex];
                if (values.id === "custom_range") {
                  this.calendarFocus();
                  actItem.classList.remove(HOVER);
                  e.preventDefault();
                  return;
                }
              }
            }
            if (!isNullOrUndefined(hvrItem) || !isNullOrUndefined(actItem)) {
              this.onMouseClick(e, hvrItem || actItem);
            }
            e.preventDefault();
          }
          break;
        case "tab":
          if (this.leftCalendar) {
            var item = this.getHoverLI();
            if (!isNullOrUndefined(item)) {
              item.classList.remove(HOVER);
            }
          } else {
            this.hide(e);
            e.preventDefault();
          }
          break;
      }
    };
    DateRangePicker2.prototype.listMoveDown = function(e) {
      var hvrItem = this.getHoverLI();
      var actItem = this.getActiveLI();
      if (!isNullOrUndefined(hvrItem)) {
        var li = hvrItem.nextElementSibling;
        if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
          removeClass([hvrItem], HOVER);
          addClass([li], HOVER);
        }
      } else if (!isNullOrUndefined(actItem)) {
        var li = actItem.nextElementSibling;
        if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
          addClass([li], HOVER);
        }
      } else {
        addClass([this.liCollections[0]], HOVER);
      }
    };
    DateRangePicker2.prototype.listMoveUp = function(e) {
      var hvrItem = this.getHoverLI();
      var actItem = this.getActiveLI();
      if (!isNullOrUndefined(hvrItem)) {
        var li = hvrItem.previousElementSibling;
        if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
          removeClass([hvrItem], HOVER);
          addClass([li], HOVER);
        }
      } else if (!isNullOrUndefined(actItem)) {
        var li = actItem.previousElementSibling;
        if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
          addClass([li], HOVER);
        }
      }
    };
    DateRangePicker2.prototype.getHoverLI = function() {
      var item = this.presetElement.querySelector("." + HOVER);
      return item;
    };
    DateRangePicker2.prototype.getActiveLI = function() {
      var item = this.presetElement.querySelector("." + ACTIVE2);
      return item;
    };
    DateRangePicker2.prototype.popupKeyBoardHandler = function() {
      this.popupKeyboardModule = new KeyboardEvents(this.popupWrapper, {
        eventName: "keydown",
        keyAction: this.popupKeyActionHandle.bind(this),
        keyConfigs: { escape: "escape" }
      });
      this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);
      this.popupKeyboardModule = new KeyboardEvents(this.inputWrapper.container.children[1], {
        eventName: "keydown",
        keyAction: this.popupKeyActionHandle.bind(this),
        keyConfigs: this.keyInputConfigs
      });
    };
    DateRangePicker2.prototype.setScrollPosition = function() {
      var listHeight = this.presetElement.getBoundingClientRect().height;
      var hover = this.presetElement.querySelector("." + HOVER);
      var active = this.presetElement.querySelector("." + ACTIVE2);
      var element = !isNullOrUndefined(hover) ? hover : active;
      if (!isNullOrUndefined(element)) {
        var nextEle = element.nextElementSibling;
        var height = nextEle ? nextEle.offsetTop : element.offsetTop;
        var liHeight = element.getBoundingClientRect().height;
        if (height + element.offsetTop > listHeight) {
          this.presetElement.scrollTop = nextEle ? height - (listHeight / 2 + liHeight / 2) : height;
        } else {
          this.presetElement.scrollTop = 0;
        }
      }
    };
    DateRangePicker2.prototype.popupKeyActionHandle = function(e) {
      var presetElement = closest(e.target, "." + PRESETS);
      switch (e.action) {
        case "escape":
          if (this.isPopupOpen()) {
            if (this.isKeyPopup) {
              this.inputElement.focus();
              this.isKeyPopup = false;
            }
            this.hide(e);
          } else {
            this.inputWrapper.container.children[1].blur();
          }
          break;
        case "enter":
          if (!this.isPopupOpen()) {
            this.show(null, e);
          } else {
            this.inputWrapper.container.children[1].focus();
          }
          break;
        case "tab":
          this.hide(e);
          break;
        case "altRightArrow":
          if (!isNullOrUndefined(presetElement)) {
            this.cancelButton.element.focus();
          } else {
            if (document.activeElement === this.cancelButton.element && this.applyButton.element.disabled !== true) {
              this.applyButton.element.focus();
            } else {
              this.leftCalendar.children[1].firstElementChild.focus();
            }
          }
          e.preventDefault();
          break;
        case "altLeftArrow":
          if (!isNullOrUndefined(presetElement)) {
            this.rightCalendar.children[1].firstElementChild.focus();
          } else {
            if (document.activeElement === this.applyButton.element && this.applyButton.element.disabled !== true) {
              this.cancelButton.element.focus();
            } else {
              if (!isNullOrUndefined(this.presetElement) && document.activeElement === this.cancelButton.element) {
                this.presetElement.focus();
              } else {
                this.rightCalendar.children[1].firstElementChild.focus();
              }
            }
          }
          e.preventDefault();
          break;
      }
    };
    DateRangePicker2.prototype.documentHandler = function(e) {
      if (isNullOrUndefined(this.popupObj)) {
        return;
      }
      var target = e.target;
      if (!this.inputWrapper.container.contains(target) || !isNullOrUndefined(this.popupObj) && !closest(target, '[id="' + this.popupWrapper.id + '"]')) {
        if (e.type !== "touchstart" && (e.type === "mousedown" || this.closeEventArgs && !this.closeEventArgs.cancel)) {
          e.preventDefault();
        }
      }
      if ((isNullOrUndefined(this.targetElement) || !isNullOrUndefined(this.targetElement) && !(target === this.targetElement)) && !closest(target, '[id="' + this.popupWrapper.id + '"]') && !(closest(target, "." + INPUTCONTAINER2) === this.inputWrapper.container) && !(closest(target, ".e-daterangepicker.e-popup") && !target.classList.contains("e-day"))) {
        this.preventBlur = false;
        if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {
          this.applyFunction(e);
          if (!this.isMobile) {
            this.isRangeIconClicked = false;
          }
        }
      }
    };
    DateRangePicker2.prototype.createInput = function() {
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = this.cssClass.replace(/\s+/g, " ").trim();
      }
      this.inputWrapper = Input.createInput({
        floatLabelType: this.floatLabelType,
        element: this.inputElement,
        properties: {
          readonly: this.readonly,
          placeholder: this.placeholder,
          cssClass: updatedCssClassValue,
          enabled: this.enabled,
          enableRtl: this.enableRtl,
          showClearButton: this.showClearButton
        },
        buttons: [DATERANGEICON]
      }, this.createElement);
      attributes(this.inputElement, {
        "aria-readonly": this.readonly ? "true" : "false",
        "tabindex": "0",
        "aria-haspopup": "true",
        "aria-activedescendant": "null",
        "aria-owns": this.element.id + "_popup",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off",
        "aria-disabled": !this.enabled ? "true" : "false",
        "autocorrect": "off",
        "autocapitalize": "off",
        "spellcheck": "false"
      });
      Input.addAttributes({ "aria-label": "select" }, this.inputWrapper.buttons[0]);
      if (!isNullOrUndefined(this.placeholder) && this.placeholder.trim() !== "") {
        Input.addAttributes({ "aria-placeholder": this.placeholder }, this.inputElement);
      }
      this.setEleWidth(this.width);
      addClass([this.inputWrapper.container], DATERANGEWRAPPER);
      if (isNullOrUndefined(this.inputElement.getAttribute("name"))) {
        attributes(this.inputElement, { "name": this.element.id });
      }
      if (this.inputElement.type === "hidden") {
        this.inputWrapper.container.style.display = "none";
      }
      this.refreshControl();
      this.previousEleValue = this.inputElement.value;
      this.inputElement.setAttribute("value", this.inputElement.value);
      this.startCopy = this.startDate;
      this.endCopy = this.endDate;
    };
    DateRangePicker2.prototype.setEleWidth = function(width) {
      if (typeof width === "string") {
        this.inputWrapper.container.style.width = this.width;
      } else if (typeof width === "number") {
        this.inputWrapper.container.style.width = formatUnit(this.width);
      } else {
        this.inputWrapper.container.style.width = "100%";
      }
    };
    DateRangePicker2.prototype.adjustLongHeaderWidth = function() {
      if (this.dayHeaderFormat === "Wide") {
        addClass([this.popupWrapper], DAYHEADERLONG2);
      }
    };
    DateRangePicker2.prototype.refreshControl = function() {
      this.validateMinMax();
      if (this.strictMode) {
        this.validateRangeStrict();
      }
      var isDisabled = this.disabledDates();
      if (this.strictMode && isDisabled) {
        this.startValue = this.previousStartValue;
        this.setProperties({ startDate: this.startValue }, true);
        this.endValue = this.previousEndValue;
        this.setProperties({ endDate: this.endValue }, true);
        this.setValue();
      }
      this.updateInput();
      if (!this.strictMode) {
        this.validateRange();
      }
      if (!this.strictMode && isDisabled) {
        this.clearRange();
      }
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !isDisabled) {
        this.disabledDateRender();
      }
      this.errorClass();
      this.previousStartValue = isNullOrUndefined(this.startValue) || isNaN(+this.startValue) ? null : /* @__PURE__ */ new Date(+this.startValue);
      this.previousEndValue = isNullOrUndefined(this.endValue) || isNaN(+this.endValue) ? null : /* @__PURE__ */ new Date(+this.endValue);
    };
    DateRangePicker2.prototype.updateInput = function() {
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
        var formatOption = { format: this.formatString, type: "date", skeleton: "yMd" };
        var startDate = this.globalize.formatDate(this.startValue, formatOption);
        var endDate = this.globalize.formatDate(this.endValue, formatOption);
        Input.setValue(startDate + " " + this.separator + " " + endDate, this.inputElement, this.floatLabelType, this.showClearButton);
        this.previousStartValue = /* @__PURE__ */ new Date(+this.startValue);
        this.previousEndValue = /* @__PURE__ */ new Date(+this.endValue);
      }
      if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {
        Input.setValue(this.invalidValueString, this.inputElement, this.floatLabelType, this.showClearButton);
      }
    };
    DateRangePicker2.prototype.checkInvalidRange = function(value) {
      if (!isNullOrUndefined(value)) {
        var invalid = false;
        var startinvalue = void 0;
        var endinvalue = void 0;
        var startString = null;
        var endString = null;
        var valueString = null;
        var startObject = false;
        var endObject = false;
        var invalidobject = false;
        if (typeof value === "string") {
          var range = value.split(" " + this.separator + " ");
          if (range.length === 2) {
            startString = range[0];
            endString = range[1];
          } else {
            invalid = true;
            valueString = value;
          }
        } else {
          if (value.length > 0) {
            startinvalue = value[0];
            endinvalue = value[1];
          } else {
            startinvalue = value.start;
            endinvalue = value.end;
          }
          if (!(startinvalue instanceof Date) && typeof startinvalue !== "object") {
            startString = this.getstringvalue(startinvalue);
          } else if (startinvalue instanceof Date) {
            startObject = true;
          } else if (!isNullOrUndefined(startinvalue)) {
            invalidobject = true;
          }
          if (!(endinvalue instanceof Date) && typeof endinvalue !== "object") {
            endString = this.getstringvalue(endinvalue);
          } else if (endinvalue instanceof Date) {
            endObject = true;
          } else if (!isNullOrUndefined(endinvalue)) {
            invalidobject = true;
          }
        }
        if (isNullOrUndefined(startString) && !startObject && !isNullOrUndefined(endString) || !isNullOrUndefined(startString) && !endObject && isNullOrUndefined(endString)) {
          invalid = true;
        }
        if (invalidobject) {
          startString = endString = valueString = null;
          invalid = true;
        }
        if (startString) {
          invalid = invalid || this.checkInvalidValue(startString);
        }
        if (endString) {
          invalid = invalid || this.checkInvalidValue(endString);
        }
        if (invalid) {
          if (startObject && !invalidobject) {
            startString = startinvalue.toLocaleDateString();
          }
          if (endObject && !invalidobject) {
            endString = endinvalue.toLocaleDateString();
          }
          if (!isNullOrUndefined(startString) && !isNullOrUndefined(endString)) {
            valueString = startString + " " + this.separator + " " + endString;
          } else if (!isNullOrUndefined(startString)) {
            valueString = startString;
          } else if (!isNullOrUndefined(endString)) {
            valueString = endString;
          }
          this.invalidValueString = valueString;
          this.setProperties({ value: null }, true);
          this.setProperties({ startValue: null }, true);
          this.setProperties({ endValue: null }, true);
          this.startDate = null;
          this.endDate = null;
        }
      }
    };
    DateRangePicker2.prototype.getstringvalue = function(value) {
      var stringValue = null;
      if (!isNullOrUndefined(value) && typeof value === "number") {
        stringValue = value.toString();
      } else if (!isNullOrUndefined(value) && typeof value === "string") {
        stringValue = "" + value;
      }
      return stringValue;
    };
    DateRangePicker2.prototype.checkInvalidValue = function(value) {
      var valueString = value;
      var invalid = false;
      var formatOpt = null;
      formatOpt = { format: this.formatString, type: "date", skeleton: "yMd" };
      if (typeof valueString !== "string") {
        invalid = true;
      } else {
        var globalize = new Internationalization(this.locale);
        if (!this.checkDateValue(globalize.parseDate(valueString, formatOpt))) {
          var extISOStr = null;
          var basISOString = null;
          extISOStr = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
          basISOString = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
          if (!extISOStr.test(valueString) && !basISOString.test(valueString) || /^[a-zA-Z0-9- ]*$/.test(valueString) || isNaN(+new Date(this.checkValue(valueString)))) {
            invalid = true;
          }
        }
      }
      return invalid;
    };
    DateRangePicker2.prototype.isDateDisabled = function(date) {
      if (isNullOrUndefined(date)) {
        return false;
      }
      var value = /* @__PURE__ */ new Date(+date);
      if (+value < +this.min || +value > +this.max) {
        return true;
      }
      this.virtualRenderCellArgs = {
        date: value,
        isDisabled: false
      };
      var args = this.virtualRenderCellArgs;
      this.virtualRenderCellEvent(args);
      if (args.isDisabled) {
        return true;
      }
      return false;
    };
    DateRangePicker2.prototype.disabledDateRender = function() {
      this.disabledDays = [];
      this.disabledDayCnt = null;
      var localDate = /* @__PURE__ */ new Date(+this.startValue);
      var count = 0;
      while (+localDate <= +this.endValue && +this.endValue <= +this.max) {
        this.virtualRenderCellArgs = {
          date: localDate,
          isDisabled: false
        };
        var args = this.virtualRenderCellArgs;
        this.virtualRenderCellEvent(args);
        if (args.isDisabled) {
          this.disabledDays.push(/* @__PURE__ */ new Date(+args.date));
          if (+localDate > +this.startValue && +localDate < +this.endValue) {
            count++;
          }
        }
        this.addDay(localDate, 1, null, this.max, this.min);
      }
      this.disabledDayCnt = count;
    };
    DateRangePicker2.prototype.virtualRenderCellEvent = function(args) {
      extend(this.virtualRenderCellArgs, { name: "renderDayCell" });
      this.trigger("renderDayCell", args);
    };
    DateRangePicker2.prototype.disabledDates = function() {
      var isStartDisabled = false;
      var isEndDisabled = false;
      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
        isStartDisabled = this.isDateDisabled(this.startValue);
        isEndDisabled = this.isDateDisabled(this.endValue);
        if (!this.isPopupOpen()) {
          this.currentDate = null;
        }
        this.setValue();
      }
      return isStartDisabled || isEndDisabled;
    };
    DateRangePicker2.prototype.setModelValue = function() {
      if (!this.value && this.startDate === null && this.endDate === null) {
        this.setProperties({ value: null }, true);
      } else if (this.value === null || this.value.start === null) {
        if (this.value === null) {
          this.setProperties({ value: [this.startDate, this.endDate] }, true);
        } else if (this.value.start === null) {
          this.setProperties({ value: { start: this.startDate, end: this.endDate } }, true);
        }
      } else {
        if (this.value && this.value.length > 0 || this.valueType && this.valueType.length > 0) {
          if (+this.startDate !== +this.value[0] || +this.endDate !== +this.value[1]) {
            this.setProperties({ value: [this.startDate, this.endDate] }, true);
          }
          if (this.value && this.value[0] == null && this.value[1] == null) {
            this.setProperties({ value: null }, true);
          }
        } else {
          if (this.value && this.value.start) {
            this.setProperties({ value: { start: this.startDate, end: this.endDate } }, true);
          }
        }
      }
      this.createHiddenInput();
    };
    DateRangePicker2.prototype.dispatchEvent = function(element, type) {
      var evt = document.createEvent("HTMLEvents");
      evt.initEvent(type, false, true);
      element.dispatchEvent(evt);
      this.firstHiddenChild.dispatchEvent(evt);
    };
    DateRangePicker2.prototype.changeTrigger = function(e) {
      if (+this.initStartDate !== +this.startValue || +this.initEndDate !== +this.endValue) {
        this.setProperties({ endDate: this.checkDateValue(this.endValue) }, true);
        this.setProperties({ startDate: this.checkDateValue(this.startValue) }, true);
        this.setModelValue();
        if (this.isAngular && this.preventChange) {
          this.preventChange = false;
        } else {
          this.trigger("change", this.rangeArgs(e));
        }
      }
      this.previousEleValue = this.inputElement.value;
      this.initStartDate = this.checkDateValue(this.startValue);
      this.initEndDate = this.checkDateValue(this.endValue);
    };
    DateRangePicker2.prototype.navigateTo = function(view, date) {
      if (this.isPopupOpen()) {
        if (view.toLowerCase() === "month") {
          view = "Month";
        } else if (view.toLowerCase() === "year") {
          view = "Year";
        } else if (view.toLowerCase() === "decade") {
          view = "Decade";
        } else {
          return;
        }
        if (this.getViewNumber(view) < this.getViewNumber(this.depth)) {
          view = this.depth;
        }
        if (this.isMobile) {
          _super.prototype.navigateTo.call(this, view, date);
        } else {
          if (date < this.min) {
            date = /* @__PURE__ */ new Date(+this.min);
          } else if (date >= this.max) {
            date = /* @__PURE__ */ new Date(+this.max);
          }
          if (view === "Month" && this.isSameMonth(date, this.max)) {
            date = new Date(this.max.getFullYear(), this.max.getMonth() - 1, this.min.getDate());
          } else if (view === "Year" && this.isSameYear(date, this.max)) {
            date = new Date(this.max.getFullYear() - 1, this.max.getMonth(), this.max.getDate());
          } else if (view === "Decade" && this.isSameDecade(date, this.max)) {
            date = new Date(this.max.getFullYear() - 10, this.max.getMonth(), this.max.getDate());
          }
          this.leftCalCurrentDate = date;
          this.navigate(this.leftCalendar, this.leftCalCurrentDate, view);
          if (view === "Month") {
            date = new Date(this.currentDate.setMonth(this.currentDate.getMonth() + 1));
          } else if (view === "Year") {
            date = new Date(this.currentDate.setFullYear(this.currentDate.getFullYear() + 1));
          } else {
            date = new Date(this.currentDate.setFullYear(this.currentDate.getFullYear() + 10));
          }
          this.rightCalCurrentDate = date;
          this.navigate(this.rightCalendar, this.rightCalCurrentDate, view);
          this.leftKeyboardModule = this.rightKeyboardModule = null;
          this.updateNavIcons();
        }
        if (this.currentView() === this.depth) {
          this.bindCalendarCellEvents();
        }
        this.removeFocusedDate();
        this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);
      }
    };
    DateRangePicker2.prototype.navigate = function(calendar, date, view) {
      this.calendarElement = calendar;
      this.table = calendar.querySelector("table");
      this.tableBodyElement = calendar.querySelector("tbody");
      this.headerTitleElement = calendar.querySelector(".e-title");
      this.tableHeadElement = calendar.querySelector("thead");
      this.contentElement = calendar.querySelector(".e-content");
      this.previousIcon = calendar.querySelector(".e-prev");
      this.nextIcon = calendar.querySelector(".e-next");
      this.effect = ZOOMIN2;
      _super.prototype.navigateTo.call(this, view, date);
    };
    DateRangePicker2.prototype.focusIn = function() {
      if (document.activeElement !== this.inputElement && this.enabled) {
        addClass([this.inputWrapper.container], [INPUTFOCUS2]);
        this.inputElement.focus();
      }
    };
    DateRangePicker2.prototype.focusOut = function() {
      var isBlur = this.preventBlur;
      if (document.activeElement === this.inputElement) {
        removeClass([this.inputWrapper.container], [INPUTFOCUS2]);
        this.preventBlur = false;
        this.inputElement.blur();
        this.preventBlur = isBlur;
      }
    };
    DateRangePicker2.prototype.destroy = function() {
      this.unBindEvents();
      this.hide(null);
      var ariaAttrs = {
        "aria-readonly": this.readonly ? "true" : "false",
        "tabindex": "0",
        "aria-haspopup": "true",
        "aria-activedescendant": "null",
        "aria-owns": this.element.id + "_popup",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off",
        "aria-disabled": !this.enabled ? "true" : "false",
        "autocorrect": "off",
        "autocapitalize": "off",
        "aria-invalid": "false",
        "spellcheck": "false"
      };
      if (this.inputElement) {
        removeClass([this.inputElement], [ROOT3]);
        EventHandler.remove(this.inputElement, "blur", this.inputBlurHandler);
        Input.removeAttributes(ariaAttrs, this.inputElement);
        if (!isNullOrUndefined(this.cloneElement.getAttribute("tabindex"))) {
          this.inputElement.setAttribute("tabindex", this.tabIndex);
        } else {
          this.inputElement.removeAttribute("tabindex");
        }
        this.ensureInputAttribute();
        this.inputElement.classList.remove("e-input");
        if (!isNullOrUndefined(this.inputWrapper)) {
          EventHandler.remove(this.inputWrapper.buttons[0], "mousedown", this.rangeIconHandler);
          if (this.angularTag === null) {
            this.inputWrapper.container.parentElement.appendChild(this.inputElement);
          }
          detach(this.inputWrapper.container);
        }
      }
      if (!isNullOrUndefined(this.inputKeyboardModule) && !this.isMobile) {
        this.inputKeyboardModule.destroy();
      }
      if (this.popupObj) {
        if (!this.isMobile) {
          this.clearCalendarEvents();
        }
      }
      _super.prototype.destroy.call(this);
      this.inputWrapper = this.popupWrapper = this.popupObj = this.cloneElement = this.presetElement = null;
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
      if (!isNullOrUndefined(this.firstHiddenChild) && !isNullOrUndefined(this.secondHiddenChild)) {
        detach(this.firstHiddenChild);
        detach(this.secondHiddenChild);
        this.firstHiddenChild = this.secondHiddenChild = null;
        this.inputElement.setAttribute("name", this.element.getAttribute("data-name"));
        this.inputElement.removeAttribute("data-name");
      }
    };
    DateRangePicker2.prototype.ensureInputAttribute = function() {
      var attr = [];
      for (var i = 0; i < this.inputElement.attributes.length; i++) {
        attr[i] = this.inputElement.attributes[i].name;
      }
      for (var i = 0; i < attr.length; i++) {
        if (isNullOrUndefined(this.cloneElement.getAttribute(attr[i]))) {
          if (attr[i].toLowerCase() === "value") {
            this.inputElement.value = "";
          }
          this.inputElement.removeAttribute(attr[i]);
        } else {
          if (attr[i].toLowerCase() === "value") {
            this.inputElement.value = this.cloneElement.getAttribute(attr[i]);
          }
          this.inputElement.setAttribute(attr[i], this.cloneElement.getAttribute(attr[i]));
        }
      }
    };
    DateRangePicker2.prototype.getModuleName = function() {
      return "daterangepicker";
    };
    DateRangePicker2.prototype.getPersistData = function() {
      var keyEntity = ["startDate", "endDate", "value"];
      return this.addOnPersist(keyEntity);
    };
    DateRangePicker2.prototype.getSelectedRange = function() {
      var range;
      if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
        range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1e3 * 60 * 60 * 24))) + 1;
        this.disabledDateRender();
        if (!isNullOrUndefined(this.disabledDayCnt)) {
          range = range - this.disabledDayCnt;
          this.disabledDayCnt = null;
        }
      } else {
        range = 0;
      }
      return { startDate: this.startValue, endDate: this.endValue, daySpan: range };
    };
    DateRangePicker2.prototype.show = function(element, event) {
      var _this = this;
      if (this.isMobile && this.popupObj) {
        this.popupObj.refreshPosition();
      }
      if (this.enabled && this.readonly || !this.enabled || this.popupObj) {
        return;
      } else {
        if (!this.isPopupOpen()) {
          if (element) {
            this.targetElement = element;
          }
          this.createPopup();
          if (this.isMobile || Browser.isDevice) {
            this.mobileRangePopupWrap = this.createElement("div", { className: "e-daterangepick-mob-popup-wrap" });
            document.body.appendChild(this.mobileRangePopupWrap);
          }
          this.openEventArgs = {
            popup: this.popupObj || null,
            cancel: false,
            date: this.inputElement.value,
            model: this,
            event: event ? event : null,
            appendTo: this.isMobile || Browser.isDevice ? this.mobileRangePopupWrap : document.body
          };
          var eventArgs = this.openEventArgs;
          this.trigger("open", eventArgs, function(eventArgs2) {
            _this.openEventArgs = eventArgs2;
            if (!_this.openEventArgs.cancel) {
              _this.openEventArgs.appendTo.appendChild(_this.popupWrapper);
              _this.showPopup(element, event);
              var isPreset = !_this.isCustomRange || _this.isMobile && _this.isCustomRange;
              if (!isUndefined(_this.presets[0].start && _this.presets[0].end && _this.presets[0].label) && isPreset) {
                _this.setScrollPosition();
              }
              _this.checkMinMaxDays();
              if (_this.isMobile && !isNullOrUndefined(_this.startDate) && isNullOrUndefined(_this.endDate)) {
                _this.endButton.element.classList.add(ACTIVE2);
                _this.startButton.element.classList.remove(ACTIVE2);
                _this.endButton.element.removeAttribute("disabled");
                _this.selectableDates();
              }
              _super.prototype.setOverlayIndex.call(
                _this,
                _this.mobileRangePopupWrap,
                _this.popupObj.element,
                _this.modal,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                _this.isMobile || Browser.isDevice
              );
            }
          });
        }
      }
    };
    DateRangePicker2.prototype.hide = function(event) {
      var _this = this;
      if (this.popupObj) {
        if (isNullOrUndefined(this.previousEndValue) && isNullOrUndefined(this.previousStartValue)) {
          this.clearRange();
        } else {
          if (!isNullOrUndefined(this.previousStartValue)) {
            this.startValue = new Date(this.checkValue(this.previousStartValue));
            this.setValue();
            this.currentDate = new Date(this.checkValue(this.startValue));
          } else {
            this.startValue = null;
            this.setValue();
          }
          if (!isNullOrUndefined(this.previousEndValue)) {
            this.endValue = new Date(this.checkValue(this.previousEndValue));
            this.setValue();
          } else {
            this.endValue = null;
            this.setValue();
          }
        }
        if (this.isPopupOpen()) {
          this.closeEventArgs = {
            cancel: false,
            popup: this.popupObj,
            date: this.inputElement.value,
            model: this,
            event: event ? event : null
          };
          var eventArgs = this.closeEventArgs;
          this.trigger("close", eventArgs, function(eventArgs2) {
            _this.closeEventArgs = eventArgs2;
            if (!_this.closeEventArgs.cancel) {
              if (_this.isMobile) {
                if (!isNullOrUndefined(_this.startButton) && !isNullOrUndefined(_this.endButton)) {
                  EventHandler.remove(_this.startButton.element, "click touchstart", _this.deviceHeaderClick);
                  EventHandler.remove(_this.endButton.element, "click touchstart", _this.deviceHeaderClick);
                }
              }
              if (_this.popupObj) {
                _this.popupObj.hide();
                if (_this.preventBlur) {
                  _this.inputElement.focus();
                  addClass([_this.inputWrapper.container], [INPUTFOCUS2]);
                }
              }
              if (!_this.isMobile) {
                if (!isNullOrUndefined(_this.leftKeyboardModule) && !isNullOrUndefined(_this.rightKeyboardModule)) {
                  _this.leftKeyboardModule.destroy();
                  _this.rightKeyboardModule.destroy();
                }
                if (!isNullOrUndefined(_this.presetElement)) {
                  _this.presetKeyboardModule.destroy();
                }
                if (!isNullOrUndefined(_this.cancelButton)) {
                  _this.btnKeyboardModule.destroy();
                }
              }
              _this.targetElement = null;
              removeClass([document.body], OVERFLOW2);
              EventHandler.remove(document, "mousedown touchstart", _this.documentHandler);
              if (_this.isMobile && _this.modal) {
                _this.modal.style.display = "none";
                _this.modal.outerHTML = "";
                _this.modal = null;
              }
              if (_this.isMobile || Browser.isDevice) {
                if (!isNullOrUndefined(_this.mobileRangePopupWrap)) {
                  _this.mobileRangePopupWrap.remove();
                  _this.mobileRangePopupWrap = null;
                }
              }
              _this.isKeyPopup = _this.dateDisabled = false;
            } else {
              removeClass([_this.inputWrapper.buttons[0]], ACTIVE2);
            }
            _this.updateClearIconState();
            _this.updateHiddenInput();
            if (_this.isMobile && _this.allowEdit && !_this.readonly) {
              _this.inputElement.removeAttribute("readonly");
            }
          });
        }
      } else {
        this.updateClearIconState();
        this.updateHiddenInput();
        if (this.isMobile && this.allowEdit && !this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
      }
    };
    DateRangePicker2.prototype.setLocale = function() {
      this.globalize = new Internationalization(this.locale);
      this.l10n.setLocale(this.locale);
      this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
      Input.setPlaceholder(this.placeholder, this.inputElement);
      this.updateInput();
      this.updateHiddenInput();
      this.changeTrigger();
    };
    DateRangePicker2.prototype.refreshChange = function() {
      this.checkView();
      this.refreshControl();
      this.changeTrigger();
    };
    DateRangePicker2.prototype.setDate = function() {
      Input.setValue("", this.inputElement, this.floatLabelType, this.showClearButton);
      this.refreshChange();
    };
    DateRangePicker2.prototype.enableInput = function() {
      if (+this.min <= +this.max) {
        this.setProperties({ enabled: true }, true);
        Input.setEnabled(this.enabled, this.inputElement);
        if (this.element.hasAttribute("disabled")) {
          this.bindEvents();
        }
      }
    };
    DateRangePicker2.prototype.clearModelvalue = function(newProp, oldProp) {
      this.setProperties({ startDate: null }, true);
      this.setProperties({ endDate: null }, true);
      if (oldProp.value && oldProp.value.length > 0) {
        this.setProperties({ value: null }, true);
      } else if (oldProp.value && oldProp.value.start) {
        this.setProperties({ value: { start: null, end: null } }, true);
      } else if (oldProp.value && !oldProp.value.start) {
        this.setProperties({ value: { start: null, end: null } }, true);
      }
      this.updateValue();
      this.setDate();
    };
    DateRangePicker2.prototype.createHiddenInput = function() {
      if (isNullOrUndefined(this.firstHiddenChild) && isNullOrUndefined(this.secondHiddenChild)) {
        this.firstHiddenChild = this.createElement("input");
        this.secondHiddenChild = this.createElement("input");
      }
      if (!isNullOrUndefined(this.inputElement.getAttribute("name"))) {
        this.inputElement.setAttribute("data-name", this.inputElement.getAttribute("name"));
        this.inputElement.removeAttribute("name");
      }
      attributes(this.firstHiddenChild, {
        "type": "text",
        "name": this.inputElement.getAttribute("data-name"),
        "class": HIDDENELEMENT
      });
      attributes(this.secondHiddenChild, {
        "type": "text",
        "name": this.inputElement.getAttribute("data-name"),
        "class": HIDDENELEMENT
      });
      var format = { type: "datetime", skeleton: "yMd" };
      this.firstHiddenChild.value = this.startDate && this.globalize.formatDate(this.startDate, format);
      this.secondHiddenChild.value = this.endDate && this.globalize.formatDate(this.endDate, format);
      this.inputElement.parentElement.appendChild(this.firstHiddenChild);
      this.inputElement.parentElement.appendChild(this.secondHiddenChild);
    };
    DateRangePicker2.prototype.setMinMaxDays = function() {
      if (this.isPopupOpen()) {
        this.removeClassDisabled();
        this.checkMinMaxDays();
        if (this.isMobile) {
          this.selectableDates();
        }
        if (!this.strictMode && (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue))) {
          this.removeSelection();
        } else {
          this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);
        }
        this.updateHeader();
      }
    };
    DateRangePicker2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var format = { format: this.formatString, type: "date", skeleton: "yMd" };
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        var openPopup = ["maxDays", "minDays", "value"];
        if (openPopup.indexOf(prop) < 0) {
          this.hide(null);
        }
        switch (prop) {
          case "width":
            this.setEleWidth(this.width);
            break;
          case "separator":
            this.previousEleValue = this.inputElement.value;
            this.setProperties({ separator: newProp.separator }, true);
            this.updateInput();
            this.changeTrigger();
            break;
          case "placeholder":
            Input.setPlaceholder(newProp.placeholder, this.inputElement);
            this.setProperties({ placeholder: newProp.placeholder }, true);
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.inputElement);
            this.inputElement.setAttribute("aria-readonly", "" + this.readonly);
            this.setRangeAllowEdit();
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "enabled":
            this.setProperties({ enabled: newProp.enabled }, true);
            Input.setEnabled(this.enabled, this.inputElement);
            if (this.enabled) {
              this.inputElement.setAttribute("tabindex", this.tabIndex);
            } else {
              this.inputElement.tabIndex = -1;
            }
            break;
          case "allowEdit":
            this.setRangeAllowEdit();
            break;
          case "enableRtl":
            this.setProperties({ enableRtl: newProp.enableRtl }, true);
            Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);
            break;
          case "zIndex":
            this.setProperties({ zIndex: newProp.zIndex }, true);
            break;
          case "format":
            this.setProperties({ format: newProp.format }, true);
            this.checkFormat();
            this.updateInput();
            this.changeTrigger();
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
            Input.setPlaceholder(this.placeholder, this.inputElement);
            this.setLocale();
            break;
          case "htmlAttributes":
            this.updateHtmlAttributeToElement();
            this.updateHtmlAttributeToWrapper();
            this.setDataAttribute(true);
            this.checkHtmlAttributes(true);
            break;
          case "showClearButton":
            Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);
            this.bindClearEvent();
            break;
          case "startDate":
            if (typeof newProp.startDate === "string") {
              newProp.startDate = this.globalize.parseDate(newProp.startDate, format);
            }
            if (+this.initStartDate !== +newProp.startDate) {
              this.startValue = this.checkDateValue(new Date(this.checkValue(newProp.startDate)));
              this.setDate();
              this.setValue();
            }
            break;
          case "endDate":
            if (typeof newProp.endDate === "string") {
              newProp.endDate = this.globalize.parseDate(newProp.endDate, format);
            }
            if (+this.initEndDate !== +newProp.endDate) {
              this.endValue = this.checkDateValue(new Date(this.checkValue(newProp.endDate)));
              this.setDate();
              this.setValue();
            }
            break;
          case "value":
            this.invalidValueString = null;
            this.checkInvalidRange(newProp.value);
            if (typeof newProp.value === "string") {
              if (!this.invalidValueString) {
                var rangeArray = newProp.value.split(" " + this.separator + " ");
                this.value = [new Date(rangeArray[0]), new Date(rangeArray[1])];
                this.updateValue();
                this.setDate();
              } else {
                this.clearModelvalue(newProp, oldProp);
              }
            } else {
              if (!isNullOrUndefined(newProp.value) && newProp.value.length > 0 || !isNullOrUndefined(newProp.value) && newProp.value.start) {
                this.valueType = newProp.value;
                if (newProp.value[0] === null || newProp.value.start === null) {
                  if (newProp.value.length === 1 || newProp.value.start) {
                    this.clearModelvalue(newProp, oldProp);
                  } else if (newProp.value[1] === null || newProp.value.start === null) {
                    this.clearModelvalue(newProp, oldProp);
                  }
                } else if (+this.initStartDate !== +newProp.value[0] || +this.initEndDate !== +newProp.value[1] || +this.initStartDate !== +(newProp.value.start || +this.initEndDate !== +newProp.value.start)) {
                  if (newProp.value.length === 1) {
                    this.modelValue = newProp.value;
                  } else if (newProp.value.start) {
                    this.modelValue = newProp.value;
                  }
                  this.updateValue();
                  this.setDate();
                }
              } else {
                if (isNullOrUndefined(this.value) || newProp.value.start == null) {
                  this.valueType = newProp.value;
                  this.startValue = null;
                  this.endValue = null;
                  this.clearModelvalue(newProp, oldProp);
                }
              }
            }
            if (this.isPopupOpen()) {
              if (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
                this.removeSelection();
                if (this.isMobile) {
                  this.deviceHeaderUpdate();
                }
                return;
              }
              if (this.isMobile) {
                this.navigate(this.deviceCalendar, this.startValue, this.currentView());
                this.deviceHeaderUpdate();
              } else {
                this.navigate(this.leftCalendar, this.startValue, this.currentView());
                this.updateControl(this.leftCalendar);
                this.navigate(this.rightCalendar, this.endValue, this.currentView());
                this.updateControl(this.rightCalendar);
              }
              this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);
              this.updateHeader();
              this.applyButton.disabled = this.applyButton.element.disabled = false;
            }
            this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
            break;
          case "minDays":
            this.setProperties({ minDays: newProp.minDays }, true);
            this.refreshChange();
            this.setMinMaxDays();
            break;
          case "maxDays":
            this.setProperties({ maxDays: newProp.maxDays }, true);
            this.refreshChange();
            this.setMinMaxDays();
            break;
          case "min":
            this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(newProp.min))) }, true);
            this.previousEleValue = this.inputElement.value;
            this.enableInput();
            this.refreshChange();
            break;
          case "max":
            this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(newProp.max))) }, true);
            this.enableInput();
            this.refreshChange();
            break;
          case "strictMode":
            this.invalidValueString = null;
            this.setProperties({ strictMode: newProp.strictMode }, true);
            this.refreshChange();
            break;
          case "presets":
            this.setProperties({ presets: newProp.presets }, true);
            this.processPresets();
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            Input.removeFloating(this.inputWrapper);
            Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);
            break;
          case "start":
            this.setProperties({ start: newProp.start }, true);
            this.refreshChange();
            break;
          case "depth":
            this.setProperties({ depth: newProp.depth }, true);
            this.refreshChange();
            break;
        }
      }
    };
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "value", void 0);
    __decorate3([
      Property(false)
    ], DateRangePicker2.prototype, "enablePersistence", void 0);
    __decorate3([
      Property(new Date(1900, 0, 1))
    ], DateRangePicker2.prototype, "min", void 0);
    __decorate3([
      Property(new Date(2099, 11, 31))
    ], DateRangePicker2.prototype, "max", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "locale", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "firstDayOfWeek", void 0);
    __decorate3([
      Property(false)
    ], DateRangePicker2.prototype, "weekNumber", void 0);
    __decorate3([
      Property("Gregorian")
    ], DateRangePicker2.prototype, "calendarMode", void 0);
    __decorate3([
      Property(false)
    ], DateRangePicker2.prototype, "openOnFocus", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "created", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "destroyed", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "change", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "cleared", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "navigated", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "renderDayCell", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "startDate", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "endDate", void 0);
    __decorate3([
      Collection([{}], Presets)
    ], DateRangePicker2.prototype, "presets", void 0);
    __decorate3([
      Property("")
    ], DateRangePicker2.prototype, "width", void 0);
    __decorate3([
      Property(1e3)
    ], DateRangePicker2.prototype, "zIndex", void 0);
    __decorate3([
      Property(true)
    ], DateRangePicker2.prototype, "showClearButton", void 0);
    __decorate3([
      Property(true)
    ], DateRangePicker2.prototype, "showTodayButton", void 0);
    __decorate3([
      Property("Month")
    ], DateRangePicker2.prototype, "start", void 0);
    __decorate3([
      Property("Month")
    ], DateRangePicker2.prototype, "depth", void 0);
    __decorate3([
      Property("")
    ], DateRangePicker2.prototype, "cssClass", void 0);
    __decorate3([
      Property("-")
    ], DateRangePicker2.prototype, "separator", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "minDays", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "maxDays", void 0);
    __decorate3([
      Property(false)
    ], DateRangePicker2.prototype, "strictMode", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "keyConfigs", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "format", void 0);
    __decorate3([
      Property(true)
    ], DateRangePicker2.prototype, "enabled", void 0);
    __decorate3([
      Property(false)
    ], DateRangePicker2.prototype, "readonly", void 0);
    __decorate3([
      Property(true)
    ], DateRangePicker2.prototype, "allowEdit", void 0);
    __decorate3([
      Property("Never")
    ], DateRangePicker2.prototype, "floatLabelType", void 0);
    __decorate3([
      Property(null)
    ], DateRangePicker2.prototype, "placeholder", void 0);
    __decorate3([
      Property({})
    ], DateRangePicker2.prototype, "htmlAttributes", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "open", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "close", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "select", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "focus", void 0);
    __decorate3([
      Event()
    ], DateRangePicker2.prototype, "blur", void 0);
    DateRangePicker2 = __decorate3([
      NotifyPropertyChanges
    ], DateRangePicker2);
    return DateRangePicker2;
  }(CalendarBase)
);

// node_modules/@syncfusion/ej2-calendars/src/timepicker/timepicker.js
var __extends47 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var WRAPPERCLASS = "e-time-wrapper";
var POPUP3 = "e-popup";
var ERROR3 = "e-error";
var POPUPDIMENSION = "240px";
var DAY = (/* @__PURE__ */ new Date()).getDate();
var MONTH2 = (/* @__PURE__ */ new Date()).getMonth();
var YEAR2 = (/* @__PURE__ */ new Date()).getFullYear();
var ROOT4 = "e-timepicker";
var LIBRARY3 = "e-lib";
var CONTROL3 = "e-control";
var CONTENT3 = "e-content";
var SELECTED4 = "e-active";
var HOVER2 = "e-hover";
var NAVIGATION = "e-navigation";
var DISABLED3 = "e-disabled";
var ICONANIMATION = "e-icon-anim";
var FOCUS = "e-input-focus";
var LISTCLASS2 = "e-list-item";
var HALFPOSITION = 2;
var ANIMATIONDURATION = 50;
var OVERFLOW3 = "e-time-overflow";
var OFFSETVAL = 4;
var EDITABLE = "e-non-edit";
var wrapperAttributes = ["title", "class", "style"];
var TimePickerBase;
(function(TimePickerBase2) {
  function createListItems(createdEl, min, max, globalize, timeFormat, step) {
    var formatOptions;
    if (this.calendarMode === "Gregorian") {
      formatOptions = { format: timeFormat, type: "time" };
    } else {
      formatOptions = { format: timeFormat, type: "time", calendar: "islamic" };
    }
    var start;
    var interval = step * 6e4;
    var listItems = [];
    var timeCollections = [];
    start = +min.setMilliseconds(0);
    var end = +max.setMilliseconds(0);
    while (end >= start) {
      timeCollections.push(start);
      listItems.push(globalize.formatDate(new Date(start), { format: timeFormat, type: "time" }));
      start += interval;
    }
    var listTag = ListBase.createList(createdEl, listItems, null, true);
    return { collection: timeCollections, list: listTag };
  }
  TimePickerBase2.createListItems = createListItems;
})(TimePickerBase || (TimePickerBase = {}));
var TimeMaskPlaceholder = (
  /** @class */
  function(_super) {
    __extends47(TimeMaskPlaceholder2, _super);
    function TimeMaskPlaceholder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([
      Property("day")
    ], TimeMaskPlaceholder2.prototype, "day", void 0);
    __decorate4([
      Property("month")
    ], TimeMaskPlaceholder2.prototype, "month", void 0);
    __decorate4([
      Property("year")
    ], TimeMaskPlaceholder2.prototype, "year", void 0);
    __decorate4([
      Property("day of the week")
    ], TimeMaskPlaceholder2.prototype, "dayOfTheWeek", void 0);
    __decorate4([
      Property("hour")
    ], TimeMaskPlaceholder2.prototype, "hour", void 0);
    __decorate4([
      Property("minute")
    ], TimeMaskPlaceholder2.prototype, "minute", void 0);
    __decorate4([
      Property("second")
    ], TimeMaskPlaceholder2.prototype, "second", void 0);
    return TimeMaskPlaceholder2;
  }(ChildProperty)
);
var TimePicker = (
  /** @class */
  function(_super) {
    __extends47(TimePicker2, _super);
    function TimePicker2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.liCollections = [];
      _this.timeCollections = [];
      _this.disableItemCollection = [];
      _this.invalidValueString = null;
      _this.isAngular = false;
      _this.preventChange = false;
      _this.maskedDateValue = "";
      _this.moduleName = _this.getModuleName();
      _this.timeOptions = options;
      return _this;
    }
    TimePicker2.prototype.preRender = function() {
      this.keyConfigure = {
        enter: "enter",
        escape: "escape",
        end: "end",
        tab: "tab",
        home: "home",
        down: "downarrow",
        up: "uparrow",
        left: "leftarrow",
        right: "rightarrow",
        open: "alt+downarrow",
        close: "alt+uparrow"
      };
      this.cloneElement = this.element.cloneNode(true);
      removeClass([this.cloneElement], [ROOT4, CONTROL3, LIBRARY3]);
      this.inputElement = this.element;
      this.angularTag = null;
      this.formElement = closest(this.element, "form");
      if (this.element.tagName === "EJS-TIMEPICKER") {
        this.angularTag = this.element.tagName;
        this.inputElement = this.createElement("input");
        this.element.appendChild(this.inputElement);
      }
      this.tabIndex = this.element.hasAttribute("tabindex") ? this.element.getAttribute("tabindex") : "0";
      this.element.removeAttribute("tabindex");
      this.openPopupEventArgs = {
        appendTo: document.body
      };
    };
    TimePicker2.prototype.render = function() {
      this.initialize();
      this.createInputElement();
      this.updateHtmlAttributeToWrapper();
      this.setTimeAllowEdit();
      this.setEnable();
      this.validateInterval();
      this.bindEvents();
      this.validateDisable();
      this.setValue(this.getFormattedValue(this.value));
      if (this.enableMask && !this.value && this.maskedDateValue && (this.floatLabelType == "Always" || !this.floatLabelType || !this.placeholder)) {
        this.updateInputValue(this.maskedDateValue);
        this.checkErrorState(this.maskedDateValue);
      }
      this.anchor = this.inputElement;
      this.inputElement.setAttribute("value", this.inputElement.value);
      this.inputEleValue = this.getDateObject(this.inputElement.value);
      this.renderComplete();
    };
    TimePicker2.prototype.setTimeAllowEdit = function() {
      if (this.allowEdit) {
        if (!this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
      } else {
        attributes(this.inputElement, { "readonly": "" });
      }
      this.clearIconState();
    };
    TimePicker2.prototype.clearIconState = function() {
      if (!this.allowEdit && this.inputWrapper && !this.readonly) {
        if (this.inputElement.value === "") {
          removeClass([this.inputWrapper.container], [EDITABLE]);
        } else {
          addClass([this.inputWrapper.container], [EDITABLE]);
        }
      } else if (this.inputWrapper) {
        removeClass([this.inputWrapper.container], [EDITABLE]);
      }
    };
    TimePicker2.prototype.validateDisable = function() {
      this.setMinMax(this.initMin, this.initMax);
      this.popupCreation();
      this.popupObj.destroy();
      this.popupWrapper = this.popupObj = null;
      if (!isNaN(+this.value) && this.value !== null) {
        if (!this.valueIsDisable(this.value)) {
          if (this.strictMode) {
            this.resetState();
          }
          this.initValue = null;
          this.initMax = this.getDateObject(this.initMax);
          this.initMin = this.getDateObject(this.initMin);
          this.timeCollections = this.liCollections = [];
          this.setMinMax(this.initMin, this.initMax);
        }
      }
    };
    TimePicker2.prototype.validationAttribute = function(target, input) {
      var name = target.getAttribute("name") ? target.getAttribute("name") : target.getAttribute("id");
      input.setAttribute("name", name);
      target.removeAttribute("name");
      var attributes2 = ["required", "aria-required", "form"];
      for (var i = 0; i < attributes2.length; i++) {
        if (isNullOrUndefined(target.getAttribute(attributes2[i]))) {
          continue;
        }
        var attr = target.getAttribute(attributes2[i]);
        input.setAttribute(attributes2[i], attr);
        target.removeAttribute(attributes2[i]);
      }
    };
    TimePicker2.prototype.initialize = function() {
      this.globalize = new Internationalization(this.locale);
      this.defaultCulture = new Internationalization("en");
      this.checkTimeFormat();
      this.checkInvalidValue(this.value);
      this.setProperties({ value: this.checkDateValue(new Date(this.checkInValue(this.value))) }, true);
      this.setProperties({ min: this.checkDateValue(new Date(this.checkInValue(this.min))) }, true);
      this.setProperties({ max: this.checkDateValue(new Date(this.checkInValue(this.max))) }, true);
      this.setProperties({ scrollTo: this.checkDateValue(new Date(this.checkInValue(this.scrollTo))) }, true);
      if (this.angularTag !== null) {
        this.validationAttribute(this.element, this.inputElement);
      }
      this.updateHtmlAttributeToElement();
      this.checkAttributes(false);
      var localeText = { placeholder: this.placeholder };
      this.l10n = new L10n("timepicker", localeText, this.locale);
      this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      this.initValue = this.checkDateValue(this.value);
      this.initMin = this.checkDateValue(this.min);
      this.initMax = this.checkDateValue(this.max);
      this.isNavigate = this.isPreventBlur = this.isTextSelected = false;
      this.activeIndex = this.valueWithMinutes = this.prevDate = null;
      if (!isNullOrUndefined(this.element.getAttribute("id"))) {
        if (this.angularTag !== null) {
          this.inputElement.id = this.element.getAttribute("id") + "_input";
        }
      } else {
        this.element.id = getUniqueID("ej2_timepicker");
        if (this.angularTag !== null) {
          attributes(this.inputElement, { "id": this.element.id + "_input" });
        }
      }
      if (isNullOrUndefined(this.inputElement.getAttribute("name"))) {
        attributes(this.inputElement, { "name": this.element.id });
      }
      if (this.enableMask) {
        this.notify("createMask", {
          module: "MaskedDateTime"
        });
      }
    };
    TimePicker2.prototype.checkTimeFormat = function() {
      if (this.format) {
        if (typeof this.format === "string") {
          this.formatString = this.format;
        } else if (!isNullOrUndefined(this.format.skeleton) && this.format.skeleton !== "") {
          var skeletonString = this.format.skeleton;
          this.formatString = this.globalize.getDatePattern({ type: "time", skeleton: skeletonString });
        } else {
          this.formatString = this.globalize.getDatePattern({ type: "time", skeleton: "short" });
        }
      } else {
        this.formatString = null;
      }
    };
    TimePicker2.prototype.checkDateValue = function(value) {
      return !isNullOrUndefined(value) && value instanceof Date && !isNaN(+value) ? value : null;
    };
    TimePicker2.prototype.createInputElement = function() {
      var updatedCssClassesValue = this.cssClass;
      var isBindClearAction = this.enableMask ? false : true;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassesValue = this.cssClass.replace(/\s+/g, " ").trim();
      }
      this.inputWrapper = Input.createInput({
        element: this.inputElement,
        bindClearAction: isBindClearAction,
        floatLabelType: this.floatLabelType,
        properties: {
          readonly: this.readonly,
          placeholder: this.placeholder,
          cssClass: updatedCssClassesValue,
          enabled: this.enabled,
          enableRtl: this.enableRtl,
          showClearButton: this.showClearButton
        },
        buttons: [" e-input-group-icon e-time-icon e-icons"]
      }, this.createElement);
      this.inputWrapper.container.style.width = this.setWidth(this.width);
      attributes(this.inputElement, {
        "aria-haspopup": "true",
        "aria-autocomplete": "list",
        "tabindex": "0",
        "aria-activedescendant": "null",
        "aria-owns": this.element.id + "_options",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off",
        "autocorrect": "off",
        "autocapitalize": "off",
        "spellcheck": "false",
        "aria-disabled": "false",
        "aria-invalid": "false"
      });
      if (!this.isNullOrEmpty(this.inputStyle)) {
        Input.addAttributes({ "style": this.inputStyle }, this.inputElement);
      }
      addClass([this.inputWrapper.container], WRAPPERCLASS);
    };
    TimePicker2.prototype.getCldrDateTimeFormat = function() {
      var culture = new Internationalization(this.locale);
      var cldrTime;
      var dateFormat = culture.getDatePattern({ skeleton: "yMd" });
      if (this.isNullOrEmpty(this.formatString)) {
        cldrTime = dateFormat + " " + this.cldrFormat("time");
      } else {
        cldrTime = this.formatString;
      }
      return cldrTime;
    };
    TimePicker2.prototype.checkInvalidValue = function(value) {
      var isInvalid = false;
      if (typeof value !== "object" && !isNullOrUndefined(value)) {
        var valueString = value;
        if (typeof valueString === "string") {
          valueString = valueString.trim();
        }
        var valueExpression = null;
        var valueExp = null;
        if (typeof value === "number") {
          valueString = value.toString();
        } else if (typeof value === "string") {
          if (!/^[a-zA-Z0-9- ]*$/.test(value)) {
            valueExpression = this.setCurrentDate(this.getDateObject(value));
            if (isNullOrUndefined(valueExpression)) {
              valueExpression = this.checkDateValue(this.globalize.parseDate(valueString, {
                format: this.getCldrDateTimeFormat(),
                type: "datetime"
              }));
              if (isNullOrUndefined(valueExpression)) {
                valueExpression = this.checkDateValue(this.globalize.parseDate(valueString, {
                  format: this.formatString,
                  type: "dateTime",
                  skeleton: "yMd"
                }));
              }
            }
          }
        }
        valueExp = this.globalize.parseDate(valueString, {
          format: this.getCldrDateTimeFormat(),
          type: "datetime"
        });
        valueExpression = !isNullOrUndefined(valueExp) && valueExp instanceof Date && !isNaN(+valueExp) ? valueExp : null;
        if (isNullOrUndefined(valueExpression) && valueString.replace(/\s/g, "").length) {
          var extISOString = null;
          var basicISOString = null;
          extISOString = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
          basicISOString = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
          if (!extISOString.test(valueString) && !basicISOString.test(valueString) || /^[a-zA-Z0-9- ]*$/.test(value) || isNaN(+/* @__PURE__ */ new Date("" + valueString))) {
            isInvalid = true;
          } else {
            valueExpression = /* @__PURE__ */ new Date("" + valueString);
          }
        }
        if (isInvalid) {
          if (!this.strictMode) {
            this.invalidValueString = valueString;
          }
          this.setProperties({ value: null }, true);
          this.initValue = null;
        } else {
          this.setProperties({ value: valueExpression }, true);
          this.initValue = this.value;
        }
      }
    };
    TimePicker2.prototype.requiredModules = function() {
      var modules = [];
      if (this.enableMask) {
        modules.push({ args: [this], member: "MaskedDateTime" });
      }
      return modules;
    };
    TimePicker2.prototype.cldrFormat = function(type) {
      var cldrDateTimeString;
      if (this.locale === "en" || this.locale === "en-US") {
        cldrDateTimeString = getValue("timeFormats.short", getDefaultDateObject());
      } else {
        cldrDateTimeString = this.getCultureTimeObject(cldrData, "" + this.locale);
      }
      return cldrDateTimeString;
    };
    TimePicker2.prototype.destroy = function() {
      this.hide();
      this.unBindEvents();
      var ariaAttribute = {
        "aria-haspopup": "true",
        "aria-autocomplete": "list",
        "tabindex": "0",
        "aria-activedescendant": "null",
        "aria-owns": this.element.id + "_options",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off",
        "autocorrect": "off",
        "autocapitalize": "off",
        "spellcheck": "false",
        "aria-disabled": "true",
        "aria-invalid": "false"
      };
      if (this.inputElement) {
        Input.removeAttributes(ariaAttribute, this.inputElement);
        if (this.angularTag === null) {
          this.inputWrapper.container.parentElement.appendChild(this.inputElement);
        }
        if (!isNullOrUndefined(this.cloneElement.getAttribute("tabindex"))) {
          this.inputElement.setAttribute("tabindex", this.tabIndex);
        } else {
          this.inputElement.removeAttribute("tabindex");
        }
        this.ensureInputAttribute();
        this.enableElement([this.inputElement]);
        this.inputElement.classList.remove("e-input");
        if (isNullOrUndefined(this.cloneElement.getAttribute("disabled"))) {
          Input.setEnabled(true, this.inputElement, this.floatLabelType);
        }
      }
      if (this.inputWrapper.container) {
        detach(this.inputWrapper.container);
      }
      this.inputWrapper = this.popupWrapper = this.cloneElement = void 0;
      this.liCollections = this.timeCollections = this.disableItemCollection = [];
      if (!isNullOrUndefined(this.rippleFn)) {
        this.rippleFn();
      }
      _super.prototype.destroy.call(this);
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
    };
    TimePicker2.prototype.ensureInputAttribute = function() {
      var propertyList = [];
      for (var i = 0; i < this.inputElement.attributes.length; i++) {
        propertyList[i] = this.inputElement.attributes[i].name;
      }
      for (var i = 0; i < propertyList.length; i++) {
        if (!isNullOrUndefined(this.cloneElement.getAttribute(propertyList[i]))) {
          this.inputElement.setAttribute(propertyList[i], this.cloneElement.getAttribute(propertyList[i]));
          if (propertyList[i].toLowerCase() === "value") {
            this.inputElement.value = this.cloneElement.getAttribute(propertyList[i]);
          }
        } else {
          this.inputElement.removeAttribute(propertyList[i]);
          if (propertyList[i].toLowerCase() === "value") {
            this.inputElement.value = "";
          }
        }
      }
    };
    TimePicker2.prototype.popupCreation = function() {
      this.popupWrapper = this.createElement("div", {
        className: ROOT4 + " " + POPUP3,
        attrs: { "id": this.element.id + "_popup", "style": "visibility:hidden" }
      });
      if (!isNullOrUndefined(this.cssClass)) {
        this.popupWrapper.className += " " + this.cssClass;
      }
      if (!isNullOrUndefined(this.step) && this.step > 0) {
        this.generateList();
        append([this.listWrapper], this.popupWrapper);
      }
      this.openPopupEventArgs.appendTo.appendChild(this.popupWrapper);
      this.addSelection();
      this.renderPopup();
      detach(this.popupWrapper);
    };
    TimePicker2.prototype.getPopupHeight = function() {
      var height = parseInt(POPUPDIMENSION, 10);
      var popupHeight = this.popupWrapper.getBoundingClientRect().height;
      return popupHeight > height ? height : popupHeight;
    };
    TimePicker2.prototype.generateList = function() {
      this.createListItems();
      this.wireListEvents();
      var rippleModel = { duration: 300, selector: "." + LISTCLASS2 };
      this.rippleFn = rippleEffect(this.listWrapper, rippleModel);
      this.liCollections = this.listWrapper.querySelectorAll("." + LISTCLASS2);
    };
    TimePicker2.prototype.renderPopup = function() {
      var _this = this;
      this.containerStyle = this.inputWrapper.container.getBoundingClientRect();
      this.popupObj = new Popup(this.popupWrapper, {
        width: this.setPopupWidth(this.width),
        zIndex: this.zIndex,
        targetType: "relative",
        position: Browser.isDevice ? { X: "center", Y: "center" } : { X: "left", Y: "bottom" },
        collision: Browser.isDevice ? { X: "fit", Y: "fit" } : { X: "flip", Y: "flip" },
        enableRtl: this.enableRtl,
        relateTo: Browser.isDevice ? document.body : this.inputWrapper.container,
        offsetY: OFFSETVAL,
        open: function() {
          _this.popupWrapper.style.visibility = "visible";
          addClass([_this.inputWrapper.buttons[0]], SELECTED4);
        },
        close: function() {
          removeClass([_this.inputWrapper.buttons[0]], SELECTED4);
          _this.unWireListEvents();
          _this.inputElement.setAttribute("aria-activedescendant", "null");
          remove(_this.popupObj.element);
          _this.popupObj.destroy();
          _this.popupWrapper.innerHTML = "";
          _this.listWrapper = _this.popupWrapper = _this.listTag = void 0;
        },
        targetExitViewport: function() {
          if (!Browser.isDevice) {
            _this.hide();
          }
        }
      });
      if (!Browser.isDevice) {
        this.popupObj.collision = { X: "none", Y: "flip" };
      }
      this.popupObj.element.style.maxHeight = POPUPDIMENSION;
    };
    TimePicker2.prototype.getFormattedValue = function(value) {
      if (isNullOrUndefined(this.checkDateValue(value))) {
        return null;
      } else {
        return this.globalize.formatDate(value, { skeleton: "medium", type: "time" });
      }
    };
    TimePicker2.prototype.getDateObject = function(text) {
      if (!this.isNullOrEmpty(text)) {
        var dateValue = this.createDateObj(text);
        var value = !this.isNullOrEmpty(this.initValue);
        if (this.checkDateValue(dateValue)) {
          var date = value ? this.initValue.getDate() : DAY;
          var month = value ? this.initValue.getMonth() : MONTH2;
          var year = value ? this.initValue.getFullYear() : YEAR2;
          return new Date(year, month, date, dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds());
        }
      }
      return null;
    };
    TimePicker2.prototype.updateHtmlAttributeToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (wrapperAttributes.indexOf(key) > -1) {
            if (key === "class") {
              var updatedClassesValue = this.htmlAttributes[key].replace(/\s+/g, " ").trim();
              if (updatedClassesValue !== "") {
                addClass([this.inputWrapper.container], updatedClassesValue.split(" "));
              }
            } else if (key === "style") {
              var timeStyle = this.inputWrapper.container.getAttribute(key);
              timeStyle = !isNullOrUndefined(timeStyle) ? timeStyle + this.htmlAttributes[key] : this.htmlAttributes[key];
              this.inputWrapper.container.setAttribute(key, timeStyle);
            } else {
              this.inputWrapper.container.setAttribute(key, this.htmlAttributes[key]);
            }
          }
        }
      }
    };
    TimePicker2.prototype.updateHtmlAttributeToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (wrapperAttributes.indexOf(key) < 0) {
            this.inputElement.setAttribute(key, this.htmlAttributes[key]);
          }
        }
      }
    };
    TimePicker2.prototype.updateCssClass = function(cssClassNew, cssClassOld) {
      if (!isNullOrUndefined(cssClassOld)) {
        cssClassOld = cssClassOld.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(cssClassNew)) {
        cssClassNew = cssClassNew.replace(/\s+/g, " ").trim();
      }
      Input.setCssClass(cssClassNew, [this.inputWrapper.container], cssClassOld);
      if (this.popupWrapper) {
        Input.setCssClass(cssClassNew, [this.popupWrapper], cssClassOld);
      }
    };
    TimePicker2.prototype.removeErrorClass = function() {
      removeClass([this.inputWrapper.container], ERROR3);
      attributes(this.inputElement, { "aria-invalid": "false" });
    };
    TimePicker2.prototype.checkErrorState = function(val) {
      var value = this.getDateObject(val);
      if (this.validateState(value) && !this.invalidValueString || this.enableMask && this.inputElement.value === this.maskedDateValue) {
        this.removeErrorClass();
      } else {
        addClass([this.inputWrapper.container], ERROR3);
        attributes(this.inputElement, { "aria-invalid": "true" });
      }
    };
    TimePicker2.prototype.validateInterval = function() {
      if (!isNullOrUndefined(this.step) && this.step > 0) {
        this.enableElement([this.inputWrapper.buttons[0]]);
      } else {
        this.disableTimeIcon();
      }
    };
    TimePicker2.prototype.disableTimeIcon = function() {
      this.disableElement([this.inputWrapper.buttons[0]]);
      this.hide();
    };
    TimePicker2.prototype.disableElement = function(element) {
      addClass(element, DISABLED3);
    };
    TimePicker2.prototype.enableElement = function(element) {
      removeClass(element, DISABLED3);
    };
    TimePicker2.prototype.selectInputText = function() {
      this.inputElement.setSelectionRange(0, this.inputElement.value.length);
    };
    TimePicker2.prototype.setCursorToEnd = function() {
      this.inputElement.setSelectionRange(this.inputElement.value.length, this.inputElement.value.length);
    };
    TimePicker2.prototype.getMeridianText = function() {
      var meridian;
      if (this.locale === "en" || this.locale === "en-US") {
        meridian = getValue("dayPeriods.format.wide", getDefaultDateObject());
      } else {
        var gregorianFormat = ".dates.calendars.gregorian.dayPeriods.format.abbreviated";
        var mainVal = "main.";
        meridian = getValue(mainVal + "" + this.locale + gregorianFormat, cldrData);
      }
      return meridian;
    };
    TimePicker2.prototype.getCursorSelection = function() {
      var input = this.inputElement;
      var start = 0;
      var end = 0;
      if (!isNaN(input.selectionStart)) {
        start = input.selectionStart;
        end = input.selectionEnd;
      }
      return { start: Math.abs(start), end: Math.abs(end) };
    };
    TimePicker2.prototype.getActiveElement = function() {
      if (!isNullOrUndefined(this.popupWrapper)) {
        return this.popupWrapper.querySelectorAll("." + SELECTED4);
      } else {
        return null;
      }
    };
    TimePicker2.prototype.isNullOrEmpty = function(value) {
      if (isNullOrUndefined(value) || typeof value === "string" && value.trim() === "") {
        return true;
      } else {
        return false;
      }
    };
    TimePicker2.prototype.setWidth = function(width) {
      if (typeof width === "number") {
        width = formatUnit(width);
      } else if (typeof width === "string") {
        width = width.match(/px|%|em/) ? width : formatUnit(width);
      } else {
        width = "100%";
      }
      return width;
    };
    TimePicker2.prototype.setPopupWidth = function(width) {
      width = this.setWidth(width);
      if (width.indexOf("%") > -1) {
        var inputWidth = this.containerStyle.width * parseFloat(width) / 100;
        width = inputWidth.toString() + "px";
      }
      return width;
    };
    TimePicker2.prototype.setScrollPosition = function() {
      var element = this.selectedElement;
      if (!isNullOrUndefined(element)) {
        this.findScrollTop(element);
      } else if (this.popupWrapper && this.checkDateValue(this.scrollTo)) {
        this.setScrollTo();
      }
    };
    TimePicker2.prototype.findScrollTop = function(element) {
      var listHeight = this.getPopupHeight();
      var nextEle = element.nextElementSibling;
      var height = nextEle ? nextEle.offsetTop : element.offsetTop;
      var liHeight = element.getBoundingClientRect().height;
      if (height + element.offsetTop > listHeight) {
        this.popupWrapper.scrollTop = nextEle ? height - (listHeight / HALFPOSITION + liHeight / HALFPOSITION) : height;
      } else {
        this.popupWrapper.scrollTop = 0;
      }
    };
    TimePicker2.prototype.setScrollTo = function() {
      var element;
      if (!isNullOrUndefined(this.popupWrapper)) {
        var items = this.popupWrapper.querySelectorAll("." + LISTCLASS2);
        if (items.length) {
          var initialTime = this.timeCollections[0];
          var scrollTime = this.getDateObject(this.checkDateValue(this.scrollTo)).getTime();
          element = items[Math.round((scrollTime - initialTime) / (this.step * 6e4))];
        }
      } else {
        this.popupWrapper.scrollTop = 0;
      }
      if (!isNullOrUndefined(element)) {
        this.findScrollTop(element);
      } else {
        this.popupWrapper.scrollTop = 0;
      }
    };
    TimePicker2.prototype.getText = function() {
      return isNullOrUndefined(this.checkDateValue(this.value)) ? "" : this.getValue(this.value);
    };
    TimePicker2.prototype.getValue = function(value) {
      return isNullOrUndefined(this.checkDateValue(value)) ? null : this.globalize.formatDate(value, {
        format: this.cldrTimeFormat(),
        type: "time"
      });
    };
    TimePicker2.prototype.cldrDateFormat = function() {
      var cldrDate;
      if (this.locale === "en" || this.locale === "en-US") {
        cldrDate = getValue("dateFormats.short", getDefaultDateObject());
      } else {
        cldrDate = this.getCultureDateObject(cldrData, "" + this.locale);
      }
      return cldrDate;
    };
    TimePicker2.prototype.cldrTimeFormat = function() {
      var cldrTime;
      if (this.isNullOrEmpty(this.formatString)) {
        if (this.locale === "en" || this.locale === "en-US") {
          cldrTime = getValue("timeFormats.short", getDefaultDateObject());
        } else {
          cldrTime = this.getCultureTimeObject(cldrData, "" + this.locale);
        }
      } else {
        cldrTime = this.formatString;
      }
      return cldrTime;
    };
    TimePicker2.prototype.dateToNumeric = function() {
      var cldrTime;
      if (this.locale === "en" || this.locale === "en-US") {
        cldrTime = getValue("timeFormats.medium", getDefaultDateObject());
      } else {
        cldrTime = getValue("main." + this.locale + ".dates.calendars.gregorian.timeFormats.medium", cldrData);
      }
      return cldrTime;
    };
    TimePicker2.prototype.getExactDateTime = function(value) {
      if (isNullOrUndefined(this.checkDateValue(value))) {
        return null;
      } else {
        return this.globalize.formatDate(value, { format: this.dateToNumeric(), type: "time" });
      }
    };
    TimePicker2.prototype.setValue = function(value) {
      var time = this.checkValue(value);
      if (!this.strictMode && !this.validateState(time)) {
        if (this.checkDateValue(this.valueWithMinutes) === null) {
          this.initValue = this.valueWithMinutes = null;
        }
        this.validateMinMax(this.value, this.min, this.max);
      } else {
        if (this.isNullOrEmpty(time)) {
          this.initValue = null;
          this.validateMinMax(this.value, this.min, this.max);
        } else {
          this.initValue = this.compareFormatChange(time);
        }
      }
      this.updateInput(true, this.initValue);
    };
    TimePicker2.prototype.compareFormatChange = function(value) {
      if (isNullOrUndefined(value)) {
        return null;
      }
      return value !== this.getText() ? this.getDateObject(value) : this.getDateObject(this.value);
    };
    TimePicker2.prototype.updatePlaceHolder = function() {
      Input.setPlaceholder(this.l10n.getConstant("placeholder"), this.inputElement);
    };
    TimePicker2.prototype.updateInputValue = function(value) {
      Input.setValue(value, this.inputElement, this.floatLabelType, this.showClearButton);
    };
    TimePicker2.prototype.preventEventBubbling = function(e) {
      e.preventDefault();
      this.interopAdaptor.invokeMethodAsync("OnTimeIconClick");
    };
    TimePicker2.prototype.popupHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (Browser.isDevice) {
        this.inputElement.setAttribute("readonly", "");
      }
      e.preventDefault();
      if (this.isPopupOpen()) {
        this.closePopup(0, e);
      } else {
        this.inputElement.focus();
        this.show(e);
      }
    };
    TimePicker2.prototype.mouseDownHandler = function() {
      if (!this.enabled) {
        return;
      }
      if (!this.readonly) {
        this.inputElement.setSelectionRange(0, 0);
        EventHandler.add(this.inputElement, "mouseup", this.mouseUpHandler, this);
      }
    };
    TimePicker2.prototype.mouseUpHandler = function(event) {
      if (!this.readonly) {
        event.preventDefault();
        if (this.enableMask) {
          event.preventDefault();
          this.notify("setMaskSelection", {
            module: "MaskedDateTime"
          });
          return;
        } else {
          EventHandler.remove(this.inputElement, "mouseup", this.mouseUpHandler);
          var curPos = this.getCursorSelection();
          if (!(curPos.start === 0 && curPos.end === this.inputElement.value.length)) {
            if (this.inputElement.value.length > 0) {
              this.cursorDetails = this.focusSelection();
            }
            this.inputElement.setSelectionRange(this.cursorDetails.start, this.cursorDetails.end);
          }
        }
      }
    };
    TimePicker2.prototype.focusSelection = function() {
      var regex = new RegExp("^[a-zA-Z0-9]+$");
      var split = this.inputElement.value.split("");
      split.push(" ");
      var curPos = this.getCursorSelection();
      var start = 0;
      var end = 0;
      var isSeparator = false;
      if (!this.isTextSelected) {
        for (var i = 0; i < split.length; i++) {
          if (!regex.test(split[i])) {
            end = i;
            isSeparator = true;
          }
          if (isSeparator) {
            if (curPos.start >= start && curPos.end <= end) {
              end = end;
              this.isTextSelected = true;
              break;
            } else {
              start = i + 1;
              isSeparator = false;
            }
          }
        }
      } else {
        start = curPos.start;
        end = curPos.end;
        this.isTextSelected = false;
      }
      return { start, end };
    };
    TimePicker2.prototype.inputHandler = function(event) {
      if (!this.readonly && this.enabled) {
        if (event.action !== "right" && event.action !== "left" && event.action !== "tab") {
          event.preventDefault();
        }
        switch (event.action) {
          case "home":
          case "end":
          case "up":
          case "down":
            if (this.enableMask && !this.readonly && !this.isPopupOpen()) {
              event.preventDefault();
              this.notify("keyDownHandler", {
                module: "MaskedDateTime",
                e: event
              });
            }
            if (!this.enableMask || this.isPopupOpen()) {
              this.keyHandler(event);
            }
            break;
          case "enter":
            if (this.isNavigate) {
              this.selectedElement = this.liCollections[this.activeIndex];
              this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);
              this.updateValue(this.valueWithMinutes, event);
            } else {
              this.updateValue(this.inputElement.value, event);
            }
            this.hide();
            this.isNavigate = false;
            if (this.isPopupOpen()) {
              event.stopPropagation();
            }
            break;
          case "open":
            this.show(event);
            break;
          case "escape":
            this.updateInputValue(this.objToString(this.value));
            if (this.enableMask) {
              if (!this.value) {
                this.updateInputValue(this.maskedDateValue);
              }
              this.createMask();
            }
            this.previousState(this.value);
            this.hide();
            break;
          case "close":
            this.hide();
            break;
          case "right":
          case "left":
          case "tab":
          case "shiftTab":
            if (!this.isPopupOpen() && this.enableMask && !this.readonly) {
              if (this.inputElement.selectionStart == 0 && this.inputElement.selectionEnd == this.inputElement.value.length || this.inputElement.selectionEnd !== this.inputElement.value.length && event.action == "tab" || this.inputElement.selectionStart !== 0 && event.action == "shiftTab" || (event.action == "left" || event.action == "right")) {
                event.preventDefault();
              }
              this.notify("keyDownHandler", {
                module: "MaskedDateTime",
                e: event
              });
            }
            break;
          default:
            this.isNavigate = false;
            break;
        }
      }
    };
    TimePicker2.prototype.onMouseClick = function(event) {
      var target = event.target;
      var li = this.selectedElement = closest(target, "." + LISTCLASS2);
      this.setSelection(li, event);
      if (li && li.classList.contains(LISTCLASS2)) {
        this.hide();
      }
    };
    TimePicker2.prototype.closePopup = function(delay, e) {
      var _this = this;
      if (this.isPopupOpen() && this.popupWrapper) {
        var args = {
          popup: this.popupObj,
          event: e || null,
          cancel: false,
          name: "open"
        };
        removeClass([document.body], OVERFLOW3);
        this.trigger("close", args, function(args2) {
          if (!args2.cancel) {
            var animModel = {
              name: "FadeOut",
              duration: ANIMATIONDURATION,
              delay: delay ? delay : 0
            };
            _this.popupObj.hide(new Animation(animModel));
            removeClass([_this.inputWrapper.container], [ICONANIMATION]);
            attributes(_this.inputElement, { "aria-expanded": "false" });
            EventHandler.remove(document, "mousedown touchstart", _this.documentClickHandler);
          }
          if (Browser.isDevice && _this.modal) {
            _this.modal.style.display = "none";
            _this.modal.outerHTML = "";
            _this.modal = null;
          }
          if (Browser.isDevice) {
            if (!isNullOrUndefined(_this.mobileTimePopupWrap)) {
              _this.mobileTimePopupWrap.remove();
              _this.mobileTimePopupWrap = null;
            }
          }
          if (Browser.isDevice && _this.allowEdit && !_this.readonly) {
            _this.inputElement.removeAttribute("readonly");
          }
        });
      } else {
        if (Browser.isDevice && this.allowEdit && !this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
      }
    };
    TimePicker2.prototype.disposeServerPopup = function() {
      if (this.popupWrapper) {
        this.popupWrapper.style.visibility = "hidden";
        this.popupWrapper.style.top = "-9999px";
        this.popupWrapper.style.left = "-9999px";
        this.popupWrapper.style.width = "0px";
        this.popupWrapper.style.height = "0px";
      }
    };
    TimePicker2.prototype.checkValueChange = function(event, isNavigation) {
      if (!this.strictMode && !this.validateState(this.valueWithMinutes)) {
        if (this.checkDateValue(this.valueWithMinutes) === null) {
          this.initValue = this.valueWithMinutes = null;
        }
        this.setProperties({ value: this.compareFormatChange(this.inputElement.value) }, true);
        this.initValue = this.valueWithMinutes = this.compareFormatChange(this.inputElement.value);
        this.prevValue = this.inputElement.value;
        if (+this.prevDate !== +this.value) {
          this.changeEvent(event);
        }
      } else {
        if (!isNavigation) {
          if (this.prevValue !== this.inputElement.value || isNullOrUndefined(this.checkDateValue(this.value))) {
            this.valueProcess(event, this.compareFormatChange(this.inputElement.value));
          }
        } else {
          var value = this.getDateObject(new Date(this.timeCollections[this.activeIndex]));
          if (+this.prevDate !== +value) {
            this.valueProcess(event, value);
          }
        }
      }
    };
    TimePicker2.prototype.onMouseOver = function(event) {
      var currentLi = closest(event.target, "." + LISTCLASS2);
      this.setHover(currentLi, HOVER2);
    };
    TimePicker2.prototype.setHover = function(li, className) {
      if (this.enabled && this.isValidLI(li) && !li.classList.contains(className)) {
        this.removeHover(className);
        addClass([li], className);
        if (className === NAVIGATION) {
          li.setAttribute("aria-selected", "true");
        }
      }
    };
    TimePicker2.prototype.setSelection = function(li, event) {
      if (this.isValidLI(li)) {
        this.checkValue(li.getAttribute("data-value"));
        if (this.enableMask) {
          this.notify("setMaskSelection", {
            module: "MaskedDateTime"
          });
        }
        this.selectedElement = li;
        this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);
        this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);
        addClass([this.selectedElement], SELECTED4);
        this.selectedElement.setAttribute("aria-selected", "true");
        this.checkValueChange(event, true);
      }
    };
    TimePicker2.prototype.onMouseLeave = function() {
      this.removeHover(HOVER2);
    };
    TimePicker2.prototype.scrollHandler = function() {
      if (this.getModuleName() === "timepicker" && Browser.isDevice) {
        return;
      } else {
        this.hide();
      }
    };
    TimePicker2.prototype.setMinMax = function(minVal, maxVal) {
      if (isNullOrUndefined(this.checkDateValue(minVal))) {
        this.initMin = this.getDateObject("12:00:00 AM");
      }
      if (isNullOrUndefined(this.checkDateValue(maxVal))) {
        this.initMax = this.getDateObject("11:59:59 PM");
      }
    };
    TimePicker2.prototype.validateMinMax = function(dateVal, minVal, maxVal) {
      var value = dateVal instanceof Date ? dateVal : this.getDateObject(dateVal);
      if (!isNullOrUndefined(this.checkDateValue(value))) {
        dateVal = this.strictOperation(this.initMin, this.initMax, dateVal, value);
      } else if (+this.createDateObj(this.getFormattedValue(this.initMin)) > +this.createDateObj(this.getFormattedValue(this.initMax))) {
        this.disableTimeIcon();
      }
      if (this.strictMode) {
        dateVal = this.valueIsDisable(dateVal) ? dateVal : null;
      }
      this.checkErrorState(dateVal);
      return dateVal;
    };
    TimePicker2.prototype.valueIsDisable = function(value) {
      if (this.disableItemCollection.length > 0) {
        if (this.disableItemCollection.length === this.timeCollections.length) {
          return false;
        }
        var time = value instanceof Date ? this.objToString(value) : value;
        for (var index = 0; index < this.disableItemCollection.length; index++) {
          if (time === this.disableItemCollection[index]) {
            return false;
          }
        }
      }
      return true;
    };
    TimePicker2.prototype.validateState = function(val) {
      if (!this.strictMode) {
        if (this.valueIsDisable(val)) {
          var value = typeof val === "string" ? this.setCurrentDate(this.getDateObject(val)) : this.setCurrentDate(this.getDateObject(val));
          var maxValue = this.setCurrentDate(this.getDateObject(this.initMax));
          var minValue = this.setCurrentDate(this.getDateObject(this.initMin));
          if (!isNullOrUndefined(this.checkDateValue(value))) {
            if (+value > +maxValue || +value < +minValue) {
              return false;
            }
          } else {
            if (+maxValue < +minValue || this.inputElement.value !== "") {
              return false;
            }
          }
        } else {
          return false;
        }
      }
      return true;
    };
    TimePicker2.prototype.strictOperation = function(minimum, maximum, dateVal, val) {
      var maxValue = this.createDateObj(this.getFormattedValue(maximum));
      var minValue = this.createDateObj(this.getFormattedValue(minimum));
      var value = this.createDateObj(this.getFormattedValue(val));
      if (this.strictMode) {
        if (+minValue > +maxValue) {
          this.disableTimeIcon();
          this.initValue = this.getDateObject(maxValue);
          this.updateInputValue(this.getValue(this.initValue));
          if (this.enableMask) {
            this.createMask();
          }
          return this.inputElement.value;
        } else if (+minValue >= +value) {
          return this.getDateObject(minValue);
        } else if (+value >= +maxValue || +minValue === +maxValue) {
          return this.getDateObject(maxValue);
        }
      } else {
        if (+minValue > +maxValue) {
          this.disableTimeIcon();
          if (!isNaN(+this.createDateObj(dateVal))) {
            return dateVal;
          }
        }
      }
      return dateVal;
    };
    TimePicker2.prototype.bindEvents = function() {
      EventHandler.add(this.inputWrapper.buttons[0], "mousedown", this.popupHandler, this);
      EventHandler.add(this.inputElement, "blur", this.inputBlurHandler, this);
      EventHandler.add(this.inputElement, "focus", this.inputFocusHandler, this);
      EventHandler.add(this.inputElement, "change", this.inputChangeHandler, this);
      EventHandler.add(this.inputElement, "input", this.inputEventHandler, this);
      if (this.enableMask) {
        EventHandler.add(this.inputElement, "keydown", this.keydownHandler, this);
      }
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown", this.clearHandler, this);
      }
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
      }
      if (!Browser.isDevice) {
        this.keyConfigure = extend(this.keyConfigure, this.keyConfigs);
        this.inputEvent = new KeyboardEvents(this.inputWrapper.container, {
          keyAction: this.inputHandler.bind(this),
          keyConfigs: this.keyConfigure,
          eventName: "keydown"
        });
        if (this.showClearButton && this.inputElement) {
          EventHandler.add(this.inputElement, "mousedown", this.mouseDownHandler, this);
        }
      }
    };
    TimePicker2.prototype.keydownHandler = function(e) {
      switch (e.code) {
        case "Delete":
          if (this.enableMask && !this.popupObj && !this.readonly) {
            this.notify("keyDownHandler", {
              module: "MaskedDateTime",
              e
            });
          }
          break;
        default:
          break;
      }
    };
    TimePicker2.prototype.formResetHandler = function() {
      if (!this.enabled) {
        return;
      }
      if (!this.inputElement.disabled) {
        var timeValue = this.inputElement.getAttribute("value");
        var val = this.checkDateValue(this.inputEleValue);
        if (this.element.tagName === "EJS-TIMEPICKER") {
          val = null;
          timeValue = "";
          this.inputElement.setAttribute("value", "");
        }
        this.setProperties({ value: val }, true);
        this.prevDate = this.value;
        this.valueWithMinutes = this.value;
        this.initValue = this.value;
        if (this.inputElement) {
          this.updateInputValue(timeValue);
          if (this.enableMask) {
            if (!timeValue) {
              this.updateInputValue(this.maskedDateValue);
            }
            this.createMask();
          }
          this.checkErrorState(timeValue);
          this.prevValue = this.inputElement.value;
        }
      }
    };
    TimePicker2.prototype.inputChangeHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      e.stopPropagation();
    };
    TimePicker2.prototype.inputEventHandler = function() {
      if (this.enableMask) {
        this.notify("inputHandler", {
          module: "MaskedDateTime"
        });
      }
    };
    TimePicker2.prototype.unBindEvents = function() {
      if (this.inputWrapper) {
        EventHandler.remove(this.inputWrapper.buttons[0], "mousedown touchstart", this.popupHandler);
      }
      EventHandler.remove(this.inputElement, "blur", this.inputBlurHandler);
      EventHandler.remove(this.inputElement, "focus", this.inputFocusHandler);
      EventHandler.remove(this.inputElement, "change", this.inputChangeHandler);
      EventHandler.remove(this.inputElement, "input", this.inputEventHandler);
      if (this.inputEvent) {
        this.inputEvent.destroy();
      }
      EventHandler.remove(this.inputElement, "mousedown touchstart", this.mouseDownHandler);
      if (this.showClearButton && !isNullOrUndefined(this.inputWrapper.clearButton)) {
        EventHandler.remove(this.inputWrapper.clearButton, "mousedown touchstart", this.clearHandler);
      }
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
    };
    TimePicker2.prototype.bindClearEvent = function() {
      if (this.showClearButton && this.inputWrapper.clearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown", this.clearHandler, this);
      }
    };
    TimePicker2.prototype.raiseClearedEvent = function(e) {
      var clearedArgs = {
        event: e
      };
      this.trigger("cleared", clearedArgs);
    };
    TimePicker2.prototype.clearHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      e.preventDefault();
      if (!isNullOrUndefined(this.value)) {
        this.clear(e);
      } else {
        this.resetState();
        this.raiseClearedEvent(e);
      }
      if (this.popupWrapper) {
        this.popupWrapper.scrollTop = 0;
      }
      if (this.enableMask) {
        this.notify("clearHandler", {
          module: "MaskedDateTime"
        });
      }
    };
    TimePicker2.prototype.clear = function(event) {
      this.setProperties({ value: null }, true);
      this.initValue = null;
      this.resetState();
      this.raiseClearedEvent(event);
      this.changeEvent(event);
    };
    TimePicker2.prototype.setZIndex = function() {
      if (this.popupObj) {
        this.popupObj.zIndex = this.zIndex;
        this.popupObj.dataBind();
      }
    };
    TimePicker2.prototype.checkAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["step", "disabled", "readonly", "style", "name", "value", "min", "max", "placeholder"];
      var value;
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {
          switch (prop) {
            case "disabled":
              if (isNullOrUndefined(this.timeOptions) || this.timeOptions["enabled"] === void 0 || isDynamic) {
                var enabled = this.inputElement.getAttribute(prop) === "disabled" || this.inputElement.getAttribute(prop) === "" || this.inputElement.getAttribute(prop) === "true" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "style":
              this.inputStyle = this.inputElement.getAttribute(prop);
              break;
            case "readonly":
              if (isNullOrUndefined(this.timeOptions) || this.timeOptions["readonly"] === void 0 || isDynamic) {
                var readonly = this.inputElement.getAttribute(prop) === "readonly" || this.inputElement.getAttribute(prop) === "" || this.inputElement.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "name":
              this.inputElement.setAttribute("name", this.inputElement.getAttribute(prop));
              break;
            case "step":
              this.step = parseInt(this.inputElement.getAttribute(prop), 10);
              break;
            case "placeholder":
              if (isNullOrUndefined(this.timeOptions) || this.timeOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.inputElement.getAttribute(prop) }, !isDynamic);
              }
              break;
            case "min":
              if (isNullOrUndefined(this.timeOptions) || this.timeOptions["min"] === void 0 || isDynamic) {
                value = new Date(this.inputElement.getAttribute(prop));
                if (!isNullOrUndefined(this.checkDateValue(value))) {
                  this.setProperties({ min: value }, !isDynamic);
                }
              }
              break;
            case "max":
              if (isNullOrUndefined(this.timeOptions) || this.timeOptions["max"] === void 0 || isDynamic) {
                value = new Date(this.inputElement.getAttribute(prop));
                if (!isNullOrUndefined(this.checkDateValue(value))) {
                  this.setProperties({ max: value }, !isDynamic);
                }
              }
              break;
            case "value":
              if (isNullOrUndefined(this.timeOptions) || this.timeOptions["value"] === void 0 || isDynamic) {
                value = new Date(this.inputElement.getAttribute(prop));
                if (!isNullOrUndefined(this.checkDateValue(value))) {
                  this.initValue = value;
                  this.updateInput(false, this.initValue);
                  this.setProperties({ value }, !isDynamic);
                }
              }
              break;
          }
        }
      }
    };
    TimePicker2.prototype.setCurrentDate = function(value) {
      if (isNullOrUndefined(this.checkDateValue(value))) {
        return null;
      }
      return new Date(YEAR2, MONTH2, DAY, value.getHours(), value.getMinutes(), value.getSeconds());
    };
    TimePicker2.prototype.getTextFormat = function() {
      var time = 0;
      if (this.cldrTimeFormat().split(" ")[0] === "a" || this.cldrTimeFormat().indexOf("a") === 0) {
        time = 1;
      } else if (this.cldrTimeFormat().indexOf("a") < 0) {
        var strArray = this.cldrTimeFormat().split(" ");
        for (var i = 0; i < strArray.length; i++) {
          if (strArray[i].toLowerCase().indexOf("h") >= 0) {
            time = i;
            break;
          }
        }
      }
      return time;
    };
    TimePicker2.prototype.updateValue = function(value, event) {
      var val;
      if (this.isNullOrEmpty(value)) {
        this.resetState();
      } else {
        val = this.checkValue(value);
        if (this.strictMode) {
          var inputVal = val === null && value.trim().length > 0 ? this.previousState(this.prevDate) : this.inputElement.value;
          this.updateInputValue(inputVal);
          if (this.enableMask) {
            if (!inputVal) {
              this.updateInputValue(this.maskedDateValue);
            }
            if (isNullOrUndefined(val) && value != this.maskedDateValue) {
              this.createMask();
            }
            if (isNullOrUndefined(val) && value == this.maskedDateValue) {
              this.updateInputValue(this.maskedDateValue);
            }
          }
        }
      }
      this.checkValueChange(event, typeof value === "string" ? false : true);
    };
    TimePicker2.prototype.previousState = function(date) {
      var value = this.getDateObject(date);
      for (var i = 0; i < this.timeCollections.length; i++) {
        if (+value === this.timeCollections[i]) {
          this.activeIndex = i;
          this.selectedElement = this.liCollections[i];
          this.valueWithMinutes = new Date(this.timeCollections[i]);
          break;
        }
      }
      return this.prevValue;
    };
    TimePicker2.prototype.resetState = function() {
      this.removeSelection();
      Input.setValue("", this.inputElement, this.floatLabelType, false);
      this.valueWithMinutes = this.activeIndex = null;
      if (!this.strictMode) {
        this.checkErrorState(null);
      }
    };
    TimePicker2.prototype.objToString = function(val) {
      if (isNullOrUndefined(this.checkDateValue(val))) {
        return null;
      } else {
        return this.globalize.formatDate(val, { format: this.cldrTimeFormat(), type: "time" });
      }
    };
    TimePicker2.prototype.checkValue = function(value) {
      if (!this.isNullOrEmpty(value)) {
        var date = value instanceof Date ? value : this.getDateObject(value);
        return this.validateValue(date, value);
      }
      this.resetState();
      return this.valueWithMinutes = null;
    };
    TimePicker2.prototype.validateValue = function(date, value) {
      var time;
      var val = this.validateMinMax(value, this.min, this.max);
      var newval = this.createDateObj(val);
      if (this.getFormattedValue(newval) !== this.getFormattedValue(this.value)) {
        this.valueWithMinutes = isNullOrUndefined(newval) ? null : newval;
        time = this.objToString(this.valueWithMinutes);
      } else {
        if (this.strictMode) {
          date = newval;
        }
        this.valueWithMinutes = this.checkDateValue(date);
        time = this.objToString(this.valueWithMinutes);
      }
      if (!this.strictMode && isNullOrUndefined(time)) {
        var value_1 = val.trim().length > 0 ? val : "";
        this.updateInputValue(value_1);
        if (this.enableMask) {
          if (!value_1) {
            this.updateInputValue(this.maskedDateValue);
          }
        }
      } else {
        this.updateInputValue(time);
        if (this.enableMask) {
          if (time == "") {
            this.updateInputValue(this.maskedDateValue);
          }
          if (isNullOrUndefined(time) && value != this.maskedDateValue) {
            this.createMask();
          }
          if (isNullOrUndefined(time) && value == this.maskedDateValue) {
            this.updateInputValue(this.maskedDateValue);
          }
        }
      }
      return time;
    };
    TimePicker2.prototype.createMask = function() {
      this.notify("createMask", {
        module: "MaskedDateTime"
      });
    };
    TimePicker2.prototype.findNextElement = function(event) {
      var textVal = this.inputElement.value;
      var value = isNullOrUndefined(this.valueWithMinutes) ? this.createDateObj(textVal) : this.getDateObject(this.valueWithMinutes);
      var timeVal = null;
      var count = this.liCollections.length;
      var collections = this.timeCollections;
      if (!isNullOrUndefined(this.checkDateValue(value)) || !isNullOrUndefined(this.activeIndex)) {
        if (event.action === "home") {
          var index = this.validLiElement(0);
          timeVal = +this.createDateObj(new Date(this.timeCollections[index]));
          this.activeIndex = index;
        } else if (event.action === "end") {
          var index = this.validLiElement(collections.length - 1, true);
          timeVal = +this.createDateObj(new Date(this.timeCollections[index]));
          this.activeIndex = index;
        } else {
          if (event.action === "down") {
            for (var i = 0; i < count; i++) {
              if (+value < this.timeCollections[i]) {
                var index = this.validLiElement(i);
                timeVal = +this.createDateObj(new Date(this.timeCollections[index]));
                this.activeIndex = index;
                break;
              } else if (i === count - 1) {
                var index = this.validLiElement(0);
                timeVal = +this.createDateObj(new Date(this.timeCollections[index]));
                this.activeIndex = index;
                break;
              }
            }
          } else {
            for (var i = count - 1; i >= 0; i--) {
              if (+value > this.timeCollections[i]) {
                var index = this.validLiElement(i, true);
                timeVal = +this.createDateObj(new Date(this.timeCollections[index]));
                this.activeIndex = index;
                break;
              } else if (i === 0) {
                var index = this.validLiElement(count - 1);
                timeVal = +this.createDateObj(new Date(this.timeCollections[index]));
                this.activeIndex = index;
                break;
              }
            }
          }
        }
        this.selectedElement = this.liCollections[this.activeIndex];
        this.elementValue(isNullOrUndefined(timeVal) ? null : new Date(timeVal));
      } else {
        this.selectNextItem(event);
      }
    };
    TimePicker2.prototype.selectNextItem = function(event) {
      var index = this.validLiElement(0, event.action === "down" ? false : true);
      this.activeIndex = index;
      this.selectedElement = this.liCollections[index];
      this.elementValue(new Date(this.timeCollections[index]));
    };
    TimePicker2.prototype.elementValue = function(value) {
      if (!isNullOrUndefined(this.checkDateValue(value))) {
        this.checkValue(value);
      }
    };
    TimePicker2.prototype.validLiElement = function(index, backward) {
      var elementIndex = null;
      var items = isNullOrUndefined(this.popupWrapper) ? this.liCollections : this.popupWrapper.querySelectorAll("." + LISTCLASS2);
      var isCheck = true;
      if (items.length) {
        if (backward) {
          for (var i = index; i >= 0; i--) {
            if (!items[i].classList.contains(DISABLED3)) {
              elementIndex = i;
              break;
            } else if (i === 0) {
              if (isCheck) {
                index = i = items.length;
                isCheck = false;
              }
            }
          }
        } else {
          for (var i = index; i <= items.length - 1; i++) {
            if (!items[i].classList.contains(DISABLED3)) {
              elementIndex = i;
              break;
            } else if (i === items.length - 1) {
              if (isCheck) {
                index = i = -1;
                isCheck = false;
              }
            }
          }
        }
      }
      return elementIndex;
    };
    TimePicker2.prototype.keyHandler = function(event) {
      if (isNullOrUndefined(this.step) || this.step <= 0 || this.inputWrapper.buttons[0].classList.contains(DISABLED3)) {
        return;
      }
      var count = this.timeCollections.length;
      if (isNullOrUndefined(this.getActiveElement()) || this.getActiveElement().length === 0) {
        if (this.liCollections.length > 0) {
          if (isNullOrUndefined(this.value) && isNullOrUndefined(this.activeIndex)) {
            var index = this.validLiElement(0, event.action === "down" ? false : true);
            this.activeIndex = index;
            this.selectedElement = this.liCollections[index];
            this.elementValue(new Date(this.timeCollections[index]));
          } else {
            this.findNextElement(event);
          }
        } else {
          this.findNextElement(event);
        }
      } else {
        var nextItem = void 0;
        if (event.keyCode >= 37 && event.keyCode <= 40) {
          var index = event.keyCode === 40 || event.keyCode === 39 ? ++this.activeIndex : --this.activeIndex;
          this.activeIndex = index = this.activeIndex === count ? 0 : this.activeIndex;
          this.activeIndex = index = this.activeIndex < 0 ? count - 1 : this.activeIndex;
          this.activeIndex = index = this.validLiElement(this.activeIndex, event.keyCode === 40 || event.keyCode === 39 ? false : true);
          nextItem = isNullOrUndefined(this.timeCollections[index]) ? this.timeCollections[0] : this.timeCollections[index];
        } else if (event.action === "home") {
          var index = this.validLiElement(0);
          this.activeIndex = index;
          nextItem = this.timeCollections[index];
        } else if (event.action === "end") {
          var index = this.validLiElement(count - 1, true);
          this.activeIndex = index;
          nextItem = this.timeCollections[index];
        }
        this.selectedElement = this.liCollections[this.activeIndex];
        this.elementValue(new Date(nextItem));
      }
      this.isNavigate = true;
      this.setHover(this.selectedElement, NAVIGATION);
      this.setActiveDescendant();
      this.selectInputText();
      if (this.isPopupOpen() && this.selectedElement !== null && (!event || event.type !== "click")) {
        this.setScrollPosition();
      }
    };
    TimePicker2.prototype.getCultureTimeObject = function(ld, c) {
      return getValue("main." + c + ".dates.calendars.gregorian.timeFormats.short", ld);
    };
    TimePicker2.prototype.getCultureDateObject = function(ld, c) {
      return getValue("main." + c + ".dates.calendars.gregorian.dateFormats.short", ld);
    };
    TimePicker2.prototype.wireListEvents = function() {
      EventHandler.add(this.listWrapper, "click", this.onMouseClick, this);
      if (!Browser.isDevice) {
        EventHandler.add(this.listWrapper, "mouseover", this.onMouseOver, this);
        EventHandler.add(this.listWrapper, "mouseout", this.onMouseLeave, this);
      }
    };
    TimePicker2.prototype.unWireListEvents = function() {
      if (this.listWrapper) {
        EventHandler.remove(this.listWrapper, "click", this.onMouseClick);
        if (!Browser.isDevice) {
          EventHandler.remove(this.listWrapper, "mouseover", this.onMouseOver);
          EventHandler.remove(this.listWrapper, "mouseout", this.onMouseLeave);
        }
      }
    };
    TimePicker2.prototype.valueProcess = function(event, value) {
      var result = isNullOrUndefined(this.checkDateValue(value)) ? null : value;
      if (+this.prevDate !== +result) {
        this.initValue = result;
        this.changeEvent(event);
      }
    };
    TimePicker2.prototype.changeEvent = function(e) {
      this.addSelection();
      this.updateInput(true, this.initValue);
      var eventArgs = {
        event: e || null,
        value: this.value,
        text: this.inputElement.value,
        isInteracted: !isNullOrUndefined(e),
        element: this.element
      };
      eventArgs.value = this.valueWithMinutes || this.getDateObject(this.inputElement.value);
      this.prevDate = this.valueWithMinutes || this.getDateObject(this.inputElement.value);
      if (this.isAngular && this.preventChange) {
        this.preventChange = false;
      } else {
        this.trigger("change", eventArgs);
      }
      this.invalidValueString = null;
      this.checkErrorState(this.value);
    };
    TimePicker2.prototype.updateInput = function(isUpdate, date) {
      if (isUpdate) {
        this.prevValue = this.getValue(date);
      }
      this.prevDate = this.valueWithMinutes = date;
      if (typeof date !== "number" || (this.value && +(/* @__PURE__ */ new Date(+this.value)).setMilliseconds(0)) !== +date) {
        this.setProperties({ value: date }, true);
        if (this.enableMask) {
          this.createMask();
        }
      }
      if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {
        this.checkErrorState(this.invalidValueString);
        this.updateInputValue(this.invalidValueString);
      }
      this.clearIconState();
    };
    TimePicker2.prototype.setActiveDescendant = function() {
      if (!isNullOrUndefined(this.selectedElement)) {
        attributes(this.inputElement, { "aria-activedescendant": this.selectedElement.getAttribute("id") });
      } else {
        attributes(this.inputElement, { "aria-activedescendant": "null" });
      }
    };
    TimePicker2.prototype.removeSelection = function() {
      this.removeHover(HOVER2);
      if (!isNullOrUndefined(this.popupWrapper)) {
        var items = this.popupWrapper.querySelectorAll("." + SELECTED4);
        if (items.length) {
          removeClass(items, SELECTED4);
          items[0].removeAttribute("aria-selected");
        }
      }
    };
    TimePicker2.prototype.removeHover = function(className) {
      var hoveredItem = this.getHoverItem(className);
      if (hoveredItem && hoveredItem.length) {
        removeClass(hoveredItem, className);
        if (className === NAVIGATION) {
          hoveredItem[0].removeAttribute("aria-selected");
        }
      }
    };
    TimePicker2.prototype.getHoverItem = function(className) {
      var hoveredItem;
      if (!isNullOrUndefined(this.popupWrapper)) {
        hoveredItem = this.popupWrapper.querySelectorAll("." + className);
      }
      return hoveredItem;
    };
    TimePicker2.prototype.setActiveClass = function() {
      if (!isNullOrUndefined(this.popupWrapper)) {
        var items = this.popupWrapper.querySelectorAll("." + LISTCLASS2);
        if (items.length) {
          for (var i = 0; i < items.length; i++) {
            if (this.timeCollections[i] === +this.getDateObject(this.valueWithMinutes)) {
              items[i].setAttribute("aria-selected", "true");
              this.selectedElement = items[i];
              this.activeIndex = i;
              break;
            }
          }
        }
      }
    };
    TimePicker2.prototype.addSelection = function() {
      this.selectedElement = null;
      this.removeSelection();
      this.setActiveClass();
      if (!isNullOrUndefined(this.selectedElement)) {
        addClass([this.selectedElement], SELECTED4);
        this.selectedElement.setAttribute("aria-selected", "true");
      }
    };
    TimePicker2.prototype.isValidLI = function(li) {
      return li && li.classList.contains(LISTCLASS2) && !li.classList.contains(DISABLED3);
    };
    TimePicker2.prototype.createDateObj = function(val) {
      var formatStr = null;
      var today = this.globalize.formatDate(/* @__PURE__ */ new Date(), { format: formatStr, skeleton: "short", type: "date" });
      var value = null;
      if (typeof val === "string") {
        if (val.toUpperCase().indexOf("AM") > -1 || val.toUpperCase().indexOf("PM") > -1) {
          today = this.defaultCulture.formatDate(/* @__PURE__ */ new Date(), { format: formatStr, skeleton: "short", type: "date" });
          value = isNaN(+/* @__PURE__ */ new Date(today + " " + val)) ? null : new Date((/* @__PURE__ */ new Date(today + " " + val)).setMilliseconds(0));
          if (isNullOrUndefined(value)) {
            value = this.timeParse(today, val);
          }
        } else {
          value = this.timeParse(today, val);
        }
      } else if (val instanceof Date) {
        value = val;
      }
      return value;
    };
    TimePicker2.prototype.timeParse = function(today, val) {
      var value;
      value = this.globalize.parseDate(today + " " + val, {
        format: this.cldrDateFormat() + " " + this.cldrTimeFormat(),
        type: "datetime"
      });
      value = isNullOrUndefined(value) ? this.globalize.parseDate(today + " " + val, {
        format: this.cldrDateFormat() + " " + this.dateToNumeric(),
        type: "datetime"
      }) : value;
      value = isNullOrUndefined(value) ? value : new Date(value.setMilliseconds(0));
      return value;
    };
    TimePicker2.prototype.createListItems = function() {
      var _this = this;
      this.listWrapper = this.createElement("div", { className: CONTENT3, attrs: { "tabindex": "0" } });
      var start;
      var interval = this.step * 6e4;
      var listItems = [];
      this.timeCollections = [];
      this.disableItemCollection = [];
      start = +this.getDateObject(this.initMin).setMilliseconds(0);
      var end = +this.getDateObject(this.initMax).setMilliseconds(0);
      while (end >= start) {
        this.timeCollections.push(start);
        listItems.push(this.globalize.formatDate(new Date(start), { format: this.cldrTimeFormat(), type: "time" }));
        start += interval;
      }
      var listBaseOptions = {
        itemCreated: function(args) {
          var eventArgs = {
            element: args.item,
            text: args.text,
            value: _this.getDateObject(args.text),
            isDisabled: false
          };
          _this.trigger("itemRender", eventArgs, function(eventArgs2) {
            if (eventArgs2.isDisabled) {
              eventArgs2.element.classList.add(DISABLED3);
            }
            if (eventArgs2.element.classList.contains(DISABLED3)) {
              _this.disableItemCollection.push(eventArgs2.element.getAttribute("data-value"));
            }
          });
        }
      };
      this.listTag = ListBase.createList(this.createElement, listItems, listBaseOptions, true);
      attributes(this.listTag, { "role": "listbox", "aria-hidden": "false", "id": this.element.id + "_options" });
      append([this.listTag], this.listWrapper);
    };
    TimePicker2.prototype.documentClickHandler = function(event) {
      var target = event.target;
      if (!isNullOrUndefined(this.popupObj) && (this.inputWrapper.container.contains(target) || this.popupObj.element && this.popupObj.element.contains(target)) && event.type !== "touchstart") {
        event.preventDefault();
      }
      if (!closest(target, '[id="' + this.popupObj.element.id + '"]') && target !== this.inputElement && target !== (this.inputWrapper && this.inputWrapper.buttons[0]) && target !== (this.inputWrapper && this.inputWrapper.clearButton) && target !== (this.inputWrapper && this.inputWrapper.container)) {
        if (this.isPopupOpen()) {
          this.hide();
          this.focusOut();
        }
      } else if (target !== this.inputElement) {
        if (!Browser.isDevice) {
          this.isPreventBlur = (Browser.isIE || Browser.info.name === "edge") && document.activeElement === this.inputElement && target === this.popupWrapper;
        }
      }
    };
    TimePicker2.prototype.setEnableRtl = function() {
      Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);
      if (this.popupObj) {
        this.popupObj.enableRtl = this.enableRtl;
        this.popupObj.dataBind();
      }
    };
    TimePicker2.prototype.setEnable = function() {
      Input.setEnabled(this.enabled, this.inputElement, this.floatLabelType);
      if (this.enabled) {
        removeClass([this.inputWrapper.container], DISABLED3);
        attributes(this.inputElement, { "aria-disabled": "false" });
        this.inputElement.setAttribute("tabindex", this.tabIndex);
      } else {
        this.hide();
        addClass([this.inputWrapper.container], DISABLED3);
        attributes(this.inputElement, { "aria-disabled": "true" });
        this.inputElement.tabIndex = -1;
      }
    };
    TimePicker2.prototype.getProperty = function(date, val) {
      if (val === "min") {
        this.initMin = this.checkDateValue(new Date(this.checkInValue(date.min)));
        this.setProperties({ min: this.initMin }, true);
      } else {
        this.initMax = this.checkDateValue(new Date(this.checkInValue(date.max)));
        this.setProperties({ max: this.initMax }, true);
      }
      if (this.inputElement.value === "") {
        this.validateMinMax(this.value, this.min, this.max);
      } else {
        this.checkValue(this.inputElement.value);
      }
      this.checkValueChange(null, false);
    };
    TimePicker2.prototype.inputBlurHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (this.isPreventBlur && this.isPopupOpen()) {
        this.inputElement.focus();
        return;
      }
      this.closePopup(0, e);
      if (this.enableMask && this.maskedDateValue && this.placeholder && this.floatLabelType !== "Always") {
        if (this.inputElement.value == this.maskedDateValue && !this.value && (this.floatLabelType == "Auto" || this.floatLabelType == "Never" || this.placeholder)) {
          this.updateInputValue("");
        }
      }
      removeClass([this.inputWrapper.container], [FOCUS]);
      var blurArguments = {
        model: this
      };
      this.trigger("blur", blurArguments);
      if (this.getText() !== this.inputElement.value) {
        this.updateValue(this.inputElement.value, e);
      } else if (this.inputElement.value.trim().length === 0) {
        this.resetState();
      }
      this.cursorDetails = null;
      this.isNavigate = false;
      if (this.inputElement.value === "") {
        this.invalidValueString = null;
      }
    };
    TimePicker2.prototype.focusOut = function() {
      if (document.activeElement === this.inputElement) {
        this.inputElement.blur();
        removeClass([this.inputWrapper.container], [FOCUS]);
        var blurArguments = {
          model: this
        };
        this.trigger("blur", blurArguments);
      }
    };
    TimePicker2.prototype.isPopupOpen = function() {
      if (this.popupWrapper && this.popupWrapper.classList.contains("" + ROOT4)) {
        return true;
      }
      return false;
    };
    TimePicker2.prototype.inputFocusHandler = function() {
      if (!this.enabled) {
        return;
      }
      var focusArguments = {
        model: this
      };
      if (!this.readonly && !Browser.isDevice && !this.enableMask) {
        this.selectInputText();
      }
      if (this.enableMask && !this.inputElement.value && this.placeholder) {
        if (this.maskedDateValue && !this.value && (this.floatLabelType == "Auto" || this.floatLabelType == "Never" || this.placeholder)) {
          this.updateInputValue(this.maskedDateValue);
          this.inputElement.selectionStart = 0;
          this.inputElement.selectionEnd = this.inputElement.value.length;
        }
      }
      this.trigger("focus", focusArguments);
      this.clearIconState();
      if (this.openOnFocus) {
        this.show();
      }
    };
    TimePicker2.prototype.focusIn = function() {
      if (document.activeElement !== this.inputElement && this.enabled) {
        this.inputElement.focus();
      }
    };
    TimePicker2.prototype.hide = function() {
      this.closePopup(100, null);
      this.clearIconState();
    };
    TimePicker2.prototype.show = function(event) {
      var _this = this;
      if (this.enabled && this.readonly || !this.enabled || this.popupWrapper) {
        return;
      } else {
        this.popupCreation();
        if (Browser.isDevice && this.listWrapper) {
          this.modal = this.createElement("div");
          this.modal.className = "" + ROOT4 + " e-time-modal";
          document.body.className += " " + OVERFLOW3;
          document.body.appendChild(this.modal);
        }
        if (Browser.isDevice) {
          this.mobileTimePopupWrap = this.createElement("div", { className: "e-timepicker-mob-popup-wrap" });
          document.body.appendChild(this.mobileTimePopupWrap);
        }
        this.openPopupEventArgs = {
          popup: this.popupObj || null,
          cancel: false,
          event: event || null,
          name: "open",
          appendTo: Browser.isDevice ? this.mobileTimePopupWrap : document.body
        };
        var eventArgs = this.openPopupEventArgs;
        this.trigger("open", eventArgs, function(eventArgs2) {
          _this.openPopupEventArgs = eventArgs2;
          if (!_this.openPopupEventArgs.cancel && !_this.inputWrapper.buttons[0].classList.contains(DISABLED3)) {
            _this.openPopupEventArgs.appendTo.appendChild(_this.popupWrapper);
            _this.popupAlignment(_this.openPopupEventArgs);
            _this.setScrollPosition();
            if (!Browser.isDevice) {
              _this.inputElement.focus();
            }
            var openAnimation = {
              name: "FadeIn",
              duration: ANIMATIONDURATION
            };
            _this.popupObj.refreshPosition(_this.anchor);
            if (_this.zIndex === 1e3) {
              _this.popupObj.show(new Animation(openAnimation), _this.element);
            } else {
              _this.popupObj.show(new Animation(openAnimation), null);
            }
            _this.setActiveDescendant();
            attributes(_this.inputElement, { "aria-expanded": "true" });
            addClass([_this.inputWrapper.container], FOCUS);
            EventHandler.add(document, "mousedown touchstart", _this.documentClickHandler, _this);
            _this.setOverlayIndex(_this.mobileTimePopupWrap, _this.popupObj.element, _this.modal, Browser.isDevice);
          } else {
            _this.popupObj.destroy();
            _this.popupWrapper = _this.listTag = void 0;
            _this.liCollections = _this.timeCollections = _this.disableItemCollection = [];
            _this.popupObj = null;
          }
        });
      }
    };
    TimePicker2.prototype.setOverlayIndex = function(popupWrapper, timePopupElement, modal, isDevice) {
      if (isDevice && !isNullOrUndefined(timePopupElement) && !isNullOrUndefined(modal) && !isNullOrUndefined(popupWrapper)) {
        var index = parseInt(timePopupElement.style.zIndex, 10) ? parseInt(timePopupElement.style.zIndex, 10) : 1e3;
        modal.style.zIndex = (index - 1).toString();
        popupWrapper.style.zIndex = index.toString();
      }
    };
    TimePicker2.prototype.formatValues = function(type) {
      var value;
      if (typeof type === "number") {
        value = formatUnit(type);
      } else if (typeof type === "string") {
        value = type.match(/px|%|em/) ? type : isNaN(parseInt(type, 10)) ? type : formatUnit(type);
      }
      return value;
    };
    TimePicker2.prototype.popupAlignment = function(args) {
      args.popup.position.X = this.formatValues(args.popup.position.X);
      args.popup.position.Y = this.formatValues(args.popup.position.Y);
      if (!isNaN(parseFloat(args.popup.position.X)) || !isNaN(parseFloat(args.popup.position.Y))) {
        this.popupObj.relateTo = this.anchor = document.body;
        this.popupObj.targetType = "container";
      }
      if (!isNaN(parseFloat(args.popup.position.X))) {
        this.popupObj.offsetX = parseFloat(args.popup.position.X);
      }
      if (!isNaN(parseFloat(args.popup.position.Y))) {
        this.popupObj.offsetY = parseFloat(args.popup.position.Y);
      }
      if (!Browser.isDevice) {
        switch (args.popup.position.X) {
          case "left":
            break;
          case "right":
            args.popup.offsetX = this.containerStyle.width;
            break;
          case "center":
            args.popup.offsetX = -(this.containerStyle.width / 2);
            break;
        }
        switch (args.popup.position.Y) {
          case "top":
            break;
          case "bottom":
            break;
          case "center":
            args.popup.offsetY = -(this.containerStyle.height / 2);
            break;
        }
        if (args.popup.position.X === "center" && args.popup.position.Y === "center") {
          this.popupObj.relateTo = this.inputWrapper.container;
          this.anchor = this.inputElement;
          this.popupObj.targetType = "relative";
        }
      } else {
        if (args.popup.position.X === "center" && args.popup.position.Y === "center") {
          this.popupObj.relateTo = this.anchor = document.body;
          this.popupObj.offsetY = 0;
          this.popupObj.targetType = "container";
          this.popupObj.collision = { X: "fit", Y: "fit" };
        }
      }
    };
    TimePicker2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    TimePicker2.prototype.getModuleName = function() {
      return "timepicker";
    };
    TimePicker2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "placeholder":
            Input.setPlaceholder(newProp.placeholder, this.inputElement);
            this.inputElement.setAttribute("aria-placeholder", newProp.placeholder);
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.inputElement, this.floatLabelType);
            if (this.readonly) {
              this.hide();
            }
            this.setTimeAllowEdit();
            break;
          case "enabled":
            this.setProperties({ enabled: newProp.enabled }, true);
            this.setEnable();
            break;
          case "allowEdit":
            this.setTimeAllowEdit();
            break;
          case "enableRtl":
            this.setProperties({ enableRtl: newProp.enableRtl }, true);
            this.setEnableRtl();
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "zIndex":
            this.setProperties({ zIndex: newProp.zIndex }, true);
            this.setZIndex();
            break;
          case "htmlAttributes":
            this.updateHtmlAttributeToElement();
            this.updateHtmlAttributeToWrapper();
            this.checkAttributes(true);
            break;
          case "min":
          case "max":
            this.getProperty(newProp, prop);
            break;
          case "showClearButton":
            Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);
            this.bindClearEvent();
            break;
          case "locale":
            this.setProperties({ locale: newProp.locale }, true);
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.updatePlaceHolder();
            this.setValue(this.value);
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
            }
            break;
          case "width":
            setStyleAttribute(this.inputWrapper.container, { "width": this.setWidth(newProp.width) });
            this.containerStyle = this.inputWrapper.container.getBoundingClientRect();
            break;
          case "format":
            this.setProperties({ format: newProp.format }, true);
            this.checkTimeFormat();
            this.setValue(this.value);
            if (this.enableMask) {
              this.createMask();
              if (!this.value) {
                this.updateInputValue(this.maskedDateValue);
              }
            }
            break;
          case "value":
            this.invalidValueString = null;
            this.checkInvalidValue(newProp.value);
            newProp.value = this.value;
            if (!this.invalidValueString) {
              if (typeof newProp.value === "string") {
                this.setProperties({ value: this.checkDateValue(new Date(newProp.value)) }, true);
                newProp.value = this.value;
              } else {
                if ((newProp.value && +(/* @__PURE__ */ new Date(+newProp.value)).setMilliseconds(0)) !== +this.value) {
                  newProp.value = this.checkDateValue(/* @__PURE__ */ new Date("" + newProp.value));
                }
              }
              this.initValue = newProp.value;
              newProp.value = this.compareFormatChange(this.checkValue(newProp.value));
            } else {
              this.updateInputValue(this.invalidValueString);
              this.checkErrorState(this.invalidValueString);
            }
            this.checkValueChange(null, false);
            if (this.isPopupOpen()) {
              this.setScrollPosition();
            }
            if (this.isAngular && this.preventChange) {
              this.preventChange = false;
            }
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
            }
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            Input.removeFloating(this.inputWrapper);
            Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);
            break;
          case "strictMode":
            this.invalidValueString = null;
            if (newProp.strictMode) {
              this.checkErrorState(null);
            }
            this.setProperties({ strictMode: newProp.strictMode }, true);
            this.checkValue(this.inputElement.value);
            this.checkValueChange(null, false);
            break;
          case "scrollTo":
            if (this.checkDateValue(new Date(this.checkInValue(newProp.scrollTo)))) {
              if (this.popupWrapper) {
                this.setScrollTo();
              }
              this.setProperties({ scrollTo: this.checkDateValue(new Date(this.checkInValue(newProp.scrollTo))) }, true);
            } else {
              this.setProperties({ scrollTo: null }, true);
            }
            break;
          case "enableMask":
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
              this.updateInputValue(this.maskedDateValue);
            } else {
              if (this.inputElement.value === this.maskedDateValue) {
                this.updateInputValue("");
              }
            }
            break;
        }
      }
    };
    TimePicker2.prototype.checkInValue = function(inValue) {
      if (inValue instanceof Date) {
        return inValue.toUTCString();
      } else {
        return "" + inValue;
      }
    };
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "width", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "cssClass", void 0);
    __decorate4([
      Property(false)
    ], TimePicker2.prototype, "strictMode", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "keyConfigs", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "format", void 0);
    __decorate4([
      Property(true)
    ], TimePicker2.prototype, "enabled", void 0);
    __decorate4([
      Property(false)
    ], TimePicker2.prototype, "readonly", void 0);
    __decorate4([
      Property({})
    ], TimePicker2.prototype, "htmlAttributes", void 0);
    __decorate4([
      Property("Never")
    ], TimePicker2.prototype, "floatLabelType", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "placeholder", void 0);
    __decorate4([
      Property(1e3)
    ], TimePicker2.prototype, "zIndex", void 0);
    __decorate4([
      Property(false)
    ], TimePicker2.prototype, "enablePersistence", void 0);
    __decorate4([
      Property(true)
    ], TimePicker2.prototype, "showClearButton", void 0);
    __decorate4([
      Property(30)
    ], TimePicker2.prototype, "step", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "scrollTo", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "value", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "min", void 0);
    __decorate4([
      Property(null)
    ], TimePicker2.prototype, "max", void 0);
    __decorate4([
      Property(true)
    ], TimePicker2.prototype, "allowEdit", void 0);
    __decorate4([
      Property(false)
    ], TimePicker2.prototype, "openOnFocus", void 0);
    __decorate4([
      Property(false)
    ], TimePicker2.prototype, "enableMask", void 0);
    __decorate4([
      Property({ day: "day", month: "month", year: "year", hour: "hour", minute: "minute", second: "second", dayOfTheWeek: "day of the week" })
    ], TimePicker2.prototype, "maskPlaceholder", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "change", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "created", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "destroyed", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "open", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "itemRender", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "close", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "cleared", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "blur", void 0);
    __decorate4([
      Event()
    ], TimePicker2.prototype, "focus", void 0);
    TimePicker2 = __decorate4([
      NotifyPropertyChanges
    ], TimePicker2);
    return TimePicker2;
  }(Component)
);

// node_modules/@syncfusion/ej2-calendars/src/datetimepicker/datetimepicker.js
var __extends48 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DATEWRAPPER2 = "e-date-wrapper";
var DATEPICKERROOT = "e-datepicker";
var DATETIMEWRAPPER = "e-datetime-wrapper";
var DAY2 = (/* @__PURE__ */ new Date()).getDate();
var MONTH3 = (/* @__PURE__ */ new Date()).getMonth();
var YEAR3 = (/* @__PURE__ */ new Date()).getFullYear();
var HOUR = (/* @__PURE__ */ new Date()).getHours();
var MINUTE = (/* @__PURE__ */ new Date()).getMinutes();
var SECOND = (/* @__PURE__ */ new Date()).getSeconds();
var MILLISECOND = (/* @__PURE__ */ new Date()).getMilliseconds();
var ROOT5 = "e-datetimepicker";
var DATETIMEPOPUPWRAPPER = "e-datetimepopup-wrapper";
var INPUTWRAPPER2 = "e-input-group-icon";
var POPUP4 = "e-popup";
var TIMEICON = "e-time-icon";
var INPUTFOCUS3 = "e-input-focus";
var POPUPDIMENSION2 = "250px";
var ICONANIMATION2 = "e-icon-anim";
var DISABLED4 = "e-disabled";
var ERROR4 = "e-error";
var CONTENT4 = "e-content";
var NAVIGATION2 = "e-navigation";
var ACTIVE3 = "e-active";
var HOVER3 = "e-hover";
var ICONS2 = "e-icons";
var HALFPOSITION2 = 2;
var LISTCLASS3 = "e-list-item";
var ANIMATIONDURATION2 = 100;
var OVERFLOW4 = "e-time-overflow";
var DateTimePicker = (
  /** @class */
  function(_super) {
    __extends48(DateTimePicker2, _super);
    function DateTimePicker2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.valueWithMinutes = null;
      _this.scrollInvoked = false;
      _this.moduleName = _this.getModuleName();
      _this.dateTimeOptions = options;
      return _this;
    }
    DateTimePicker2.prototype.focusHandler = function() {
      if (!this.enabled) {
        return;
      }
      addClass([this.inputWrapper.container], INPUTFOCUS3);
    };
    DateTimePicker2.prototype.focusIn = function() {
      _super.prototype.focusIn.call(this);
    };
    DateTimePicker2.prototype.focusOut = function() {
      if (document.activeElement === this.inputElement) {
        this.inputElement.blur();
        removeClass([this.inputWrapper.container], [INPUTFOCUS3]);
      }
    };
    DateTimePicker2.prototype.blurHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (this.isTimePopupOpen() && this.isPreventBlur) {
        this.inputElement.focus();
        return;
      }
      removeClass([this.inputWrapper.container], INPUTFOCUS3);
      var blurArguments = {
        model: this
      };
      if (this.isTimePopupOpen()) {
        this.hide(e);
      }
      this.trigger("blur", blurArguments);
    };
    DateTimePicker2.prototype.destroy = function() {
      if (this.popupObject && this.popupObject.element.classList.contains(POPUP4)) {
        this.popupObject.destroy();
        detach(this.dateTimeWrapper);
        this.dateTimeWrapper = void 0;
        this.liCollections = this.timeCollections = [];
        if (!isNullOrUndefined(this.rippleFn)) {
          this.rippleFn();
        }
      }
      var ariaAttribute = {
        "aria-live": "assertive",
        "aria-atomic": "true",
        "aria-invalid": "false",
        "aria-haspopup": "true",
        "aria-activedescendant": "null",
        "autocorrect": "off",
        "autocapitalize": "off",
        "spellcheck": "false",
        "aria-owns": this.element.id + "_options",
        "aria-expanded": "false",
        "role": "combobox",
        "autocomplete": "off"
      };
      if (this.inputElement) {
        Input.removeAttributes(ariaAttribute, this.inputElement);
        this.inputElement.removeAttribute("aria-placeholder");
      }
      if (this.isCalendar()) {
        if (this.popupWrapper) {
          detach(this.popupWrapper);
        }
        this.popupObject = this.popupWrapper = null;
        this.keyboardHandler.destroy();
      }
      this.unBindInputEvents();
      _super.prototype.destroy.call(this);
    };
    DateTimePicker2.prototype.render = function() {
      this.timekeyConfigure = {
        enter: "enter",
        escape: "escape",
        end: "end",
        tab: "tab",
        home: "home",
        down: "downarrow",
        up: "uparrow",
        left: "leftarrow",
        right: "rightarrow",
        open: "alt+downarrow",
        close: "alt+uparrow"
      };
      this.valueWithMinutes = null;
      this.previousDateTime = null;
      this.isPreventBlur = false;
      this.cloneElement = this.element.cloneNode(true);
      this.dateTimeFormat = this.cldrDateTimeFormat();
      this.initValue = this.value;
      _super.prototype.updateHtmlAttributeToElement.call(this);
      this.checkAttributes(false);
      var localeText = { placeholder: this.placeholder };
      this.l10n = new L10n("datetimepicker", localeText, this.locale);
      this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      _super.prototype.render.call(this);
      this.createInputElement();
      _super.prototype.updateHtmlAttributeToWrapper.call(this);
      this.bindInputEvents();
      if (this.enableMask) {
        this.notify("createMask", {
          module: "MaskedDateTime"
        });
      }
      this.setValue();
      if (this.enableMask && !this.value && this.maskedDateValue && (this.floatLabelType == "Always" || !this.floatLabelType || !this.placeholder)) {
        Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);
      }
      this.setProperties({ scrollTo: this.checkDateValue(new Date(this.checkValue(this.scrollTo))) }, true);
      this.previousDateTime = this.value && /* @__PURE__ */ new Date(+this.value);
      if (this.element.tagName === "EJS-DATETIMEPICKER") {
        this.tabIndex = this.element.hasAttribute("tabindex") ? this.element.getAttribute("tabindex") : "0";
        this.element.removeAttribute("tabindex");
        if (!this.enabled) {
          this.inputElement.tabIndex = -1;
        }
      }
      this.renderComplete();
    };
    DateTimePicker2.prototype.setValue = function() {
      this.initValue = this.validateMinMaxRange(this.value);
      if (!this.strictMode && this.isDateObject(this.initValue)) {
        var value = this.validateMinMaxRange(this.initValue);
        Input.setValue(this.getFormattedValue(value), this.inputElement, this.floatLabelType, this.showClearButton);
        this.setProperties({ value }, true);
      } else {
        if (isNullOrUndefined(this.value)) {
          this.initValue = null;
          this.setProperties({ value: null }, true);
        }
      }
      this.valueWithMinutes = this.value;
      _super.prototype.updateInput.call(this);
    };
    DateTimePicker2.prototype.validateMinMaxRange = function(value) {
      var result = value;
      if (this.isDateObject(value)) {
        result = this.validateValue(value);
      } else {
        if (+this.min > +this.max) {
          this.disablePopupButton(true);
        }
      }
      this.checkValidState(result);
      return result;
    };
    DateTimePicker2.prototype.checkValidState = function(value) {
      this.isValidState = true;
      if (!this.strictMode) {
        if (+value > +this.max || +value < +this.min) {
          this.isValidState = false;
        }
      }
      this.checkErrorState();
    };
    DateTimePicker2.prototype.checkErrorState = function() {
      if (this.isValidState) {
        removeClass([this.inputWrapper.container], ERROR4);
      } else {
        addClass([this.inputWrapper.container], ERROR4);
      }
      attributes(this.inputElement, { "aria-invalid": this.isValidState ? "false" : "true" });
    };
    DateTimePicker2.prototype.validateValue = function(value) {
      var dateVal = value;
      if (this.strictMode) {
        if (+this.min > +this.max) {
          this.disablePopupButton(true);
          dateVal = this.max;
        } else if (+value < +this.min) {
          dateVal = this.min;
        } else if (+value > +this.max) {
          dateVal = this.max;
        }
      } else {
        if (+this.min > +this.max) {
          this.disablePopupButton(true);
          dateVal = value;
        }
      }
      return dateVal;
    };
    DateTimePicker2.prototype.disablePopupButton = function(isDisable) {
      if (isDisable) {
        addClass([this.inputWrapper.buttons[0], this.timeIcon], DISABLED4);
        this.hide();
      } else {
        removeClass([this.inputWrapper.buttons[0], this.timeIcon], DISABLED4);
      }
    };
    DateTimePicker2.prototype.getFormattedValue = function(value) {
      var dateOptions;
      if (!isNullOrUndefined(value)) {
        if (this.calendarMode === "Gregorian") {
          dateOptions = { format: this.cldrDateTimeFormat(), type: "dateTime", skeleton: "yMd" };
        } else {
          dateOptions = { format: this.cldrDateTimeFormat(), type: "dateTime", skeleton: "yMd", calendar: "islamic" };
        }
        return this.globalize.formatDate(value, dateOptions);
      } else {
        return null;
      }
    };
    DateTimePicker2.prototype.isDateObject = function(value) {
      return !isNullOrUndefined(value) && !isNaN(+value) ? true : false;
    };
    DateTimePicker2.prototype.createInputElement = function() {
      removeClass([this.inputElement], DATEPICKERROOT);
      removeClass([this.inputWrapper.container], DATEWRAPPER2);
      addClass([this.inputWrapper.container], DATETIMEWRAPPER);
      addClass([this.inputElement], ROOT5);
      this.renderTimeIcon();
    };
    DateTimePicker2.prototype.renderTimeIcon = function() {
      this.timeIcon = Input.appendSpan(INPUTWRAPPER2 + " " + TIMEICON + " " + ICONS2, this.inputWrapper.container);
    };
    DateTimePicker2.prototype.bindInputEvents = function() {
      EventHandler.add(this.timeIcon, "mousedown", this.timeHandler, this);
      EventHandler.add(this.inputWrapper.buttons[0], "mousedown", this.dateHandler, this);
      EventHandler.add(this.inputElement, "blur", this.blurHandler, this);
      EventHandler.add(this.inputElement, "focus", this.focusHandler, this);
      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
      this.keyboardHandler = new KeyboardEvents(this.inputElement, {
        eventName: "keydown",
        keyAction: this.inputKeyAction.bind(this),
        keyConfigs: this.defaultKeyConfigs
      });
    };
    DateTimePicker2.prototype.unBindInputEvents = function() {
      EventHandler.remove(this.timeIcon, "mousedown touchstart", this.timeHandler);
      EventHandler.remove(this.inputWrapper.buttons[0], "mousedown touchstart", this.dateHandler);
      if (this.inputElement) {
        EventHandler.remove(this.inputElement, "blur", this.blurHandler);
        EventHandler.remove(this.inputElement, "focus", this.focusHandler);
      }
      if (this.keyboardHandler) {
        this.keyboardHandler.destroy();
      }
    };
    DateTimePicker2.prototype.cldrTimeFormat = function() {
      var cldrTime;
      if (this.isNullOrEmpty(this.timeFormat)) {
        if (this.locale === "en" || this.locale === "en-US") {
          cldrTime = getValue("timeFormats.short", getDefaultDateObject());
        } else {
          cldrTime = this.getCultureTimeObject(cldrData, "" + this.locale);
        }
      } else {
        cldrTime = this.timeFormat;
      }
      return cldrTime;
    };
    DateTimePicker2.prototype.cldrDateTimeFormat = function() {
      var cldrTime;
      var culture = new Internationalization(this.locale);
      var dateFormat = culture.getDatePattern({ skeleton: "yMd" });
      if (this.isNullOrEmpty(this.formatString)) {
        cldrTime = dateFormat + " " + this.getCldrFormat("time");
      } else {
        cldrTime = this.formatString;
      }
      return cldrTime;
    };
    DateTimePicker2.prototype.getCldrFormat = function(type) {
      var cldrDateTime;
      if (this.locale === "en" || this.locale === "en-US") {
        cldrDateTime = getValue("timeFormats.short", getDefaultDateObject());
      } else {
        cldrDateTime = this.getCultureTimeObject(cldrData, "" + this.locale);
      }
      return cldrDateTime;
    };
    DateTimePicker2.prototype.isNullOrEmpty = function(value) {
      if (isNullOrUndefined(value) || typeof value === "string" && value.trim() === "") {
        return true;
      } else {
        return false;
      }
    };
    DateTimePicker2.prototype.getCultureTimeObject = function(ld, c) {
      if (this.calendarMode === "Gregorian") {
        return getValue("main." + this.locale + ".dates.calendars.gregorian.timeFormats.short", ld);
      } else {
        return getValue("main." + this.locale + ".dates.calendars.islamic.timeFormats.short", ld);
      }
    };
    DateTimePicker2.prototype.timeHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      this.isIconClicked = true;
      if (Browser.isDevice) {
        this.inputElement.setAttribute("readonly", "");
      }
      if (e.currentTarget === this.timeIcon) {
        e.preventDefault();
      }
      if (this.enabled && !this.readonly) {
        if (this.isDatePopupOpen()) {
          _super.prototype.hide.call(this, e);
        }
        if (this.isTimePopupOpen()) {
          this.closePopup(e);
        } else {
          this.inputElement.focus();
          this.popupCreation("time", e);
          addClass([this.inputWrapper.container], [INPUTFOCUS3]);
        }
      }
      this.isIconClicked = false;
    };
    DateTimePicker2.prototype.dateHandler = function(e) {
      if (!this.enabled) {
        return;
      }
      if (e.currentTarget === this.inputWrapper.buttons[0]) {
        e.preventDefault();
      }
      if (this.enabled && !this.readonly) {
        if (this.isTimePopupOpen()) {
          this.closePopup(e);
        }
        if (!isNullOrUndefined(this.popupWrapper)) {
          this.popupCreation("date", e);
        }
      }
    };
    DateTimePicker2.prototype.show = function(type, e) {
      if (this.enabled && this.readonly || !this.enabled) {
        return;
      } else {
        if (type === "time" && !this.dateTimeWrapper) {
          if (this.isDatePopupOpen()) {
            this.hide(e);
          }
          this.popupCreation("time", e);
        } else if (!this.popupObj) {
          if (this.isTimePopupOpen()) {
            this.hide(e);
          }
          _super.prototype.show.call(this);
          this.popupCreation("date", e);
        }
      }
    };
    DateTimePicker2.prototype.toggle = function(e) {
      if (this.isDatePopupOpen()) {
        _super.prototype.hide.call(this, e);
        this.show("time", null);
      } else if (this.isTimePopupOpen()) {
        this.hide(e);
        _super.prototype.show.call(this, null, e);
        this.popupCreation("date", null);
      } else {
        this.show(null, e);
      }
    };
    DateTimePicker2.prototype.listCreation = function() {
      var dateObject;
      if (this.calendarMode === "Gregorian") {
        dateObject = this.globalize.parseDate(this.inputElement.value, {
          format: this.cldrDateTimeFormat(),
          type: "datetime"
        });
      } else {
        dateObject = this.globalize.parseDate(this.inputElement.value, {
          format: this.cldrDateTimeFormat(),
          type: "datetime",
          calendar: "islamic"
        });
      }
      var value = isNullOrUndefined(this.value) ? this.inputElement.value !== "" ? dateObject : /* @__PURE__ */ new Date() : this.value;
      this.valueWithMinutes = value;
      this.listWrapper = createElement("div", { className: CONTENT4, attrs: { "tabindex": "0" } });
      var min = this.startTime(value);
      var max = this.endTime(value);
      var listDetails = TimePickerBase.createListItems(this.createElement, min, max, this.globalize, this.cldrTimeFormat(), this.step);
      this.timeCollections = listDetails.collection;
      this.listTag = listDetails.list;
      attributes(this.listTag, { "role": "listbox", "aria-hidden": "false", "id": this.element.id + "_options" });
      append([listDetails.list], this.listWrapper);
      this.wireTimeListEvents();
      var rippleModel = { duration: 300, selector: "." + LISTCLASS3 };
      this.rippleFn = rippleEffect(this.listWrapper, rippleModel);
      this.liCollections = this.listWrapper.querySelectorAll("." + LISTCLASS3);
    };
    DateTimePicker2.prototype.popupCreation = function(type, e) {
      if (Browser.isDevice) {
        this.element.setAttribute("readonly", "readonly");
      }
      if (type === "date") {
        if (!this.readonly && this.popupWrapper) {
          addClass([this.popupWrapper], DATETIMEPOPUPWRAPPER);
          attributes(this.popupWrapper, { "id": this.element.id + "_datepopup" });
        }
      } else {
        if (!this.readonly) {
          this.dateTimeWrapper = createElement("div", {
            className: ROOT5 + " " + POPUP4,
            attrs: { "id": this.element.id + "_timepopup", "style": "visibility:hidden ; display:block" }
          });
          if (!isNullOrUndefined(this.cssClass)) {
            this.dateTimeWrapper.className += " " + this.cssClass;
          }
          if (!isNullOrUndefined(this.step) && this.step > 0) {
            this.listCreation();
            append([this.listWrapper], this.dateTimeWrapper);
          }
          document.body.appendChild(this.dateTimeWrapper);
          this.addTimeSelection();
          this.renderPopup();
          this.setTimeScrollPosition();
          this.openPopup(e);
          this.popupObject.refreshPosition(this.inputElement);
        }
      }
    };
    DateTimePicker2.prototype.openPopup = function(e) {
      var _this = this;
      this.preventArgs = {
        cancel: false,
        popup: this.popupObject,
        event: e || null
      };
      var eventArgs = this.preventArgs;
      this.trigger("open", eventArgs, function(eventArgs2) {
        _this.preventArgs = eventArgs2;
        if (!_this.preventArgs.cancel && !_this.readonly) {
          var openAnimation = {
            name: "FadeIn",
            duration: ANIMATIONDURATION2
          };
          if (_this.zIndex === 1e3) {
            _this.popupObject.show(new Animation(openAnimation), _this.element);
          } else {
            _this.popupObject.show(new Animation(openAnimation), null);
          }
          addClass([_this.inputWrapper.container], [ICONANIMATION2]);
          attributes(_this.inputElement, { "aria-expanded": "true" });
          EventHandler.add(document, "mousedown touchstart", _this.documentClickHandler, _this);
        }
      });
    };
    DateTimePicker2.prototype.documentClickHandler = function(event) {
      var target = event.target;
      if (!isNullOrUndefined(this.popupObject) && (this.inputWrapper.container.contains(target) || this.popupObject.element && this.popupObject.element.contains(target)) && event.type !== "touchstart") {
        event.preventDefault();
      }
      if (!closest(target, '[id="' + (this.popupObject && this.popupObject.element.id + '"]')) && target !== this.inputElement && target !== this.timeIcon && target !== this.inputWrapper.container) {
        if (this.isTimePopupOpen()) {
          this.hide(event);
          this.focusOut();
        }
      } else if (target !== this.inputElement) {
        if (!Browser.isDevice) {
          this.isPreventBlur = document.activeElement === this.inputElement && (Browser.isIE || Browser.info.name === "edge") && target === this.popupObject.element;
        }
      }
    };
    DateTimePicker2.prototype.isTimePopupOpen = function() {
      return this.dateTimeWrapper && this.dateTimeWrapper.classList.contains("" + ROOT5) ? true : false;
    };
    DateTimePicker2.prototype.isDatePopupOpen = function() {
      return this.popupWrapper && this.popupWrapper.classList.contains("" + DATETIMEPOPUPWRAPPER) ? true : false;
    };
    DateTimePicker2.prototype.renderPopup = function() {
      var _this = this;
      this.containerStyle = this.inputWrapper.container.getBoundingClientRect();
      if (Browser.isDevice) {
        this.timeModal = createElement("div");
        this.timeModal.className = "" + ROOT5 + " e-time-modal";
        document.body.className += " " + OVERFLOW4;
        this.timeModal.style.display = "block";
        document.body.appendChild(this.timeModal);
      }
      var offset = 4;
      this.popupObject = new Popup(this.dateTimeWrapper, {
        width: this.setPopupWidth(),
        zIndex: this.zIndex,
        targetType: "container",
        collision: Browser.isDevice ? { X: "fit", Y: "fit" } : { X: "flip", Y: "flip" },
        relateTo: Browser.isDevice ? document.body : this.inputWrapper.container,
        position: Browser.isDevice ? { X: "center", Y: "center" } : { X: "left", Y: "bottom" },
        enableRtl: this.enableRtl,
        offsetY: offset,
        open: function() {
          _this.dateTimeWrapper.style.visibility = "visible";
          addClass([_this.timeIcon], ACTIVE3);
          if (!Browser.isDevice) {
            _this.timekeyConfigure = extend(_this.timekeyConfigure, _this.keyConfigs);
            _this.inputEvent = new KeyboardEvents(_this.inputWrapper.container, {
              keyAction: _this.timeKeyActionHandle.bind(_this),
              keyConfigs: _this.timekeyConfigure,
              eventName: "keydown"
            });
          }
        },
        close: function() {
          removeClass([_this.timeIcon], ACTIVE3);
          _this.unWireTimeListEvents();
          _this.inputElement.setAttribute("aria-activedescendant", "null");
          remove(_this.popupObject.element);
          _this.popupObject.destroy();
          _this.dateTimeWrapper.innerHTML = "";
          _this.listWrapper = _this.dateTimeWrapper = void 0;
          if (_this.inputEvent) {
            _this.inputEvent.destroy();
          }
        },
        targetExitViewport: function() {
          if (!Browser.isDevice) {
            _this.hide();
          }
        }
      });
      this.popupObject.element.style.maxHeight = POPUPDIMENSION2;
    };
    DateTimePicker2.prototype.setDimension = function(width) {
      if (typeof width === "number") {
        width = formatUnit(width);
      } else if (typeof width === "string") {
        width = width;
      } else {
        width = "100%";
      }
      return width;
    };
    DateTimePicker2.prototype.setPopupWidth = function() {
      var width = this.setDimension(this.width);
      if (width.indexOf("%") > -1) {
        var inputWidth = this.containerStyle.width * parseFloat(width) / 100;
        width = inputWidth.toString() + "px";
      }
      return width;
    };
    DateTimePicker2.prototype.wireTimeListEvents = function() {
      EventHandler.add(this.listWrapper, "click", this.onMouseClick, this);
      if (!Browser.isDevice) {
        EventHandler.add(this.listWrapper, "mouseover", this.onMouseOver, this);
        EventHandler.add(this.listWrapper, "mouseout", this.onMouseLeave, this);
      }
    };
    DateTimePicker2.prototype.unWireTimeListEvents = function() {
      if (this.listWrapper) {
        EventHandler.remove(this.listWrapper, "click", this.onMouseClick);
        EventHandler.remove(document, "mousedown touchstart", this.documentClickHandler);
        if (!Browser.isDevice) {
          EventHandler.add(this.listWrapper, "mouseover", this.onMouseOver, this);
          EventHandler.add(this.listWrapper, "mouseout", this.onMouseLeave, this);
        }
      }
    };
    DateTimePicker2.prototype.onMouseOver = function(event) {
      var currentLi = closest(event.target, "." + LISTCLASS3);
      this.setTimeHover(currentLi, HOVER3);
    };
    DateTimePicker2.prototype.onMouseLeave = function() {
      this.removeTimeHover(HOVER3);
    };
    DateTimePicker2.prototype.setTimeHover = function(li, className) {
      if (this.enabled && this.isValidLI(li) && !li.classList.contains(className)) {
        this.removeTimeHover(className);
        addClass([li], className);
      }
    };
    DateTimePicker2.prototype.getPopupHeight = function() {
      var height = parseInt(POPUPDIMENSION2, 10);
      var popupHeight = this.dateTimeWrapper.getBoundingClientRect().height;
      return popupHeight > height ? height : popupHeight;
    };
    DateTimePicker2.prototype.changeEvent = function(e) {
      if ((this.value && this.value.valueOf()) !== (this.previousDateTime && +this.previousDateTime.valueOf())) {
        _super.prototype.changeEvent.call(this, e);
        this.valueWithMinutes = this.value;
        this.setInputValue("date");
        this.previousDateTime = this.value && /* @__PURE__ */ new Date(+this.value);
      }
    };
    DateTimePicker2.prototype.updateValue = function(e) {
      this.setInputValue("time");
      if (+this.previousDateTime !== +this.value) {
        this.changedArgs = {
          value: this.value,
          event: e || null,
          isInteracted: !isNullOrUndefined(e),
          element: this.element
        };
        this.addTimeSelection();
        this.trigger("change", this.changedArgs);
        this.previousDateTime = this.previousDate = this.value;
      }
    };
    DateTimePicker2.prototype.setTimeScrollPosition = function() {
      var popupElement = this.selectedElement;
      if (!isNullOrUndefined(popupElement)) {
        this.findScrollTop(popupElement);
      } else if (this.dateTimeWrapper && this.checkDateValue(this.scrollTo)) {
        this.setScrollTo();
      }
    };
    DateTimePicker2.prototype.findScrollTop = function(element) {
      var listHeight = this.getPopupHeight();
      var nextElement = element.nextElementSibling;
      var height = nextElement ? nextElement.offsetTop : element.offsetTop;
      var lineHeight = element.getBoundingClientRect().height;
      if (height + element.offsetTop > listHeight) {
        this.dateTimeWrapper.scrollTop = nextElement ? height - (listHeight / HALFPOSITION2 + lineHeight / HALFPOSITION2) : height;
      } else {
        this.dateTimeWrapper.scrollTop = 0;
      }
    };
    DateTimePicker2.prototype.setScrollTo = function() {
      var element;
      var items = this.dateTimeWrapper.querySelectorAll("." + LISTCLASS3);
      if (items.length >= 0) {
        this.scrollInvoked = true;
        var initialTime = this.timeCollections[0];
        var scrollTime = this.getDateObject(this.checkDateValue(this.scrollTo)).getTime();
        element = items[Math.round((scrollTime - initialTime) / (this.step * 6e4))];
      } else {
        this.dateTimeWrapper.scrollTop = 0;
      }
      if (!isNullOrUndefined(element)) {
        this.findScrollTop(element);
      } else {
        this.dateTimeWrapper.scrollTop = 0;
      }
    };
    DateTimePicker2.prototype.setInputValue = function(type) {
      if (type === "date") {
        this.inputElement.value = this.previousElementValue = this.getFormattedValue(this.getFullDateTime());
        this.setProperties({ value: this.getFullDateTime() }, true);
      } else {
        var tempVal = this.getFormattedValue(new Date(this.timeCollections[this.activeIndex]));
        Input.setValue(tempVal, this.inputElement, this.floatLabelType, this.showClearButton);
        this.previousElementValue = this.inputElement.value;
        this.setProperties({ value: new Date(this.timeCollections[this.activeIndex]) }, true);
        if (this.enableMask) {
          this.createMask();
        }
      }
      this.updateIconState();
    };
    DateTimePicker2.prototype.getFullDateTime = function() {
      var value = null;
      if (this.isDateObject(this.valueWithMinutes)) {
        value = this.combineDateTime(this.valueWithMinutes);
      } else {
        value = this.previousDate;
      }
      return this.validateMinMaxRange(value);
    };
    DateTimePicker2.prototype.createMask = function() {
      this.notify("createMask", {
        module: "MaskedDateTime"
      });
    };
    DateTimePicker2.prototype.combineDateTime = function(value) {
      if (this.isDateObject(value)) {
        var day = this.previousDate.getDate();
        var month = this.previousDate.getMonth();
        var year = this.previousDate.getFullYear();
        var hour = value.getHours();
        var minutes = value.getMinutes();
        var seconds = value.getSeconds();
        return new Date(year, month, day, hour, minutes, seconds);
      } else {
        return this.previousDate;
      }
    };
    DateTimePicker2.prototype.onMouseClick = function(event) {
      var target = event.target;
      var li = this.selectedElement = closest(target, "." + LISTCLASS3);
      if (li && li.classList.contains(LISTCLASS3)) {
        this.timeValue = li.getAttribute("data-value");
        this.hide(event);
      }
      this.setSelection(li, event);
    };
    DateTimePicker2.prototype.setSelection = function(li, event) {
      if (this.isValidLI(li) && !li.classList.contains(ACTIVE3)) {
        this.selectedElement = li;
        var index = Array.prototype.slice.call(this.liCollections).indexOf(li);
        this.activeIndex = index;
        this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);
        addClass([this.selectedElement], ACTIVE3);
        this.selectedElement.setAttribute("aria-selected", "true");
        this.updateValue(event);
      }
    };
    DateTimePicker2.prototype.setTimeActiveClass = function() {
      var collections = isNullOrUndefined(this.dateTimeWrapper) ? this.listWrapper : this.dateTimeWrapper;
      if (!isNullOrUndefined(collections)) {
        var items = collections.querySelectorAll("." + LISTCLASS3);
        if (items.length) {
          for (var i = 0; i < items.length; i++) {
            if (this.timeCollections[i] === +this.valueWithMinutes) {
              items[i].setAttribute("aria-selected", "true");
              this.selectedElement = items[i];
              this.activeIndex = i;
              this.setTimeActiveDescendant();
              break;
            }
          }
        }
      }
    };
    DateTimePicker2.prototype.setTimeActiveDescendant = function() {
      if (!isNullOrUndefined(this.selectedElement)) {
        attributes(this.inputElement, { "aria-activedescendant": this.selectedElement.getAttribute("id") });
      } else {
        attributes(this.inputElement, { "aria-activedescendant": "null" });
      }
    };
    DateTimePicker2.prototype.addTimeSelection = function() {
      this.selectedElement = null;
      this.removeTimeSelection();
      this.setTimeActiveClass();
      if (!isNullOrUndefined(this.selectedElement)) {
        addClass([this.selectedElement], ACTIVE3);
        this.selectedElement.setAttribute("aria-selected", "true");
      }
    };
    DateTimePicker2.prototype.removeTimeSelection = function() {
      this.removeTimeHover(HOVER3);
      if (!isNullOrUndefined(this.dateTimeWrapper)) {
        var items = this.dateTimeWrapper.querySelectorAll("." + ACTIVE3);
        if (items.length) {
          removeClass(items, ACTIVE3);
          items[0].removeAttribute("aria-selected");
        }
      }
    };
    DateTimePicker2.prototype.removeTimeHover = function(className) {
      var hoveredItem = this.getTimeHoverItem(className);
      if (hoveredItem && hoveredItem.length) {
        removeClass(hoveredItem, className);
      }
    };
    DateTimePicker2.prototype.getTimeHoverItem = function(className) {
      var collections = isNullOrUndefined(this.dateTimeWrapper) ? this.listWrapper : this.dateTimeWrapper;
      var hoveredItem;
      if (!isNullOrUndefined(collections)) {
        hoveredItem = collections.querySelectorAll("." + className);
      }
      return hoveredItem;
    };
    DateTimePicker2.prototype.isValidLI = function(li) {
      return li && li.classList.contains(LISTCLASS3) && !li.classList.contains(DISABLED4);
    };
    DateTimePicker2.prototype.calculateStartEnd = function(value, range, method) {
      var day = value.getDate();
      var month = value.getMonth();
      var year = value.getFullYear();
      var hours = value.getHours();
      var minutes = value.getMinutes();
      var seconds = value.getSeconds();
      var milliseconds = value.getMilliseconds();
      if (range) {
        if (method === "starttime") {
          return new Date(year, month, day, 0, 0, 0);
        } else {
          return new Date(year, month, day, 23, 59, 59);
        }
      } else {
        return new Date(year, month, day, hours, minutes, seconds, milliseconds);
      }
    };
    DateTimePicker2.prototype.startTime = function(date) {
      var tempStartValue;
      var start;
      var tempMin = this.min;
      var value = date === null ? /* @__PURE__ */ new Date() : date;
      if (+value.getDate() === +tempMin.getDate() && +value.getMonth() === +tempMin.getMonth() && +value.getFullYear() === +tempMin.getFullYear() || +new Date(value.getFullYear(), value.getMonth(), value.getDate()) <= +new Date(tempMin.getFullYear(), tempMin.getMonth(), tempMin.getDate())) {
        start = false;
        tempStartValue = this.min;
      } else if (+value < +this.max && +value > +this.min) {
        start = true;
        tempStartValue = value;
      } else if (+value >= +this.max) {
        start = true;
        tempStartValue = this.max;
      }
      return this.calculateStartEnd(tempStartValue, start, "starttime");
    };
    DateTimePicker2.prototype.endTime = function(date) {
      var tempEndValue;
      var end;
      var tempMax = this.max;
      var value = date === null ? /* @__PURE__ */ new Date() : date;
      if (+value.getDate() === +tempMax.getDate() && +value.getMonth() === +tempMax.getMonth() && +value.getFullYear() === +tempMax.getFullYear() || +new Date(value.getUTCFullYear(), value.getMonth(), value.getDate()) >= +new Date(tempMax.getFullYear(), tempMax.getMonth(), tempMax.getDate())) {
        end = false;
        tempEndValue = this.max;
      } else if (+value < +this.max && +value > +this.min) {
        end = true;
        tempEndValue = value;
      } else if (+value <= +this.min) {
        end = true;
        tempEndValue = this.min;
      }
      return this.calculateStartEnd(tempEndValue, end, "endtime");
    };
    DateTimePicker2.prototype.hide = function(e) {
      var _this = this;
      if (this.popupObj || this.dateTimeWrapper) {
        this.preventArgs = {
          cancel: false,
          popup: this.popupObj || this.popupObject,
          event: e || null
        };
        var eventArgs = this.preventArgs;
        if (isNullOrUndefined(this.popupObj)) {
          this.trigger("close", eventArgs, function(eventArgs2) {
            _this.dateTimeCloseEventCallback(e, eventArgs2);
          });
        } else {
          this.dateTimeCloseEventCallback(e, eventArgs);
        }
      } else {
        if (Browser.isDevice && this.allowEdit && !this.readonly) {
          this.inputElement.removeAttribute("readonly");
        }
        this.setAllowEdit();
      }
    };
    DateTimePicker2.prototype.dateTimeCloseEventCallback = function(e, eventArgs) {
      this.preventArgs = eventArgs;
      if (!this.preventArgs.cancel) {
        if (this.isDatePopupOpen()) {
          _super.prototype.hide.call(this, e);
        } else if (this.isTimePopupOpen()) {
          this.closePopup(e);
          removeClass([document.body], OVERFLOW4);
          if (Browser.isDevice && this.timeModal) {
            this.timeModal.style.display = "none";
            this.timeModal.outerHTML = "";
            this.timeModal = null;
          }
          this.setTimeActiveDescendant();
        }
      }
      if (Browser.isDevice && this.allowEdit && !this.readonly) {
        this.inputElement.removeAttribute("readonly");
      }
      this.setAllowEdit();
    };
    DateTimePicker2.prototype.closePopup = function(e) {
      if (this.isTimePopupOpen() && this.popupObject) {
        var animModel = {
          name: "FadeOut",
          duration: ANIMATIONDURATION2,
          delay: 0
        };
        this.popupObject.hide(new Animation(animModel));
        this.inputWrapper.container.classList.remove(ICONANIMATION2);
        attributes(this.inputElement, { "aria-expanded": "false" });
        EventHandler.remove(document, "mousedown touchstart", this.documentClickHandler);
      }
    };
    DateTimePicker2.prototype.preRender = function() {
      this.checkFormat();
      this.dateTimeFormat = this.cldrDateTimeFormat();
      _super.prototype.preRender.call(this);
      removeClass([this.inputElementCopy], [ROOT5]);
    };
    DateTimePicker2.prototype.getProperty = function(date, val) {
      if (val === "min") {
        this.setProperties({ min: this.validateValue(date.min) }, true);
      } else {
        this.setProperties({ max: this.validateValue(date.max) }, true);
      }
    };
    DateTimePicker2.prototype.checkAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["style", "name", "step", "disabled", "readonly", "value", "min", "max", "placeholder", "type"];
      var value;
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {
          switch (prop) {
            case "name":
              this.inputElement.setAttribute("name", this.inputElement.getAttribute(prop));
              break;
            case "step":
              this.step = parseInt(this.inputElement.getAttribute(prop), 10);
              break;
            case "readonly":
              if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions["readonly"] === void 0 || isDynamic) {
                var readonly = this.inputElement.getAttribute(prop) === "disabled" || this.inputElement.getAttribute(prop) === "" || this.inputElement.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.inputElement.getAttribute(prop) }, !isDynamic);
              }
              break;
            case "min":
              if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions["min"] === void 0 || isDynamic) {
                value = new Date(this.inputElement.getAttribute(prop));
                if (!this.isNullOrEmpty(value) && !isNaN(+value)) {
                  this.setProperties({ min: value }, !isDynamic);
                }
              }
              break;
            case "disabled":
              if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions["enabled"] === void 0 || isDynamic) {
                var enabled = this.inputElement.getAttribute(prop) === "disabled" || this.inputElement.getAttribute(prop) === "true" || this.inputElement.getAttribute(prop) === "" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "value":
              if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions["value"] === void 0 || isDynamic) {
                value = new Date(this.inputElement.getAttribute(prop));
                if (!this.isNullOrEmpty(value) && !isNaN(+value)) {
                  this.setProperties({ value }, !isDynamic);
                }
              }
              break;
            case "max":
              if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions["max"] === void 0 || isDynamic) {
                value = new Date(this.inputElement.getAttribute(prop));
                if (!this.isNullOrEmpty(value) && !isNaN(+value)) {
                  this.setProperties({ max: value }, !isDynamic);
                }
              }
              break;
          }
        }
      }
    };
    DateTimePicker2.prototype.requiredModules = function() {
      var modules = [];
      if (this) {
        modules.push({ args: [this], member: "islamic" });
      }
      if (this.enableMask) {
        modules.push(this.maskedDateModule());
      }
      return modules;
    };
    DateTimePicker2.prototype.maskedDateModule = function() {
      var modules = { args: [this], member: "MaskedDateTime" };
      return modules;
    };
    DateTimePicker2.prototype.getTimeActiveElement = function() {
      if (!isNullOrUndefined(this.dateTimeWrapper)) {
        return this.dateTimeWrapper.querySelectorAll("." + ACTIVE3);
      } else {
        return null;
      }
    };
    DateTimePicker2.prototype.createDateObj = function(val) {
      return val instanceof Date ? val : null;
    };
    DateTimePicker2.prototype.getDateObject = function(text) {
      if (!this.isNullOrEmpty(text)) {
        var dateValue = this.createDateObj(text);
        var value = this.valueWithMinutes;
        var status_1 = !isNullOrUndefined(value);
        if (this.checkDateValue(dateValue)) {
          var date = status_1 ? value.getDate() : DAY2;
          var month = status_1 ? value.getMonth() : MONTH3;
          var year = status_1 ? value.getFullYear() : YEAR3;
          var hour = status_1 ? value.getHours() : HOUR;
          var minute = status_1 ? value.getMinutes() : MINUTE;
          var second = status_1 ? value.getSeconds() : SECOND;
          var millisecond = status_1 ? value.getMilliseconds() : MILLISECOND;
          if (!this.scrollInvoked) {
            return new Date(year, month, date, hour, minute, second, millisecond);
          } else {
            this.scrollInvoked = false;
            return new Date(year, month, date, dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds(), dateValue.getMilliseconds());
          }
        }
      }
      return null;
    };
    DateTimePicker2.prototype.findNextTimeElement = function(event) {
      var textVal = this.inputElement.value;
      var value = isNullOrUndefined(this.valueWithMinutes) ? this.createDateObj(textVal) : this.getDateObject(this.valueWithMinutes);
      var dateTimeVal = null;
      var listCount = this.liCollections.length;
      if (!isNullOrUndefined(this.activeIndex) || !isNullOrUndefined(this.checkDateValue(value))) {
        if (event.action === "home") {
          dateTimeVal = +this.createDateObj(new Date(this.timeCollections[0]));
          this.activeIndex = 0;
        } else if (event.action === "end") {
          dateTimeVal = +this.createDateObj(new Date(this.timeCollections[this.timeCollections.length - 1]));
          this.activeIndex = this.timeCollections.length - 1;
        } else {
          if (event.action === "down") {
            for (var i = 0; i < listCount; i++) {
              if (+value < this.timeCollections[i]) {
                dateTimeVal = +this.createDateObj(new Date(this.timeCollections[i]));
                this.activeIndex = i;
                break;
              }
            }
          } else {
            for (var i = listCount - 1; i >= 0; i--) {
              if (+value > this.timeCollections[i]) {
                dateTimeVal = +this.createDateObj(new Date(this.timeCollections[i]));
                this.activeIndex = i;
                break;
              }
            }
          }
        }
        this.selectedElement = this.liCollections[this.activeIndex];
        this.timeElementValue(isNullOrUndefined(dateTimeVal) ? null : new Date(dateTimeVal));
      }
    };
    DateTimePicker2.prototype.setTimeValue = function(date, value) {
      var dateString;
      var time;
      var val = this.validateMinMaxRange(value);
      var newval = this.createDateObj(val);
      if (this.getFormattedValue(newval) !== (!isNullOrUndefined(this.value) ? this.getFormattedValue(this.value) : null)) {
        this.valueWithMinutes = isNullOrUndefined(newval) ? null : newval;
        time = /* @__PURE__ */ new Date(+this.valueWithMinutes);
      } else {
        if (this.strictMode) {
          date = newval;
        }
        this.valueWithMinutes = this.checkDateValue(date);
        time = /* @__PURE__ */ new Date(+this.valueWithMinutes);
      }
      if (this.calendarMode === "Gregorian") {
        dateString = this.globalize.formatDate(time, {
          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.cldrDateTimeFormat(),
          type: "dateTime",
          skeleton: "yMd"
        });
      } else {
        dateString = this.globalize.formatDate(time, {
          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.cldrDateTimeFormat(),
          type: "dateTime",
          skeleton: "yMd",
          calendar: "islamic"
        });
      }
      if (!this.strictMode && isNullOrUndefined(time)) {
        Input.setValue(dateString, this.inputElement, this.floatLabelType, this.showClearButton);
      } else {
        Input.setValue(dateString, this.inputElement, this.floatLabelType, this.showClearButton);
      }
      return time;
    };
    DateTimePicker2.prototype.timeElementValue = function(value) {
      if (!isNullOrUndefined(this.checkDateValue(value)) && !this.isNullOrEmpty(value)) {
        var date = value instanceof Date ? value : this.getDateObject(value);
        return this.setTimeValue(date, value);
      }
      return null;
    };
    DateTimePicker2.prototype.timeKeyHandler = function(event) {
      if (isNullOrUndefined(this.step) || this.step <= 0) {
        return;
      }
      var listCount = this.timeCollections.length;
      if (isNullOrUndefined(this.getTimeActiveElement()) || this.getTimeActiveElement().length === 0) {
        if (this.liCollections.length > 0) {
          if (isNullOrUndefined(this.value) && isNullOrUndefined(this.activeIndex)) {
            this.activeIndex = 0;
            this.selectedElement = this.liCollections[0];
            this.timeElementValue(new Date(this.timeCollections[0]));
          } else {
            this.findNextTimeElement(event);
          }
        }
      } else {
        var nextItemValue = void 0;
        if (event.keyCode >= 37 && event.keyCode <= 40) {
          var index = event.keyCode === 40 || event.keyCode === 39 ? ++this.activeIndex : --this.activeIndex;
          this.activeIndex = index = this.activeIndex === listCount ? 0 : this.activeIndex;
          this.activeIndex = index = this.activeIndex < 0 ? listCount - 1 : this.activeIndex;
          nextItemValue = isNullOrUndefined(this.timeCollections[index]) ? this.timeCollections[0] : this.timeCollections[index];
        } else if (event.action === "home") {
          this.activeIndex = 0;
          nextItemValue = this.timeCollections[0];
        } else if (event.action === "end") {
          this.activeIndex = listCount - 1;
          nextItemValue = this.timeCollections[listCount - 1];
        }
        this.selectedElement = this.liCollections[this.activeIndex];
        this.timeElementValue(new Date(nextItemValue));
      }
      this.isNavigate = true;
      this.setTimeHover(this.selectedElement, NAVIGATION2);
      this.setTimeActiveDescendant();
      if (this.isTimePopupOpen() && this.selectedElement !== null && (!event || event.type !== "click")) {
        this.setTimeScrollPosition();
      }
    };
    DateTimePicker2.prototype.timeKeyActionHandle = function(event) {
      if (this.enabled) {
        if (event.action !== "right" && event.action !== "left" && event.action !== "tab") {
          event.preventDefault();
        }
        switch (event.action) {
          case "up":
          case "down":
          case "home":
          case "end":
            this.timeKeyHandler(event);
            break;
          case "enter":
            if (this.isNavigate) {
              this.selectedElement = this.liCollections[this.activeIndex];
              this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);
              this.setInputValue("time");
              if (+this.previousDateTime !== +this.value) {
                this.changedArgs.value = this.value;
                this.addTimeSelection();
                this.previousDateTime = this.value;
              }
            } else {
              this.updateValue(event);
            }
            this.hide(event);
            addClass([this.inputWrapper.container], INPUTFOCUS3);
            this.isNavigate = false;
            event.stopPropagation();
            break;
          case "escape":
            this.hide(event);
            break;
          default:
            this.isNavigate = false;
            break;
        }
      }
    };
    DateTimePicker2.prototype.inputKeyAction = function(event) {
      switch (event.action) {
        case "altDownArrow":
          this.strictModeUpdate();
          this.updateInput();
          this.toggle(event);
          break;
      }
    };
    DateTimePicker2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "value":
            this.isDynamicValueChanged = true;
            this.invalidValueString = null;
            this.checkInvalidValue(newProp.value);
            newProp.value = this.value;
            newProp.value = this.validateValue(newProp.value);
            Input.setValue(this.getFormattedValue(newProp.value), this.inputElement, this.floatLabelType, this.showClearButton);
            this.valueWithMinutes = newProp.value;
            this.setProperties({ value: newProp.value }, true);
            if (this.popupObj) {
              this.popupUpdate();
            }
            this.previousDateTime = new Date(this.inputElement.value);
            this.updateInput();
            this.changeTrigger(null);
            this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
            if (this.enableMask && this.value) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
            }
            break;
          case "min":
          case "max":
            this.getProperty(newProp, prop);
            this.updateInput();
            break;
          case "enableRtl":
            Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);
            break;
          case "cssClass":
            if (!isNullOrUndefined(oldProp.cssClass)) {
              oldProp.cssClass = oldProp.cssClass.replace(/\s+/g, " ").trim();
            }
            if (!isNullOrUndefined(newProp.cssClass)) {
              newProp.cssClass = newProp.cssClass.replace(/\s+/g, " ").trim();
            }
            Input.setCssClass(newProp.cssClass, [this.inputWrapper.container], oldProp.cssClass);
            if (this.dateTimeWrapper) {
              Input.setCssClass(newProp.cssClass, [this.dateTimeWrapper], oldProp.cssClass);
            }
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
            Input.setPlaceholder(this.l10n.getConstant("placeholder"), this.inputElement);
            this.dateTimeFormat = this.cldrDateTimeFormat();
            _super.prototype.updateInput.call(this);
            break;
          case "htmlAttributes":
            this.updateHtmlAttributeToElement();
            this.updateHtmlAttributeToWrapper();
            this.checkAttributes(true);
            break;
          case "format":
            this.setProperties({ format: newProp.format }, true);
            this.checkFormat();
            this.dateTimeFormat = this.formatString;
            this.setValue();
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
              if (!this.value) {
                Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);
              }
            }
            break;
          case "placeholder":
            Input.setPlaceholder(newProp.placeholder, this.inputElement);
            this.inputElement.setAttribute("aria-placeholder", newProp.placeholder);
            break;
          case "enabled":
            Input.setEnabled(this.enabled, this.inputElement);
            if (!this.enabled) {
              this.inputElement.tabIndex = -1;
            }
            break;
          case "strictMode":
            this.invalidValueString = null;
            this.updateInput();
            break;
          case "width":
            this.setWidth(newProp.width);
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.inputElement);
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            Input.removeFloating(this.inputWrapper);
            Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);
            break;
          case "scrollTo":
            if (this.checkDateValue(new Date(this.checkValue(newProp.scrollTo)))) {
              if (this.dateTimeWrapper) {
                this.setScrollTo();
              }
              this.setProperties({ scrollTo: this.checkDateValue(new Date(this.checkValue(newProp.scrollTo))) }, true);
            } else {
              this.setProperties({ scrollTo: null }, true);
            }
            break;
          case "enableMask":
            if (this.enableMask) {
              this.notify("createMask", {
                module: "MaskedDateTime"
              });
              Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);
            } else {
              if (this.inputElement.value === this.maskedDateValue) {
                this.maskedDateValue = "";
                Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);
              }
            }
            break;
          default:
            _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
            break;
        }
        if (!this.isDynamicValueChanged) {
          this.hide(null);
        }
        this.isDynamicValueChanged = false;
      }
    };
    DateTimePicker2.prototype.getModuleName = function() {
      return "datetimepicker";
    };
    DateTimePicker2.prototype.restoreValue = function() {
      this.previousDateTime = this.previousDate;
      this.currentDate = this.value ? this.value : /* @__PURE__ */ new Date();
      this.valueWithMinutes = this.value;
      this.previousDate = this.value;
      this.previousElementValue = this.previousElementValue = isNullOrUndefined(this.inputValueCopy) ? "" : this.getFormattedValue(this.inputValueCopy);
    };
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "timeFormat", void 0);
    __decorate5([
      Property(30)
    ], DateTimePicker2.prototype, "step", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "scrollTo", void 0);
    __decorate5([
      Property(1e3)
    ], DateTimePicker2.prototype, "zIndex", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "value", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "keyConfigs", void 0);
    __decorate5([
      Property({})
    ], DateTimePicker2.prototype, "htmlAttributes", void 0);
    __decorate5([
      Property(false)
    ], DateTimePicker2.prototype, "enablePersistence", void 0);
    __decorate5([
      Property(true)
    ], DateTimePicker2.prototype, "allowEdit", void 0);
    __decorate5([
      Property(false)
    ], DateTimePicker2.prototype, "isMultiSelection", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "values", void 0);
    __decorate5([
      Property(true)
    ], DateTimePicker2.prototype, "showClearButton", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "placeholder", void 0);
    __decorate5([
      Property(false)
    ], DateTimePicker2.prototype, "strictMode", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "serverTimezoneOffset", void 0);
    __decorate5([
      Property(new Date(1900, 0, 1))
    ], DateTimePicker2.prototype, "min", void 0);
    __decorate5([
      Property(new Date(2099, 11, 31))
    ], DateTimePicker2.prototype, "max", void 0);
    __decorate5([
      Property(null)
    ], DateTimePicker2.prototype, "firstDayOfWeek", void 0);
    __decorate5([
      Property("Gregorian")
    ], DateTimePicker2.prototype, "calendarMode", void 0);
    __decorate5([
      Property("Month")
    ], DateTimePicker2.prototype, "start", void 0);
    __decorate5([
      Property("Month")
    ], DateTimePicker2.prototype, "depth", void 0);
    __decorate5([
      Property(false)
    ], DateTimePicker2.prototype, "weekNumber", void 0);
    __decorate5([
      Property(true)
    ], DateTimePicker2.prototype, "showTodayButton", void 0);
    __decorate5([
      Property("Short")
    ], DateTimePicker2.prototype, "dayHeaderFormat", void 0);
    __decorate5([
      Property(false)
    ], DateTimePicker2.prototype, "openOnFocus", void 0);
    __decorate5([
      Property(false)
    ], DateTimePicker2.prototype, "enableMask", void 0);
    __decorate5([
      Property({ day: "day", month: "month", year: "year", hour: "hour", minute: "minute", second: "second", dayOfTheWeek: "day of the week" })
    ], DateTimePicker2.prototype, "maskPlaceholder", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "open", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "close", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "cleared", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "blur", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "focus", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "created", void 0);
    __decorate5([
      Event()
    ], DateTimePicker2.prototype, "destroyed", void 0);
    DateTimePicker2 = __decorate5([
      NotifyPropertyChanges
    ], DateTimePicker2);
    return DateTimePicker2;
  }(DatePicker)
);

// node_modules/@syncfusion/ej2-calendars/src/calendar/islamic.js
var OTHERMONTH3 = "e-other-month";
var YEAR4 = "e-year";
var MONTH4 = "e-month";
var DECADE2 = "e-decade";
var DISABLED5 = "e-disabled";
var OVERLAY3 = "e-overlay";
var WEEKEND2 = "e-weekend";
var WEEKNUMBER3 = "e-week-number";
var SELECTED5 = "e-selected";
var FOCUSEDDATE3 = "e-focused-date";
var OTHERMONTHROW2 = "e-month-hide";
var TODAY3 = "e-today";
var LINK2 = "e-day";
var CELL2 = "e-cell";
var dayMilliSeconds2 = 864e5;
var minDecade = 2060;
var maxDecade = 2069;
var Islamic = (
  /** @class */
  function() {
    function Islamic2(instance) {
      this.calendarInstance = instance;
    }
    Islamic2.prototype.getModuleName = function() {
      return "islamic";
    };
    Islamic2.prototype.islamicTitleUpdate = function(date, view) {
      var globalize = new Internationalization(this.calendarInstance.locale);
      switch (view) {
        case "days":
          this.calendarInstance.headerTitleElement.textContent = globalize.formatDate(date, { type: "dateTime", format: "MMMMyyyy", calendar: "islamic" });
          break;
        case "months":
          this.calendarInstance.headerTitleElement.textContent = globalize.formatDate(date, { type: "dateTime", format: "yyyy", calendar: "islamic" });
      }
    };
    Islamic2.prototype.islamicRenderDays = function(currentDate, value, multiSelection, values) {
      var tdEles = [];
      var cellsCount = 42;
      var localDate = new Date(this.islamicInValue(currentDate));
      var minMaxDate;
      this.islamicTitleUpdate(currentDate, "days");
      var islamicDate = this.getIslamicDate(localDate);
      var gregorianObject = this.toGregorian(islamicDate.year, islamicDate.month, 1);
      var currentMonth = islamicDate.month;
      localDate = gregorianObject;
      while (localDate.getDay() !== this.calendarInstance.firstDayOfWeek) {
        this.calendarInstance.setStartDate(localDate, -1 * dayMilliSeconds2);
      }
      for (var day = 0; day < cellsCount; ++day) {
        var weekEle = this.calendarInstance.createElement("td", { className: CELL2 });
        var weekAnchor = this.calendarInstance.createElement("span");
        if (day % 7 === 0 && this.calendarInstance.weekNumber) {
          weekAnchor.textContent = "" + this.calendarInstance.getWeek(localDate);
          weekEle.appendChild(weekAnchor);
          addClass([weekEle], "" + WEEKNUMBER3);
          tdEles.push(weekEle);
        }
        minMaxDate = /* @__PURE__ */ new Date(+localDate);
        localDate = this.calendarInstance.minMaxDate(localDate);
        var dateFormatOptions = { type: "dateTime", skeleton: "full", calendar: "islamic" };
        var date = this.calendarInstance.globalize.parseDate(this.calendarInstance.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);
        var tdEle = this.islamicDayCell(localDate);
        var title = this.calendarInstance.globalize.formatDate(localDate, { type: "date", skeleton: "full", calendar: "islamic" });
        var dayLink = this.calendarInstance.createElement("span");
        dayLink.textContent = this.calendarInstance.globalize.formatDate(localDate, { type: "date", skeleton: "d", calendar: "islamic" });
        var disabled = this.calendarInstance.min > localDate || this.calendarInstance.max < localDate;
        if (disabled) {
          addClass([tdEle], DISABLED5);
          addClass([tdEle], OVERLAY3);
        } else {
          dayLink.setAttribute("title", "" + title);
        }
        var hijriMonthObject = this.getIslamicDate(localDate);
        if (currentMonth !== hijriMonthObject.month) {
          addClass([tdEle], OTHERMONTH3);
        }
        if (localDate.getDay() === 0 || localDate.getDay() === 6) {
          addClass([tdEle], WEEKEND2);
        }
        tdEle.appendChild(dayLink);
        this.calendarInstance.renderDayCellArgs = {
          date: localDate,
          isDisabled: false,
          element: tdEle,
          isOutOfRange: disabled
        };
        var argument = this.calendarInstance.renderDayCellArgs;
        this.calendarInstance.renderDayCellEvent(argument);
        if (argument.isDisabled) {
          if (this.calendarInstance.isMultiSelection) {
            if (!isNullOrUndefined(this.calendarInstance.values) && this.calendarInstance.values.length > 0) {
              for (var index = 0; index < values.length; index++) {
                var localDateString = +new Date(this.calendarInstance.globalize.formatDate(argument.date, { type: "date", skeleton: "yMd", calendar: "islamic" }));
                var tempDateString = +new Date(this.calendarInstance.globalize.formatDate(this.calendarInstance.values[index], { type: "date", skeleton: "yMd", calendar: "islamic" }));
                if (localDateString === tempDateString) {
                  this.calendarInstance.values.splice(index, 1);
                  index = -1;
                }
              }
            }
          } else if (value && +value === +argument.date) {
            this.calendarInstance.setProperties({ value: null }, true);
          }
        }
        if (this.calendarInstance.renderDayCellArgs.isDisabled && !tdEle.classList.contains(SELECTED5)) {
          addClass([tdEle], DISABLED5);
          addClass([tdEle], OVERLAY3);
          if (+this.calendarInstance.renderDayCellArgs.date === +this.calendarInstance.todayDate) {
            this.calendarInstance.todayDisabled = true;
          }
        }
        var otherMnthBool = tdEle.classList.contains(OTHERMONTH3);
        var disabledCls = tdEle.classList.contains(DISABLED5);
        if (!disabledCls) {
          EventHandler.add(tdEle, "click", this.calendarInstance.clickHandler, this.calendarInstance);
        }
        if (this.calendarInstance.isMultiSelection && !isNullOrUndefined(this.calendarInstance.values) && !otherMnthBool && !disabledCls) {
          for (var tempValue = 0; tempValue < this.calendarInstance.values.length; tempValue++) {
            var localDateString = this.calendarInstance.globalize.formatDate(localDate, { type: "date", skeleton: "short", calendar: "islamic" });
            var tempDateString = this.calendarInstance.globalize.formatDate(this.calendarInstance.values[tempValue], { type: "date", skeleton: "short", calendar: "islamic" });
            if (localDateString === tempDateString && this.calendarInstance.getDateVal(localDate, this.calendarInstance.values[tempValue])) {
              addClass([tdEle], SELECTED5);
            } else {
              this.calendarInstance.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
            }
          }
          if (this.calendarInstance.values.length <= 0) {
            this.calendarInstance.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
          }
        } else if (!otherMnthBool && !disabledCls && this.calendarInstance.getDateVal(localDate, value)) {
          addClass([tdEle], SELECTED5);
        } else {
          this.calendarInstance.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
        }
        if (date.getDate() === (/* @__PURE__ */ new Date()).getDate() && date.getMonth() === (/* @__PURE__ */ new Date()).getMonth()) {
          if (date.getFullYear() === (/* @__PURE__ */ new Date()).getFullYear()) {
            addClass([tdEle], TODAY3);
          }
        }
        localDate = /* @__PURE__ */ new Date(+minMaxDate);
        tdEles.push(this.calendarInstance.renderDayCellArgs.element);
        this.calendarInstance.addDay(localDate, 1, null, this.calendarInstance.max, this.calendarInstance.min);
      }
      return tdEles;
    };
    Islamic2.prototype.islamicIconHandler = function() {
      new Date(this.islamicInValue(this.calendarInstance.currentDate)).setDate(1);
      var date = new Date(this.islamicInValue(this.calendarInstance.currentDate));
      switch (this.calendarInstance.currentView()) {
        case "Month":
          {
            var prevMonthCompare = this.islamicCompareMonth(date, this.calendarInstance.min) < 1;
            var nextMonthCompare = this.islamicCompareMonth(date, this.calendarInstance.max) > -1;
            this.calendarInstance.previousIconHandler(prevMonthCompare);
            this.calendarInstance.nextIconHandler(nextMonthCompare);
          }
          break;
        case "Year":
          {
            var prevYearCompare = this.hijriCompareYear(date, this.calendarInstance.min) < 1;
            var nextYearCompare = this.hijriCompareYear(date, this.calendarInstance.max) > -1;
            this.calendarInstance.previousIconHandler(prevYearCompare);
            this.calendarInstance.nextIconHandler(nextYearCompare);
          }
          break;
        case "Decade": {
          var prevDecadeCompare = this.hijriCompareDecade(date, this.calendarInstance.min) < 1;
          var nextDecadeCompare = this.hijriCompareDecade(date, this.calendarInstance.max) > -1;
          this.calendarInstance.previousIconHandler(prevDecadeCompare);
          this.calendarInstance.nextIconHandler(nextDecadeCompare);
        }
      }
    };
    Islamic2.prototype.islamicNext = function() {
      this.calendarInstance.effect = "";
      var view = this.calendarInstance.getViewNumber(this.calendarInstance.currentView());
      var islamicDate = this.getIslamicDate(this.calendarInstance.currentDate);
      switch (this.calendarInstance.currentView()) {
        case "Year":
          this.calendarInstance.currentDate = this.toGregorian(islamicDate.year + 1, islamicDate.month, 1);
          this.calendarInstance.switchView(view);
          break;
        case "Month":
          this.calendarInstance.currentDate = this.toGregorian(islamicDate.year, islamicDate.month + 1, 1);
          this.calendarInstance.switchView(view);
          break;
        case "Decade":
          this.calendarInstance.currentDate = this.toGregorian(islamicDate.year + 10, islamicDate.month, 1);
          this.calendarInstance.switchView(view);
          break;
      }
    };
    Islamic2.prototype.islamicPrevious = function() {
      var currentView = this.calendarInstance.getViewNumber(this.calendarInstance.currentView());
      this.calendarInstance.effect = "";
      var islamicDate = this.getIslamicDate(this.calendarInstance.currentDate);
      switch (this.calendarInstance.currentView()) {
        case "Month":
          this.calendarInstance.currentDate = this.toGregorian(islamicDate.year, islamicDate.month - 1, 1);
          this.calendarInstance.switchView(currentView);
          break;
        case "Year":
          this.calendarInstance.currentDate = this.toGregorian(islamicDate.year - 1, islamicDate.month, 1);
          this.calendarInstance.switchView(currentView);
          break;
        case "Decade":
          this.calendarInstance.currentDate = this.toGregorian(islamicDate.year - 10, islamicDate.month - 1, 1);
          this.calendarInstance.switchView(currentView);
          break;
      }
    };
    Islamic2.prototype.islamicRenderYears = function(e, value) {
      this.calendarInstance.removeTableHeadElement();
      var numCells = 4;
      var tdEles = [];
      var valueUtil = isNullOrUndefined(value);
      var curDate = new Date(this.islamicInValue(this.calendarInstance.currentDate));
      var localDate = curDate;
      var islamicDate = this.getIslamicDate(localDate);
      var gregorianObject = HijriParser.toGregorian(islamicDate.year, 1, 1);
      localDate = gregorianObject;
      var mon = islamicDate.month;
      var yr = islamicDate.year;
      var curYrs = islamicDate.year;
      var minYr = this.getIslamicDate(this.calendarInstance.min).year;
      var minMonth = this.getIslamicDate(this.calendarInstance.min).month;
      var maxYr = this.getIslamicDate(this.calendarInstance.max).year;
      var maxMonth = this.getIslamicDate(this.calendarInstance.max).month;
      this.islamicTitleUpdate(this.calendarInstance.currentDate, "months");
      for (var month = 1; month <= 12; ++month) {
        var islamicDate_1 = this.getIslamicDate(localDate);
        var gregorianObject_1 = HijriParser.toGregorian(islamicDate_1.year, month, 1);
        localDate = gregorianObject_1;
        var tdEle = this.islamicDayCell(localDate);
        var dayLink = this.calendarInstance.createElement("span");
        var localMonth = value && this.getIslamicDate(value).month === this.getIslamicDate(localDate).month;
        var select2 = value && this.getIslamicDate(value).year === yr && localMonth;
        dayLink.textContent = this.calendarInstance.globalize.formatDate(localDate, { type: "dateTime", format: "MMM", calendar: "islamic" });
        if (this.calendarInstance.min && (curYrs < minYr || month < minMonth && curYrs === minYr) || this.calendarInstance.max && (curYrs > maxYr || month > maxMonth && curYrs >= maxYr)) {
          addClass([tdEle], DISABLED5);
        } else if (!valueUtil && select2) {
          addClass([tdEle], SELECTED5);
        } else {
          if (this.getIslamicDate(localDate).month === mon && this.getIslamicDate(this.calendarInstance.currentDate).month === mon) {
            addClass([tdEle], FOCUSEDDATE3);
          }
        }
        if (!tdEle.classList.contains(DISABLED5)) {
          EventHandler.add(tdEle, "click", this.calendarInstance.clickHandler, this.calendarInstance);
        }
        tdEle.appendChild(dayLink);
        tdEles.push(tdEle);
      }
      this.islamicRenderTemplate(tdEles, numCells, YEAR4, e, value);
    };
    Islamic2.prototype.islamicRenderDecade = function(e, value) {
      this.calendarInstance.removeTableHeadElement();
      var numCells = 4;
      var yearCell = 12;
      var tdEles = [];
      var localDate = new Date(this.islamicInValue(this.calendarInstance.currentDate));
      var islamicDate = this.getIslamicDate(localDate);
      var gregorianObject = HijriParser.toGregorian(islamicDate.year, 1, 1);
      localDate = gregorianObject;
      var localYr = localDate.getFullYear();
      var startYr = new Date(this.islamicInValue(localYr - localYr % 10));
      var endYr = new Date(this.islamicInValue(localYr - localYr % 10 + (10 - 1)));
      var startFullYr = startYr.getFullYear();
      var endFullYr = endYr.getFullYear();
      var startHdrYr = this.calendarInstance.globalize.formatDate(startYr, { type: "dateTime", format: "y", calendar: "islamic" });
      var endHdrYr = this.calendarInstance.globalize.formatDate(endYr, { type: "dateTime", format: "y", calendar: "islamic" });
      this.calendarInstance.headerTitleElement.textContent = startHdrYr + " - " + endHdrYr;
      var start = new Date(localYr - localYr % 10 - 2, 0, 1);
      var startYear = start.getFullYear();
      for (var rowCount = 1; rowCount <= yearCell; ++rowCount) {
        var year = startYear + rowCount;
        localDate.setFullYear(year);
        localDate.setDate(1);
        localDate.setMonth(0);
        var islamicDate_2 = this.getIslamicDate(localDate);
        var gregorianObject_2 = HijriParser.toGregorian(islamicDate_2.year, 1, 1);
        localDate = gregorianObject_2;
        var tdEle = this.islamicDayCell(localDate);
        attributes(tdEle, { "role": "gridcell" });
        var dayLink = this.calendarInstance.createElement("span");
        dayLink.textContent = this.calendarInstance.globalize.formatDate(localDate, { type: "dateTime", format: "y", calendar: "islamic" });
        if (year < startFullYr || year > endFullYr) {
          addClass([tdEle], OTHERMONTH3);
        } else if (year < new Date(this.islamicInValue(this.calendarInstance.min)).getFullYear() || year > new Date(this.islamicInValue(this.calendarInstance.max)).getFullYear()) {
          addClass([tdEle], DISABLED5);
        } else if (!isNullOrUndefined(value) && this.getIslamicDate(localDate).year === this.getIslamicDate(value).year) {
          addClass([tdEle], SELECTED5);
        } else {
          if (localDate.getFullYear() === this.calendarInstance.currentDate.getFullYear() && !tdEle.classList.contains(DISABLED5)) {
            addClass([tdEle], FOCUSEDDATE3);
          }
        }
        if (!tdEle.classList.contains(DISABLED5)) {
          EventHandler.add(tdEle, "click", this.calendarInstance.clickHandler, this.calendarInstance);
        }
        tdEle.appendChild(dayLink);
        tdEles.push(tdEle);
      }
      this.islamicRenderTemplate(tdEles, numCells, "e-decade", e, value);
    };
    Islamic2.prototype.islamicDayCell = function(localDate) {
      var dateFormatOptions = { skeleton: "full", type: "dateTime", calendar: "islamic" };
      var formatDate = this.calendarInstance.globalize.formatDate(localDate, dateFormatOptions);
      var date = this.calendarInstance.globalize.parseDate(formatDate, dateFormatOptions);
      var value = date.valueOf();
      var attrs = {
        className: CELL2,
        attrs: { "id": "" + getUniqueID("" + value), "aria-selected": "false", "role": "gridcell" }
      };
      return this.calendarInstance.createElement("td", attrs);
    };
    Islamic2.prototype.islamicRenderTemplate = function(elements, count, classNm, e, value) {
      var view = this.calendarInstance.getViewNumber(this.calendarInstance.currentView());
      var trEle;
      this.calendarInstance.tableBodyElement = this.calendarInstance.createElement("tbody");
      this.calendarInstance.table.appendChild(this.calendarInstance.tableBodyElement);
      removeClass([this.calendarInstance.contentElement, this.calendarInstance.headerElement], [MONTH4, DECADE2, YEAR4]);
      addClass([this.calendarInstance.contentElement, this.calendarInstance.headerElement], [classNm]);
      var weekNumCell = 41;
      var numberCell = 35;
      var otherMonthCell = 6;
      var row = count;
      var rowCount = 0;
      for (var dayCell = 0; dayCell < elements.length / count; ++dayCell) {
        trEle = this.calendarInstance.createElement("tr", { attrs: { "role": "row" } });
        for (rowCount = 0 + rowCount; rowCount < row; rowCount++) {
          if (!elements[rowCount].classList.contains("e-week-number") && !isNullOrUndefined(elements[rowCount].children[0])) {
            addClass([elements[rowCount].children[0]], [LINK2]);
            rippleEffect(elements[rowCount].children[0], {
              duration: 600,
              isCenterRipple: true
            });
          }
          trEle.appendChild(elements[rowCount]);
          if (this.calendarInstance.weekNumber && rowCount === otherMonthCell + 1 && elements[otherMonthCell + 1].classList.contains(OTHERMONTH3)) {
            addClass([trEle], OTHERMONTHROW2);
          }
          if (!this.calendarInstance.weekNumber && rowCount === otherMonthCell && elements[otherMonthCell].classList.contains(OTHERMONTH3)) {
            addClass([trEle], OTHERMONTHROW2);
          }
          if (this.calendarInstance.weekNumber) {
            if (rowCount === weekNumCell && elements[weekNumCell].classList.contains(OTHERMONTH3)) {
              addClass([trEle], OTHERMONTHROW2);
            }
          } else {
            if (rowCount === numberCell && elements[numberCell].classList.contains(OTHERMONTH3)) {
              addClass([trEle], OTHERMONTHROW2);
            }
          }
        }
        row = row + count;
        rowCount = rowCount + 0;
        this.calendarInstance.tableBodyElement.appendChild(trEle);
      }
      this.calendarInstance.table.querySelector("tbody").className = this.calendarInstance.effect;
      this.islamicIconHandler();
      if (view !== this.calendarInstance.getViewNumber(this.calendarInstance.currentView()) || view === 0 && view !== this.calendarInstance.getViewNumber(this.calendarInstance.currentView())) {
        this.calendarInstance.navigateHandler(e);
      }
      this.calendarInstance.setAriaActiveDescendant();
      this.calendarInstance.changedArgs = { value: this.calendarInstance.value, values: this.calendarInstance.values };
      this.calendarInstance.changeHandler();
    };
    Islamic2.prototype.islamicCompareMonth = function(start, end) {
      var hijriStart = this.getIslamicDate(start);
      var hijriEnd = this.getIslamicDate(end);
      var result;
      if (hijriStart.year > hijriEnd.year) {
        result = 1;
      } else if (hijriStart.year < hijriEnd.year) {
        result = -1;
      } else {
        result = hijriStart.month === hijriEnd.month ? 0 : hijriStart.month > hijriEnd.month ? 1 : -1;
      }
      return result;
    };
    Islamic2.prototype.islamicCompare = function(startDate, endDate, modifier) {
      var hijriStart = this.getIslamicDate(startDate);
      var hijriEnd = this.getIslamicDate(endDate);
      var start = hijriEnd.year;
      var end;
      var result;
      end = start;
      result = 0;
      if (modifier) {
        start = start - start % modifier;
        end = start - start % modifier + modifier - 1;
      }
      if (hijriStart.year > end) {
        result = 1;
      } else if (this.calendarInstance.currentView() === "Decade" && hijriStart.year < start && !(startDate.getFullYear() >= minDecade && startDate.getFullYear() <= maxDecade)) {
        result = -1;
      } else if (hijriStart.year < start && this.calendarInstance.currentView() === "Year") {
        result = -1;
      }
      return result;
    };
    Islamic2.prototype.getIslamicDate = function(date) {
      return HijriParser.getHijriDate(date);
    };
    Islamic2.prototype.toGregorian = function(year, month, date) {
      return HijriParser.toGregorian(year, month, date);
    };
    Islamic2.prototype.hijriCompareYear = function(start, end) {
      return this.islamicCompare(start, end, 0);
    };
    Islamic2.prototype.hijriCompareDecade = function(start, end) {
      return this.islamicCompare(start, end, 10);
    };
    Islamic2.prototype.destroy = function() {
      this.calendarInstance = null;
    };
    Islamic2.prototype.islamicInValue = function(inValue) {
      if (inValue instanceof Date) {
        return inValue.toUTCString();
      } else {
        return "" + inValue;
      }
    };
    return Islamic2;
  }()
);

// node_modules/@syncfusion/ej2-calendars/src/maskbase/masked-date-time.js
var ARROWLEFT = "ArrowLeft";
var ARROWRIGHT = "ArrowRight";
var ARROWUP = "ArrowUp";
var ARROWDOWN = "ArrowDown";
var TAB = "Tab";
var SHIFTTAB = "shiftTab";
var END = "End";
var HOME = "Home";
var MaskedDateTime = (
  /** @class */
  function() {
    function MaskedDateTime2(parent) {
      this.mask = "";
      this.defaultConstant = {
        day: "day",
        month: "month",
        year: "year",
        hour: "hour",
        minute: "minute",
        second: "second",
        dayOfTheWeek: "day of the week"
      };
      this.hiddenMask = "";
      this.validCharacters = "dMyhmHfasz";
      this.isDayPart = false;
      this.isMonthPart = false;
      this.isYearPart = false;
      this.isHourPart = false;
      this.isMinutePart = false;
      this.isSecondsPart = false;
      this.isMilliSecondsPart = false;
      this.monthCharacter = "";
      this.periodCharacter = "";
      this.isHiddenMask = false;
      this.isComplete = false;
      this.isNavigate = false;
      this.formatRegex = /EEEEE|EEEE|EEE|EE|E|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|HH|H|hh|h|mm|m|fff|ff|f|aa|a|ss|s|zzzz|zzz|zz|z|'[^']*'|'[^']*'/g;
      this.isDeletion = false;
      this.isShortYear = false;
      this.isDeleteKey = false;
      this.isDateZero = false;
      this.isMonthZero = false;
      this.isYearZero = false;
      this.dayTypeCount = 0;
      this.monthTypeCount = 0;
      this.hourTypeCount = 0;
      this.minuteTypeCount = 0;
      this.secondTypeCount = 0;
      this.parent = parent;
      this.dateformat = this.getCulturedFormat();
      this.maskDateValue = this.parent.value != null ? /* @__PURE__ */ new Date(+this.parent.value) : /* @__PURE__ */ new Date();
      this.maskDateValue.setMonth(0);
      this.maskDateValue.setHours(0);
      this.maskDateValue.setMinutes(0);
      this.maskDateValue.setSeconds(0);
      this.previousDate = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());
      this.removeEventListener();
      this.addEventListener();
    }
    MaskedDateTime2.prototype.getModuleName = function() {
      return "MaskedDateTime";
    };
    MaskedDateTime2.prototype.addEventListener = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.parent.on("createMask", this.createMask, this);
      this.parent.on("setMaskSelection", this.validCharacterCheck, this);
      this.parent.on("inputHandler", this.maskInputHandler, this);
      this.parent.on("keyDownHandler", this.maskKeydownHandler, this);
      this.parent.on("clearHandler", this.clearHandler, this);
    };
    MaskedDateTime2.prototype.removeEventListener = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.parent.off("createMask", this.createMask);
      this.parent.off("setMaskSelection", this.validCharacterCheck);
      this.parent.off("inputHandler", this.maskInputHandler);
      this.parent.off("keyDownHandler", this.maskKeydownHandler);
      this.parent.off("clearHandler", this.clearHandler);
    };
    MaskedDateTime2.prototype.createMask = function(dateformat) {
      this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = false;
      this.dateformat = this.getCulturedFormat();
      if (this.parent.maskPlaceholder.day)
        this.defaultConstant["day"] = this.parent.maskPlaceholder.day;
      if (this.parent.maskPlaceholder.month)
        this.defaultConstant["month"] = this.parent.maskPlaceholder.month;
      if (this.parent.maskPlaceholder.year)
        this.defaultConstant["year"] = this.parent.maskPlaceholder.year;
      if (this.parent.maskPlaceholder.hour)
        this.defaultConstant["hour"] = this.parent.maskPlaceholder.hour;
      if (this.parent.maskPlaceholder.minute)
        this.defaultConstant["minute"] = this.parent.maskPlaceholder.minute;
      if (this.parent.maskPlaceholder.second)
        this.defaultConstant["second"] = this.parent.maskPlaceholder.second;
      if (this.parent.maskPlaceholder.dayOfTheWeek)
        this.defaultConstant["dayOfTheWeek"] = this.parent.maskPlaceholder.dayOfTheWeek.toString();
      this.getCUltureMaskFormat();
      var inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = true;
      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = false;
      this.previousHiddenMask = this.hiddenMask;
      this.mask = this.previousValue = inputValue;
      this.parent.maskedDateValue = this.mask;
      if (this.parent.value) {
        this.setDynamicValue();
      }
    };
    MaskedDateTime2.prototype.getCUltureMaskFormat = function() {
      this.l10n = new L10n(this.parent.moduleName, this.defaultConstant, this.parent.locale);
      this.objectString = Object.keys(this.defaultConstant);
      for (var i = 0; i < this.objectString.length; i++) {
        this.defaultConstant[this.objectString[i].toString()] = this.l10n.getConstant(this.objectString[i].toString());
      }
    };
    MaskedDateTime2.prototype.validCharacterCheck = function() {
      var start = this.parent.inputElement.selectionStart;
      for (var i = start, j = start - 1; i < this.hiddenMask.length || j >= 0; i++, j--) {
        if (i < this.hiddenMask.length && this.validCharacters.indexOf(this.hiddenMask[i]) !== -1) {
          this.setSelection(this.hiddenMask[i]);
          return;
        }
        if (j >= 0 && this.validCharacters.indexOf(this.hiddenMask[j]) !== -1) {
          this.setSelection(this.hiddenMask[j]);
          return;
        }
      }
    };
    MaskedDateTime2.prototype.setDynamicValue = function() {
      this.maskDateValue = this.parent.value;
      this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = true;
      this.updateValue();
    };
    MaskedDateTime2.prototype.setSelection = function(validChar) {
      var start = -1;
      var end = 0;
      for (var i = 0; i < this.hiddenMask.length; i++) {
        if (this.hiddenMask[i] === validChar) {
          end = i + 1;
          if (start === -1) {
            start = i;
          }
        }
      }
      if (start < 0) {
        start = 0;
      }
      this.parent.inputElement.setSelectionRange(start, end);
    };
    MaskedDateTime2.prototype.maskKeydownHandler = function(args) {
      if (args.e.key === "Delete") {
        this.isDeleteKey = true;
        return;
      }
      if (!args.e.altKey && !args.e.ctrlKey && (args.e.key === ARROWLEFT || args.e.key === ARROWRIGHT || args.e.key === SHIFTTAB || args.e.key === TAB || args.e.action === SHIFTTAB || args.e.key === END || args.e.key === HOME)) {
        var start = this.parent.inputElement.selectionStart;
        var end = this.parent.inputElement.selectionEnd;
        var length_1 = this.parent.inputElement.value.length;
        if (start == 0 && end == length_1 && (args.e.key === TAB || args.e.action === SHIFTTAB)) {
          var index = args.e.action === SHIFTTAB ? end : 0;
          this.parent.inputElement.selectionStart = this.parent.inputElement.selectionEnd = index;
        }
        if (args.e.key === END || args.e.key === HOME) {
          var range = args.e.key === END ? length_1 : 0;
          this.parent.inputElement.selectionStart = this.parent.inputElement.selectionEnd = range;
        }
        this.navigateSelection(args.e.key === ARROWLEFT || args.e.action === SHIFTTAB || args.e.key === END ? true : false);
      }
      if (!args.e.altKey && !args.e.ctrlKey && (args.e.key === ARROWUP || args.e.key === ARROWDOWN)) {
        var start = this.parent.inputElement.selectionStart;
        this.dateAlteration(args.e.key === ARROWDOWN ? true : false);
        var inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
        this.isHiddenMask = true;
        this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
        this.isHiddenMask = false;
        this.previousHiddenMask = this.hiddenMask;
        this.previousValue = inputValue;
        this.parent.inputElement.value = inputValue;
        this.parent.inputElement.selectionStart = start;
        this.validCharacterCheck();
      }
    };
    MaskedDateTime2.prototype.differenceCheck = function() {
      var start = this.parent.inputElement.selectionStart;
      var inputValue = this.parent.inputElement.value;
      var previousVal = this.previousValue.substring(0, start + this.previousValue.length - inputValue.length);
      var newVal = inputValue.substring(0, start);
      var newDateValue = /* @__PURE__ */ new Date(+this.maskDateValue);
      var maxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();
      if (previousVal.indexOf(newVal) === 0 && (newVal.length === 0 || this.previousHiddenMask[newVal.length - 1] !== this.previousHiddenMask[newVal.length])) {
        for (var i = newVal.length; i < previousVal.length; i++) {
          if (this.previousHiddenMask[i] !== "" && this.validCharacters.indexOf(this.previousHiddenMask[i]) >= 0) {
            this.isDeletion = this.handleDeletion(this.previousHiddenMask[i], false);
          }
        }
        if (this.isDeletion) {
          return;
        }
      }
      switch (this.previousHiddenMask[start - 1]) {
        case "d":
          var date = (this.isDayPart && newDateValue.getDate().toString().length < 2 ? newDateValue.getDate() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isDateZero = newVal[start - 1] == "0";
          if (isNaN(date)) {
            return;
          }
          for (var i = 0; date > maxDate; i++) {
            date = parseInt(date.toString().slice(1), 10);
          }
          if (date >= 1) {
            newDateValue.setDate(date);
            this.isNavigate = date.toString().length === 2;
            this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
            if (newDateValue.getMonth() !== this.maskDateValue.getMonth()) {
              return;
            }
            this.isDayPart = true;
            this.dayTypeCount = this.dayTypeCount + 1;
          } else {
            this.isDayPart = false;
            this.dayTypeCount = this.isDateZero ? this.dayTypeCount + 1 : this.dayTypeCount;
          }
          break;
        case "M":
          var month = void 0;
          if (newDateValue.getMonth().toString().length < 2) {
            month = (this.isMonthPart ? (newDateValue.getMonth() + 1) * 10 : 0) + parseInt(newVal[start - 1], 10);
          } else {
            month = parseInt(newVal[start - 1], 10);
          }
          this.isMonthZero = newVal[start - 1] == "0";
          if (!isNaN(month)) {
            while (month > 12) {
              month = parseInt(month.toString().slice(1), 10);
            }
            if (month >= 1) {
              newDateValue.setMonth(month - 1);
              this.isNavigate = month.toString().length === 2;
              if (newDateValue.getMonth() !== month - 1) {
                newDateValue.setDate(1);
                newDateValue.setMonth(month - 1);
              }
              if (this.isDayPart) {
                var previousMaxDate = new Date(this.previousDate.getFullYear(), this.previousDate.getMonth() + 1, 0).getDate();
                var currentMaxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();
                if (this.previousDate.getDate() == previousMaxDate && currentMaxDate <= previousMaxDate) {
                  newDateValue.setDate(currentMaxDate);
                }
              }
              this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
              this.isMonthPart = true;
              this.monthTypeCount = this.monthTypeCount + 1;
            } else {
              newDateValue.setMonth(0);
              this.isMonthPart = false;
              this.monthTypeCount = this.isMonthZero ? this.monthTypeCount + 1 : this.monthTypeCount;
            }
          } else {
            var monthString = this.getCulturedValue("months[stand-alone].wide");
            var monthValue = Object.keys(monthString);
            this.monthCharacter += newVal[start - 1].toLowerCase();
            while (this.monthCharacter.length > 0) {
              var i = 1;
              for (var _i = 0, monthValue_1 = monthValue; _i < monthValue_1.length; _i++) {
                var months = monthValue_1[_i];
                if (monthString[i].toLowerCase().indexOf(this.monthCharacter) === 0) {
                  newDateValue.setMonth(i - 1);
                  this.isMonthPart = true;
                  this.maskDateValue = newDateValue;
                  return;
                }
                i++;
              }
              this.monthCharacter = this.monthCharacter.substring(1, this.monthCharacter.length);
            }
          }
          break;
        case "y":
          var year = (this.isYearPart && (newDateValue.getFullYear().toString().length < 4 && !this.isShortYear) ? newDateValue.getFullYear() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isShortYear = false;
          this.isYearZero = newVal[start - 1] == "0";
          if (isNaN(year)) {
            return;
          }
          while (year > 9999) {
            year = parseInt(year.toString().slice(1), 10);
          }
          if (year < 1) {
            this.isYearPart = false;
          } else {
            newDateValue.setFullYear(year);
            if (year.toString().length === 4) {
              this.isNavigate = true;
            }
            this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
            this.isYearPart = true;
          }
          break;
        case "h":
          this.hour = (this.isHourPart && (newDateValue.getHours() % 12 || 12).toString().length < 2 ? (newDateValue.getHours() % 12 || 12) * 10 : 0) + parseInt(newVal[start - 1], 10);
          if (isNaN(this.hour)) {
            return;
          }
          while (this.hour > 12) {
            this.hour = parseInt(this.hour.toString().slice(1), 10);
          }
          newDateValue.setHours(Math.floor(newDateValue.getHours() / 12) * 12 + this.hour % 12);
          this.isNavigate = this.hour.toString().length === 2;
          this.isHourPart = true;
          this.hourTypeCount = this.hourTypeCount + 1;
          break;
        case "H":
          this.hour = (this.isHourPart && newDateValue.getHours().toString().length < 2 ? newDateValue.getHours() * 10 : 0) + parseInt(newVal[start - 1], 10);
          if (isNaN(this.hour)) {
            return;
          }
          for (var i = 0; this.hour > 23; i++) {
            this.hour = parseInt(this.hour.toString().slice(1), 10);
          }
          newDateValue.setHours(this.hour);
          this.isNavigate = this.hour.toString().length === 2;
          this.isHourPart = true;
          this.hourTypeCount = this.hourTypeCount + 1;
          break;
        case "m":
          var minutes = (this.isMinutePart && newDateValue.getMinutes().toString().length < 2 ? newDateValue.getMinutes() * 10 : 0) + parseInt(newVal[start - 1], 10);
          if (isNaN(minutes)) {
            return;
          }
          for (var i = 0; minutes > 59; i++) {
            minutes = parseInt(minutes.toString().slice(1), 10);
          }
          newDateValue.setMinutes(minutes);
          this.isNavigate = minutes.toString().length === 2;
          this.isMinutePart = true;
          this.minuteTypeCount = this.minuteTypeCount + 1;
          break;
        case "s":
          var seconds = (this.isSecondsPart && newDateValue.getSeconds().toString().length < 2 ? newDateValue.getSeconds() * 10 : 0) + parseInt(newVal[start - 1], 10);
          if (isNaN(seconds)) {
            return;
          }
          for (var i = 0; seconds > 59; i++) {
            seconds = parseInt(seconds.toString().slice(1), 10);
          }
          newDateValue.setSeconds(seconds);
          this.isNavigate = seconds.toString().length === 2;
          this.isSecondsPart = true;
          this.secondTypeCount = this.secondTypeCount + 1;
          break;
        case "a":
          this.periodCharacter += newVal[start - 1].toLowerCase();
          var periodString = this.getCulturedValue("dayPeriods.format.wide");
          var periodkeys = Object.keys(periodString);
          for (var i = 0; this.periodCharacter.length > 0; i++) {
            if (periodString[periodkeys[0]].toLowerCase().indexOf(this.periodCharacter) === 0 && newDateValue.getHours() >= 12 || periodString[periodkeys[1]].toLowerCase().indexOf(this.periodCharacter) === 0 && newDateValue.getHours() < 12) {
              newDateValue.setHours((newDateValue.getHours() + 12) % 24);
              this.maskDateValue = newDateValue;
            }
            this.periodCharacter = this.periodCharacter.substring(1, this.periodCharacter.length);
          }
          break;
        default:
          break;
      }
      this.maskDateValue = newDateValue;
    };
    MaskedDateTime2.prototype.formatCheck = function() {
      var proxy = this;
      function formatValueSpecifier(formattext) {
        var isSymbol;
        var result;
        var daysAbbreviated = proxy.getCulturedValue("days[stand-alone].abbreviated");
        var dayKeyAbbreviated = Object.keys(daysAbbreviated);
        var daysWide = proxy.getCulturedValue("days[stand-alone].wide");
        var dayKeyWide = Object.keys(daysWide);
        var daysNarrow = proxy.getCulturedValue("days[stand-alone].narrow");
        var dayKeyNarrow = Object.keys(daysNarrow);
        var monthAbbreviated = proxy.getCulturedValue("months[stand-alone].abbreviated");
        var monthWide = proxy.getCulturedValue("months[stand-alone].wide");
        var periodString = proxy.getCulturedValue("dayPeriods.format.wide");
        var periodkeys = Object.keys(periodString);
        var milliseconds;
        var dateOptions;
        switch (formattext) {
          case "ddd":
          case "dddd":
          case "d":
            result = proxy.isDayPart ? proxy.maskDateValue.getDate().toString() : proxy.defaultConstant["day"].toString();
            result = proxy.zeroCheck(proxy.isDateZero, proxy.isDayPart, result);
            break;
          case "dd":
            result = proxy.isDayPart ? proxy.roundOff(proxy.maskDateValue.getDate(), 2) : proxy.defaultConstant["day"].toString();
            result = proxy.zeroCheck(proxy.isDateZero, proxy.isDayPart, result);
            if (proxy.dayTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.dayTypeCount = 0;
            }
            break;
          case "E":
          case "EE":
          case "EEE":
            result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysAbbreviated[dayKeyAbbreviated[proxy.maskDateValue.getDay()]].toString() : proxy.defaultConstant["dayOfTheWeek"].toString();
            break;
          case "EEEE":
            result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysWide[dayKeyWide[proxy.maskDateValue.getDay()]].toString() : proxy.defaultConstant["dayOfTheWeek"].toString();
            break;
          case "EEEEE":
            result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysNarrow[dayKeyNarrow[proxy.maskDateValue.getDay()]].toString() : proxy.defaultConstant["dayOfTheWeek"].toString();
            break;
          case "M":
            result = proxy.isMonthPart ? (proxy.maskDateValue.getMonth() + 1).toString() : proxy.defaultConstant["month"].toString();
            result = proxy.zeroCheck(proxy.isMonthZero, proxy.isMonthPart, result);
            break;
          case "MM":
            result = proxy.isMonthPart ? proxy.roundOff(proxy.maskDateValue.getMonth() + 1, 2) : proxy.defaultConstant["month"].toString();
            result = proxy.zeroCheck(proxy.isMonthZero, proxy.isMonthPart, result);
            if (proxy.monthTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.monthTypeCount = 0;
            }
            break;
          case "MMM":
            result = proxy.isMonthPart ? monthAbbreviated[proxy.maskDateValue.getMonth() + 1] : proxy.defaultConstant["month"].toString();
            break;
          case "MMMM":
            result = proxy.isMonthPart ? monthWide[proxy.maskDateValue.getMonth() + 1] : proxy.defaultConstant["month"].toString();
            break;
          case "yy":
            result = proxy.isYearPart ? proxy.roundOff(proxy.maskDateValue.getFullYear() % 100, 2) : proxy.defaultConstant["year"].toString();
            result = proxy.zeroCheck(proxy.isYearZero, proxy.isYearPart, result);
            if (proxy.isYearPart) {
              proxy.isNavigate = proxy.isShortYear = (proxy.maskDateValue.getFullYear() % 100).toString().length === 2;
            }
            break;
          case "y":
          case "yyyy":
            result = proxy.isYearPart ? proxy.roundOff(proxy.maskDateValue.getFullYear(), 4) : proxy.defaultConstant["year"].toString();
            result = proxy.zeroCheck(proxy.isYearZero, proxy.isYearPart, result);
            break;
          case "h":
            result = proxy.isHourPart ? (proxy.maskDateValue.getHours() % 12 || 12).toString() : proxy.defaultConstant["hour"].toString();
            break;
          case "hh":
            result = proxy.isHourPart ? proxy.roundOff(proxy.maskDateValue.getHours() % 12 || 12, 2) : proxy.defaultConstant["hour"].toString();
            if (proxy.hourTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.hourTypeCount = 0;
            }
            break;
          case "H":
            result = proxy.isHourPart ? proxy.maskDateValue.getHours().toString() : proxy.defaultConstant["hour"].toString();
            break;
          case "HH":
            result = proxy.isHourPart ? proxy.roundOff(proxy.maskDateValue.getHours(), 2) : proxy.defaultConstant["hour"].toString();
            if (proxy.hourTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.hourTypeCount = 0;
            }
            break;
          case "m":
            result = proxy.isMinutePart ? proxy.maskDateValue.getMinutes().toString() : proxy.defaultConstant["minute"].toString();
            break;
          case "mm":
            result = proxy.isMinutePart ? proxy.roundOff(proxy.maskDateValue.getMinutes(), 2) : proxy.defaultConstant["minute"].toString();
            if (proxy.minuteTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.minuteTypeCount = 0;
            }
            break;
          case "s":
            result = proxy.isSecondsPart ? proxy.maskDateValue.getSeconds().toString() : proxy.defaultConstant["second"].toString();
            break;
          case "ss":
            result = proxy.isSecondsPart ? proxy.roundOff(proxy.maskDateValue.getSeconds(), 2) : proxy.defaultConstant["second"].toString();
            if (proxy.secondTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.secondTypeCount = 0;
            }
            break;
          case "f":
            result = Math.floor(proxy.maskDateValue.getMilliseconds() / 100).toString();
            break;
          case "ff":
            milliseconds = proxy.maskDateValue.getMilliseconds();
            if (proxy.maskDateValue.getMilliseconds() > 99) {
              milliseconds = Math.floor(proxy.maskDateValue.getMilliseconds() / 10);
            }
            result = proxy.roundOff(milliseconds, 2);
            break;
          case "fff":
            result = proxy.roundOff(proxy.maskDateValue.getMilliseconds(), 3);
            break;
          case "a":
          case "aa":
            result = proxy.maskDateValue.getHours() < 12 ? periodString[periodkeys[0]] : periodString[periodkeys[1]];
            break;
          case "z":
          case "zz":
          case "zzz":
          case "zzzz":
            dateOptions = {
              format: formattext,
              type: "dateTime",
              skeleton: "yMd",
              calendar: proxy.parent.calendarMode
            };
            result = proxy.parent.globalize.formatDate(proxy.maskDateValue, dateOptions);
            break;
        }
        result = result !== void 0 ? result : formattext.slice(1, formattext.length - 1);
        if (proxy.isHiddenMask) {
          var hiddenChar = "";
          for (var i = 0; i < result.length; i++) {
            hiddenChar += formattext[0];
          }
          return hiddenChar;
        } else {
          return result;
        }
      }
      return formatValueSpecifier;
    };
    MaskedDateTime2.prototype.maskInputHandler = function() {
      var start = this.parent.inputElement.selectionStart;
      var selectionChar = this.previousHiddenMask[start - 1];
      var inputValue;
      this.differenceCheck();
      inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = true;
      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isDateZero = this.isMonthZero = this.isYearZero = false;
      this.isHiddenMask = false;
      this.previousHiddenMask = this.hiddenMask;
      this.previousValue = inputValue;
      this.parent.inputElement.value = inputValue;
      this.parent.inputElement.selectionStart = start;
      this.validCharacterCheck();
      if ((this.isNavigate || this.isDeletion) && !this.isDeleteKey) {
        var isbackward = this.isNavigate ? false : true;
        this.isNavigate = this.isDeletion = false;
        this.navigateSelection(isbackward);
      }
      this.isDeleteKey = false;
    };
    MaskedDateTime2.prototype.navigateSelection = function(isbackward) {
      var start = this.parent.inputElement.selectionStart;
      var end = this.parent.inputElement.selectionEnd;
      var formatIndex = isbackward ? start - 1 : end + 1;
      while (formatIndex < this.hiddenMask.length && formatIndex >= 0) {
        if (this.validCharacters.indexOf(this.hiddenMask[formatIndex]) >= 0) {
          this.setSelection(this.hiddenMask[formatIndex]);
          break;
        }
        formatIndex = formatIndex + (isbackward ? -1 : 1);
      }
    };
    MaskedDateTime2.prototype.roundOff = function(val, count) {
      var valueText = val.toString();
      var length = count - valueText.length;
      var result = "";
      for (var i = 0; i < length; i++) {
        result += "0";
      }
      return result + valueText;
    };
    MaskedDateTime2.prototype.zeroCheck = function(isZero, isDayPart, resultValue) {
      var result = resultValue;
      if (isZero && !isDayPart) {
        result = "0";
      }
      return result;
    };
    MaskedDateTime2.prototype.handleDeletion = function(format, isSegment) {
      switch (format) {
        case "d":
          this.isDayPart = isSegment;
          break;
        case "M":
          this.isMonthPart = isSegment;
          if (!isSegment) {
            this.maskDateValue.setMonth(0);
            this.monthCharacter = "";
          }
          break;
        case "y":
          this.isYearPart = isSegment;
          break;
        case "H":
        case "h":
          this.isHourPart = isSegment;
          if (!isSegment) {
            this.periodCharacter = "";
          }
          break;
        case "m":
          this.isMinutePart = isSegment;
          break;
        case "s":
          this.isSecondsPart = isSegment;
          break;
        default:
          return false;
      }
      return true;
    };
    MaskedDateTime2.prototype.dateAlteration = function(isDecrement) {
      var start = this.parent.inputElement.selectionStart;
      var formatText = "";
      if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {
        formatText = this.hiddenMask[start];
      } else {
        return;
      }
      var newDateValue = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());
      this.previousDate = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());
      var incrementValue = isDecrement ? -1 : 1;
      switch (formatText) {
        case "d":
          newDateValue.setDate(newDateValue.getDate() + incrementValue);
          break;
        case "M":
          var newMonth = newDateValue.getMonth() + incrementValue;
          newDateValue.setDate(1);
          newDateValue.setMonth(newMonth);
          if (this.isDayPart) {
            var previousMaxDate = new Date(this.previousDate.getFullYear(), this.previousDate.getMonth() + 1, 0).getDate();
            var currentMaxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();
            if (this.previousDate.getDate() == previousMaxDate && currentMaxDate <= previousMaxDate) {
              newDateValue.setDate(currentMaxDate);
            } else {
              newDateValue.setDate(this.previousDate.getDate());
            }
          } else {
            newDateValue.setDate(this.previousDate.getDate());
          }
          this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
          break;
        case "y":
          newDateValue.setFullYear(newDateValue.getFullYear() + incrementValue);
          break;
        case "H":
        case "h":
          newDateValue.setHours(newDateValue.getHours() + incrementValue);
          break;
        case "m":
          newDateValue.setMinutes(newDateValue.getMinutes() + incrementValue);
          break;
        case "s":
          newDateValue.setSeconds(newDateValue.getSeconds() + incrementValue);
          break;
        case "a":
          newDateValue.setHours((newDateValue.getHours() + 12) % 24);
          break;
        default:
          break;
      }
      this.maskDateValue = newDateValue.getFullYear() > 0 ? newDateValue : this.maskDateValue;
      if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {
        this.handleDeletion(this.hiddenMask[start], true);
      }
    };
    MaskedDateTime2.prototype.getCulturedValue = function(format) {
      var locale = this.parent.locale;
      var result;
      if (locale === "en" || locale === "en-US") {
        result = getValue(format, getDefaultDateObject());
      } else {
        result = getValue("main." + locale + (".dates.calendars.gregorian." + format), cldrData);
      }
      return result;
    };
    MaskedDateTime2.prototype.getCulturedFormat = function() {
      var formatString = this.getCulturedValue("dateTimeFormats[availableFormats].yMd").toString();
      if (this.parent.moduleName == "datepicker") {
        formatString = this.getCulturedValue("dateTimeFormats[availableFormats].yMd").toString();
        if (this.parent.format && this.parent.formatString) {
          formatString = this.parent.formatString;
        }
      }
      if (this.parent.moduleName == "datetimepicker") {
        formatString = this.getCulturedValue("dateTimeFormats[availableFormats].yMd").toString();
        if (this.parent.dateTimeFormat) {
          formatString = this.parent.dateTimeFormat;
        }
      }
      if (this.parent.moduleName == "timepicker") {
        formatString = this.parent.cldrTimeFormat();
      }
      return formatString;
    };
    MaskedDateTime2.prototype.clearHandler = function() {
      this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = false;
      this.updateValue();
    };
    MaskedDateTime2.prototype.updateValue = function() {
      this.monthCharacter = this.periodCharacter = "";
      var inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = true;
      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = false;
      this.previousHiddenMask = this.hiddenMask;
      this.previousValue = inputValue;
      this.parent.updateInputValue(inputValue);
    };
    MaskedDateTime2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return MaskedDateTime2;
  }()
);

export {
  ZipArchive,
  ZipArchiveItem,
  PdfVerticalAlignment,
  PdfTextAlignment,
  PdfColor,
  PointF,
  SizeF,
  RectangleF,
  PdfSolidBrush,
  PdfFontStyle,
  PdfFontFamily,
  PdfStringFormat,
  PdfPageOrientation,
  PdfPageSettings,
  PdfPen,
  PdfBitmap,
  PdfDocument,
  PdfStandardFont,
  PdfBorders,
  PdfPaddings,
  PdfTextWebLink,
  PdfPageNumberField,
  PdfCompositeField,
  PdfPageCountField,
  PdfGrid,
  PdfTrueTypeFont,
  PdfPageTemplateElement,
  DatePicker,
  DateRangePicker,
  TimePicker,
  DateTimePicker
};
//# sourceMappingURL=chunk-YBB3BQBL.js.map
